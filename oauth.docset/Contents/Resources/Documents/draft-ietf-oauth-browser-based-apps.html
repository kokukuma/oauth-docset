<!DOCTYPE html>
<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html --><html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<title>
  
    draft-ietf-oauth-browser-based-apps-08
  
</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>
<!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.38.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.38.0/respond/dest/respond.min.js"></script>
    <![endif]-->
<link href="/feed/document-changes/draft-ietf-oauth-browser-based-apps/" rel="alternate" title="Document changes" type="application/atom+xml"/>
<meta content="OAuth 2.0 for Browser-Based Apps (Internet-Draft, 2021)" name="description"/>
<script src="https://www.ietf.org/lib/dt/7.38.0/d3/d3.min.js"></script>
<script src="https://www.ietf.org/lib/dt/7.38.0/jquery/jquery.min.js"></script>
<link href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/ietf-icon-blue3.png" rel="shortcut icon"/>
<link href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/apple-touch-icon.png" rel="apple-touch-icon"/>
</head>
<body style="padding-top: 0;">
<div class="content" id="content">
<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
<div class="rfcmarkup">
<div class="noprint" style="height: 6px;">
<div class="meta-info bgred" onclick="showLegend();" onmouseout="hideLegend()" onmouseover="this.style.cursor='pointer';" style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; " title="Click for colour legend.">Â </div>
<div class="meta-info noprint pre legend" id="legend" onmouseout="hideLegend();" onmouseover="showLegend();" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
</div>
</div>
<div class="noprint">
<pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.ietf.org/archive/id/draft-ietf-oauth-browser-based-apps-08.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.ietf.org/archive/id/draft-ietf-oauth-browser-based-apps-08.xml" title="XML source for this document">xml</a>|<a href="https://tools.ietf.org/pdf/draft-ietf-oauth-browser-based-apps-08.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/draft-ietf-oauth-browser-based-apps/08/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/draft-ietf-oauth-browser-based-apps/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/oauth/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-oauth-browser-based-apps@ietf.org?subject=draft-ietf-oauth-browser-based-apps" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=draft-ietf-oauth-browser-based-apps-08.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-oauth-browser-based-apps-08.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-oauth-browser-based-apps-08.txt" title="Run an idnits check of this document">Nits</a>]

Versions: (<a href="/doc/html/draft-parecki-oauth-browser-based-apps">draft-parecki-oauth-browser-based-apps</a>)                      
          <a href="/doc/html/draft-ietf-oauth-browser-based-apps-00">00</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-01">01</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-02">02</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-03">03</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-04">04</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-05">05</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-06">06</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-07">07</a> <a href="/doc/html/draft-ietf-oauth-browser-based-apps-08"><b>08</b></a>                                    </pre>
</div>
<div class="draftcontent">
<pre>Open Authentication Protocol                                  A. Parecki
Internet-Draft                                                      Okta
Intended status: Best Current Practice                          D. Waite
Expires: November 18, 2021                                 Ping Identity
                                                            May 17, 2021


                    <span class="h1">OAuth 2.0 for Browser-Based Apps</span>
                 <span class="h1">draft-ietf-oauth-browser-based-apps-08</span>

Abstract

   This specification details the security considerations and best
   practices that must be taken into account when developing browser-
   based applications that use OAuth 2.0.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="/doc/html/bcp78">BCP 78</a> and <a href="/doc/html/bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on November 18, 2021.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Notational Conventions  . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-4">4</a>.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-5">5</a>.  First-Party Applications  . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-6">6</a>.  Application Architecture Patterns . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     6.1.  Browser-Based Apps that Can Share Data with the Resource
           Server  . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-6.2">6.2</a>.  JavaScript Applications with a Backend  . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-6.3">6.3</a>.  JavaScript Applications without a Backend . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-7">7</a>.  Authorization Code Flow . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     7.1.  Initiating the Authorization Request from a Browser-Based
           Application . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-7.2">7.2</a>.  Handling the Authorization Code Redirect  . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-8">8</a>.  Refresh Tokens  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-9">9</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-9.1">9.1</a>.  Registration of Browser-Based Apps  . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-9.2">9.2</a>.  Client Authentication . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-9.3">9.3</a>.  Client Impersonation  . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-9.4">9.4</a>.  Cross-Site Request Forgery Protections  . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-9.5">9.5</a>.  Authorization Server Mix-Up Mitigation  . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-9.6">9.6</a>.  Cross-Domain Requests . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-9.7">9.7</a>.  Content Security Policy . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-9.8">9.8</a>.  OAuth Implicit Flow . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
       <a href="#section-9.8.1">9.8.1</a>.  Attacks on the Implicit Flow  . . . . . . . . . . . .  <a href="#page-14">14</a>
       <a href="#section-9.8.2">9.8.2</a>.  Countermeasures . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
       <a href="#section-9.8.3">9.8.3</a>.  Disadvantages of the Implicit Flow  . . . . . . . . .  <a href="#page-15">15</a>
       <a href="#section-9.8.4">9.8.4</a>.  Historic Note . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-9.9">9.9</a>.  Additional Security Considerations  . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-10">10</a>. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-11">11</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-11.1">11.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-11.2">11.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#appendix-A">Appendix A</a>.  Server Support Checklist . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#appendix-B">Appendix B</a>.  Document History . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#appendix-C">Appendix C</a>.  Acknowledgements . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.%20%20Introduction"></a></body></html><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   This specification describes the current best practices for
   implementing OAuth 2.0 authorization flows in applications executing
   in a browser.

   For native application developers using OAuth 2.0 and OpenID Connect,
   an IETF BCP (best current practice) was published that guides



<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   integration of these technologies.  This document is formally known
   as [<a href="/doc/html/rfc8252" title='"OAuth 2.0 for Native Apps"'>RFC8252</a>] or <a href="/doc/html/bcp212">BCP 212</a>, but nicknamed "AppAuth" after the OpenID
   Foundation-sponsored set of libraries that assist developers in
   adopting these practices.  [<a href="/doc/html/rfc8252" title='"OAuth 2.0 for Native Apps"'>RFC8252</a>] makes specific recommendations
   for how to securely implement OAuth in native applications, including
   incorporating additional OAuth extensions where needed.

   OAuth 2.0 for Browser-Based Apps addresses the similarities between
   implementing OAuth for native apps and browser-based apps, and
   includes additional considerations when running in a browser.  This
   is primarily focused on OAuth, except where OpenID Connect provides
   additional considerations.

   Many of these recommendations are derived from the OAuth 2.0 Security
   Best Current Practice [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] and browser-based apps
   are expected to follow those recommendations as well.  This draft
   expands on and further restricts various recommendations in
   [<a href="#ref-oauth-security-topics">oauth-security-topics</a>].

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.%20%20Notational%20Conventions"></a></body></html><a class="selflink" href="#section-2" id="section-2">2</a>.  Notational Conventions</span>

   The key words "<em>MUST</em>", "<em>MUST NOT</em>", "<em>REQUIRED</em>", "<em>SHALL</em>", "<em>SHALL NOT</em>",
   "<em>SHOULD</em>", "<em>SHOULD NOT</em>", "<em>RECOMMENDED</em>", "NOT <em>RECOMMENDED</em>", "<em>MAY</em>", and
   "<em>OPTIONAL</em>" in this document are to be interpreted as described in
   [<a href="/doc/html/rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.%20%20Terminology"></a></body></html><a class="selflink" href="#section-3" id="section-3">3</a>.  Terminology</span>

   In addition to the terms defined in referenced specifications, this
   document uses the following terms:

   "OAuth":  In this document, "OAuth" refers to OAuth 2.0, [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>]
      and [<a href="/doc/html/rfc6750" title='"The OAuth 2.0 Authorization Framework: Bearer Token Usage"'>RFC6750</a>].

   "Browser-based application":  An application that is dynamically
      downloaded and executed in a web browser, usually written in
      JavaScript.  Also sometimes referred to as a "single-page
      application", or "SPA".

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.%20%20Overview"></a></body></html><a class="selflink" href="#section-4" id="section-4">4</a>.  Overview</span>

   At the time that OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>] and [<a href="/doc/html/rfc6750" title='"The OAuth 2.0 Authorization Framework: Bearer Token Usage"'>RFC6750</a>] were created,
   browser-based JavaScript applications needed a solution that strictly
   complied with the same-origin policy.  Common deployments of OAuth
   2.0 involved an application running on a different domain than the
   authorization server, so it was historically not possible to use the
   Authorization Code flow which would require a cross-origin POST
   request.  This was one of the motivations for the definition of the



<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   Implicit flow, which returns the access token in the front channel
   via the fragment part of the URL, bypassing the need for a cross-
   origin POST request.

   However, there are several drawbacks to the Implicit flow, generally
   involving vulnerabilities associated with the exposure of the access
   token in the URL.  See <a href="#section-9.8">Section 9.8</a> for an analysis of these attacks
   and the drawbacks of using the Implicit flow in browsers.  Additional
   attacks and security considerations can be found in
   [<a href="#ref-oauth-security-topics">oauth-security-topics</a>].

   In recent years, widespread adoption of Cross-Origin Resource Sharing
   (CORS), which enables exceptions to the same-origin policy, allows
   browser-based apps to use the OAuth 2.0 Authorization Code flow and
   make a POST request to exchange the authorization code for an access
   token at the token endpoint.  In this flow, the access token is never
   exposed in the less secure front channel.  Furthermore, adding PKCE
   to the flow ensures that even if an authorization code is
   intercepted, it is unusable by an attacker.

   For this reason, and from other lessons learned, the current best
   practice for browser-based applications is to use the OAuth 2.0
   Authorization Code flow with PKCE.

   Browser-based applications:

   o  <em>MUST</em> use the OAuth 2.0 Authorization Code flow with the PKCE
      extension when obtaining an access token

   o  <em>MUST</em> Protect themselves against CSRF attacks by either:

      *  ensuring the authorization server supports PKCE, or

      *  by using the OAuth 2.0 "state" parameter or the OpenID Connect
         "nonce" parameter to carry one-time use CSRF tokens

   o  <em>MUST</em> Register one or more redirect URIs, and use only exact
      registered redirect URIs in authorization requests

   OAuth 2.0 authorization servers supporting browser-based
   applications:

   o  <em>MUST</em> Require exact matching of registered redirect URIs

   o  <em>MUST</em> Support the PKCE extension

   o  <em>MUST NOT</em> issue access tokens in the authorization response




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   o  If issuing refresh tokens to browser-based applications, then:

      *  <em>MUST</em> rotate refresh tokens on each use or use sender-
         constrained refresh tokens, and

      *  <em>MUST</em> set a maximum lifetime on refresh tokens or expire if they
         are not used in some amount of time

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/5.%20%20First-Party%20Applications"></a></body></html><a class="selflink" href="#section-5" id="section-5">5</a>.  First-Party Applications</span>

   While OAuth was initially created to allow third-party applications
   to access an API on behalf of a user, it has proven to be useful in a
   first-party scenario as well.  First-party apps are applications
   where the same organization provides both the API and the
   application.

   Examples of first-party applications are a web email client provided
   by the operator of the email account, or a mobile banking application
   created by bank itself.  (Note that there is no requirement that the
   application actually be developed by the same company; a mobile
   banking application developed by a contractor that is branded as the
   bank's application is still considered a first-party application.)
   The first-party app consideration is about the user's relationship to
   the application and the service.

   To conform to this best practice, first-party applications using
   OAuth or OpenID Connect <em>MUST</em> use a redirect-based flow (such as the
   OAuth Authorization Code flow) as described later in this document.

   The resource owner password credentials grant <em>MUST NOT</em> be used, as
   described in [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] <a href="#section-2.4">Section 2.4</a>.  Instead, by using
   the Authorization Code flow and redirecting the user to the
   authorization server, this provides the authorization server the
   opportunity to prompt the user for multi-factor authentication
   options, take advantage of single sign-on sessions, or use third-
   party identity providers.  In contrast, the resource owner password
   credentials grant does not provide any built-in mechanism for these,
   and would instead be extended with custom code.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/6.%20%20Application%20Architecture%20Patterns"></a></body></html><a class="selflink" href="#section-6" id="section-6">6</a>.  Application Architecture Patterns</span>

   There are three primary architectural patterns available when
   building browser-based applications.

   o  a JavaScript application that has methods of sharing data with
      resource servers, such as using common-domain cookies

   o  a JavaScript application with a backend



<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   o  a JavaScript application with no backend, accessing resource
      servers directly

   These three architectures have different use cases and
   considerations.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/6.1.%20%20Browser-Based%20Apps%20that%20Can%20Share%20Data%20with%20the%20Resource%20Server"></a></body></html><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Browser-Based Apps that Can Share Data with the Resource Server</span>

   For simple system architectures, such as when the JavaScript
   application is served from a domain that can share cookies with the
   domain of the API (resource server), OAuth adds additional attack
   vectors that could be avoided with a different solution.

   In particular, using any redirect-based mechanism of obtaining an
   access token enables the redirect-based attacks described in
   [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] <a href="#section-4">Section 4</a>, but if the application,
   authorization server and resource server share a domain, then it is
   unnecessary to use a redirect mechanism to communicate between them.

   An additional concern with handling access tokens in a browser is
   that as of the date of this publication, there is no secure storage
   mechanism where JavaScript code can keep the access token to be later
   used in an API request.  Using an OAuth flow results in the
   JavaScript code getting an access token, needing to store it
   somewhere, and then retrieve it to make an API request.

   Instead, a more secure design is to use an HTTP-only cookie between
   the JavaScript application and API so that the JavaScript code can't
   access the cookie value itself.  The Secure cookie attribute should
   be used to ensure the cookie is not included in unencrypted HTTP
   requests.  Additionally, the SameSite cookie attribute can be used to
   prevent CSRF attacks, or alternatively, the application and API could
   be written to use anti-CSRF tokens.

   OAuth was originally created for third-party or federated access to
   APIs, so it may not be the best solution in a common-domain
   deployment.  That said, using OAuth even in a common-domain
   architecture does mean you can more easily rearchitect things later,
   such as if you were to later add a new domain to the system.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/6.2.%20%20JavaScript%20Applications%20with%20a%20Backend"></a></body></html><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  JavaScript Applications with a Backend</span>










<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   +-------------+  +--------------+ +---------------+
   |             |  |              | |               |
   |Authorization|  |    Token     | |   Resource    |
   |  Endpoint   |  |   Endpoint   | |    Server     |
   |             |  |              | |               |
   +-------------+  +--------------+ +---------------+

          ^                ^                   ^
          |             (D)|                (G)|
          |                v                   v
          |
          |         +--------------------------------+
          |         |                                |
          |         |          Application           |
       (B)|         |            Server              |
          |         |                                |
          |         +--------------------------------+
          |
          |           ^     ^     +          ^    +
          |        (A)|  (C)|  (E)|       (F)|    |(H)
          v           v     +     v          +    v

   +-------------------------------------------------+
   |                                                 |
   |                   Browser                       |
   |                                                 |
   +-------------------------------------------------+

   In this architecture, commonly referred to as "backend for frontend"
   or "BFF", the JavaScript code is loaded from a dynamic Application
   Server (A) that also has the ability to execute code itself.  This
   enables the ability to keep all of the steps involved in obtaining an
   access token outside of the JavaScript application.

   In this case, the Application Server initiates the OAuth flow itself,
   by redirecting the browser to the authorization endpoint (B).  When
   the user is redirected back, the browser delivers the authorization
   code to the application server (C), where it can then exchange it for
   an access token at the token endpoint (D) using its client secret.
   The application server then keeps the access token and refresh token
   stored internally, and creates a separate session with the browser-
   based app via a traditional browser cookie (E).

   When the JavaScript application in the browser wants to make a
   request to the Resource Server, it instead makes the request to the
   Application Server (F), and the Application Server will make the
   request with the access token to the Resource Server (G), and forward
   the response (H) back to the browser.



<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   (Common examples of this architecture are an Angular front-end with a
   .NET backend, or a React front-end with a Spring Boot backend.)

   The Application Server <em>SHOULD</em> be considered a confidential client,
   and issued its own client secret.  The Application Server <em>SHOULD</em> use
   the OAuth 2.0 Authorization Code grant with PKCE to initiate a
   request for an access token.  Detailed recommendations for
   confidential clients can be found in [<a href="#ref-oauth-security-topics">oauth-security-topics</a>]
   <a href="#section-2.1.1">Section 2.1.1</a>.

   In this scenario, the session between the browser and Application
   Server <em>SHOULD</em> be a session cookie provided by the Application Server.

   Security of the connection between code running in the browser and
   this Application Server is assumed to utilize browser-level
   protection mechanisms.  Details are out of scope of this document,
   but many recommendations can be found in the OWASP Cheat Sheet series
   (<a href="https://cheatsheetseries.owasp.org/">https://cheatsheetseries.owasp.org/</a>), such as setting an HTTP-only
   and Secure cookie to authenticate the session between the browser and
   Application Server.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/6.3.%20%20JavaScript%20Applications%20without%20a%20Backend"></a></body></html><a class="selflink" href="#section-6.3" id="section-6.3">6.3</a>.  JavaScript Applications without a Backend</span>

                         +---------------+           +--------------+
                         |               |           |              |
                         | Authorization |           |   Resource   |
                         |    Server     |           |    Server    |
                         |               |           |              |
                         +---------------+           +--------------+

                                ^     ^                 ^     +
                                |     |                 |     |
                                |(B)  |(C)              |(D)  |(E)
                                |     |                 |     |
                                |     |                 |     |
                                +     v                 +     v

   +-----------------+         +-------------------------------+
   |                 |   (A)   |                               |
   | Static Web Host | +-----&gt; |           Browser             |
   |                 |         |                               |
   +-----------------+         +-------------------------------+

   In this architecture, the JavaScript code is first loaded from a
   static web host into the browser (A), and the application then runs
   in the browser.  This application is considered a public client,
   since there is no way to issue it a client secret and there is no




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   other secure client authentication mechanism available in the
   browser.

   The code in the browser initiates the Authorization Code flow with
   the PKCE extension (described in <a href="#section-7">Section 7</a>) (B) above, and obtains an
   access token via a POST request (C).  The JavaScript application is
   then responsible for storing the access token (and optional refresh
   token) as securely as possible using appropriate browser APIs.  As of
   the date of this publication there is no browser API that allows to
   store tokens in a completely secure way.

   When the JavaScript application in the browser wants to make a
   request to the Resource Server, it can interact with the Resource
   Server directly.  It includes the access token in the request (D) and
   receives the Resource Server's response (E).

   In this scenario, the Authorization Server and Resource Server <em>MUST</em>
   support the necessary CORS headers to enable the JavaScript code to
   make this POST request from the domain on which the script is
   executing.  (See <a href="#section-9.6">Section 9.6</a> for additional details.)

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.%20%20Authorization%20Code%20Flow"></a></body></html><a class="selflink" href="#section-7" id="section-7">7</a>.  Authorization Code Flow</span>

   Browser-based applications that are public clients and use the
   Authorization Code grant type described in <a href="#section-4.1">Section 4.1</a> of OAuth 2.0
   [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>] <em>MUST</em> also follow these additional requirements described in
   this section.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.1.%20%20Initiating%20the%20Authorization%20Request%20from%20a%20Browser-Based"></a></body></html><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a>.  Initiating the Authorization Request from a Browser-Based</span>
<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/%20%20%20%20%20%20Application"></a></body></html>      Application</span>

   Browser-based applications that are public clients <em>MUST</em> implement the
   Proof Key for Code Exchange (PKCE [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>]) extension when obtaining
   an access token, and authorization servers <em>MUST</em> support and enforce
   PKCE for such clients.

   The PKCE extension prevents an attack where the authorization code is
   intercepted and exchanged for an access token by a malicious client,
   by providing the authorization server with a way to verify the client
   instance that exchanges the authorization code is the same one that
   initiated the flow.

   Browser-based applications <em>MUST</em> prevent CSRF attacks against their
   redirect URI.  This can be accomplished by any of the below:

   o  using PKCE, and confirming that the authorization server supports
      PKCE




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021               [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   o  using a unique value for the OAuth 2.0 "state" parameter

   o  if the application is using OpenID Connect, by using the OpenID
      Connect "nonce" parameter

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.%20%20Handling%20the%20Authorization%20Code%20Redirect"></a></body></html><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a>.  Handling the Authorization Code Redirect</span>

   Authorization servers <em>MUST</em> require an exact match of a registered
   redirect URI.  As described in [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] <a href="#section-4.1.1">Section 4.1.1</a>.
   this helps to prevent attacks targeting the authorization code.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.%20%20Refresh%20Tokens"></a></body></html><a class="selflink" href="#section-8" id="section-8">8</a>.  Refresh Tokens</span>

   Refresh tokens provide a way for applications to obtain a new access
   token when the initial access token expires.  With public clients,
   the risk of a leaked refresh token is greater than leaked access
   tokens, since an attacker may be able to continue using the stolen
   refresh token to obtain new access tokens potentially without being
   detectable by the authorization server.

   Browser-based applications provide an attacker with several
   opportunities by which a refresh token can be leaked, just as with
   access tokens.  As such, these applications are considered a higher
   risk for handling refresh tokens.

   Authorization servers may choose whether or not to issue refresh
   tokens to browser-based applications. [<a href="#ref-oauth-security-topics">oauth-security-topics</a>]
   describes some additional requirements around refresh tokens on top
   of the recommendations of [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>].  Applications and authorization
   servers conforming to this BCP <em>MUST</em> also follow the recommendations
   in [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] around refresh tokens if refresh tokens
   are issued to browser-based applications.

   In particular, authorization servers:

   o  <em>MUST</em> either rotate refresh tokens on each use OR use sender-
      constrained refresh tokens as described in [<a href="#ref-oauth-security-topics">oauth-security-topics</a>]
      <a href="#section-4.13.2">Section 4.13.2</a>

   o  <em>MUST</em> either set a maximum lifetime on refresh tokens OR expire if
      the refresh token has not been used within some amount of time

   o  <em>MUST NOT</em> extend the lifetime of the new refresh token beyond the
      lifetime of the initial refresh token

   o  upon issuing a rotated refresh token, <em>MUST NOT</em> extend the lifetime
      of the new refresh token beyond the lifetime of the initial




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


      refresh token if the refresh token has a preestablished expiration
      time

   For example:

   o  A user authorizes an application, issuing an access token that
      lasts 1 hour, and a refresh token that lasts 24 hours

   o  After 1 hour, the initial access token expires, so the application
      uses the refresh token to get a new access token

   o  The authorization server returns a new access token that lasts 1
      hour, and a new refresh token that lasts 23 hours

   o  This continues until 24 hours pass from the initial authorization

   o  At this point, when the application attempts to use the refresh
      token after 24 hours, the request will fail and the application
      will have to involve the user in a new authorization request

   By limiting the overall refresh token lifetime to the lifetime of the
   initial refresh token, this ensures a stolen refresh token cannot be
   used indefinitely.

   Authorization servers <em>MAY</em> set different policies around refresh token
   issuance, lifetime and expiration for browser-based applications
   compared to other public clients.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.%20%20Security%20Considerations"></a></body></html><a class="selflink" href="#section-9" id="section-9">9</a>.  Security Considerations</span>

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.1.%20%20Registration%20of%20Browser-Based%20Apps"></a></body></html><a class="selflink" href="#section-9.1" id="section-9.1">9.1</a>.  Registration of Browser-Based Apps</span>

   Browser-based applications are considered public clients as defined
   by <a href="#section-2.1">Section 2.1</a> of OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>], and <em>MUST</em> be registered with
   the authorization server as such.  Authorization servers <em>MUST</em> record
   the client type in the client registration details in order to
   identify and process requests accordingly.

   Authorization servers <em>MUST</em> require that browser-based applications
   register one or more redirect URIs.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.2.%20%20Client%20Authentication"></a></body></html><a class="selflink" href="#section-9.2" id="section-9.2">9.2</a>.  Client Authentication</span>

   Since a browser-based application's source code is delivered to the
   end-user's browser, it cannot contain provisioned secrets.  As such,
   a browser-based app with native OAuth support is considered a public
   client as defined by <a href="#section-2.1">Section 2.1</a> of OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>].




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   Secrets that are statically included as part of an app distributed to
   multiple users should not be treated as confidential secrets, as one
   user may inspect their copy and learn the shared secret.  For this
   reason, and those stated in <a href="/doc/html/rfc6819#section-5.3.1">SectionÂ 5.3.1 of [RFC6819]</a>, it is NOT
   <em>RECOMMENDED</em> for authorization servers to require client
   authentication of browser-based applications using a shared secret,
   as this serves little value beyond client identification which is
   already provided by the client_id request parameter.

   Authorization servers that still require a statically included shared
   secret for SPA clients <em>MUST</em> treat the client as a public client, and
   not accept the secret as proof of the client's identity.  Without
   additional measures, such clients are subject to client impersonation
   (see <a href="#section-9.3">Section 9.3</a> below).

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.3.%20%20Client%20Impersonation"></a></body></html><a class="selflink" href="#section-9.3" id="section-9.3">9.3</a>.  Client Impersonation</span>

   As stated in <a href="#section-10.2">Section 10.2</a> of OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>], the authorization
   server <em>SHOULD NOT</em> process authorization requests automatically
   without user consent or interaction, except when the identity of the
   client can be assured.

   If authorization servers restrict redirect URIs to a fixed set of
   absolute HTTPS URIs, preventing the use of wildcard domains, wildcard
   paths, or wildcard query string components, this exact match of
   registered absolute HTTPS URIs <em>MAY</em> be accepted by authorization
   servers as proof of identity of the client for the purpose of
   deciding whether to automatically process an authorization request
   when a previous request for the client_id has already been approved.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.4.%20%20Cross-Site%20Request%20Forgery%20Protections"></a></body></html><a class="selflink" href="#section-9.4" id="section-9.4">9.4</a>.  Cross-Site Request Forgery Protections</span>

   Clients <em>MUST</em> prevent Cross-Site Request Forgery (CSRF) attacks
   against their redirect URI.  Clients can accomplish this by either
   ensuring the authorization server supports PKCE and relying on the
   CSRF protection that PKCE provides, or if the client is also an
   OpenID Connect client, using the OpenID Connect "nonce" parameter, or
   by using the "state" parameter to carry one-time-use CSRF tokens as
   described in <a href="#section-7.1">Section 7.1</a>.

   See Section 2.1 of [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] for additional details.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.5.%20%20Authorization%20Server%20Mix-Up%20Mitigation"></a></body></html><a class="selflink" href="#section-9.5" id="section-9.5">9.5</a>.  Authorization Server Mix-Up Mitigation</span>

   Authorization server mix-up attacks mark a severe threat to every
   client that supports at least two authorization servers.  To conform
   to this BCP such clients <em>MUST</em> apply countermeasures to defend against
   mix-up attacks.



<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   It is <em>RECOMMENDED</em> to defend against mix-up attacks by identifying and
   validating the issuer of the authorization response.  This can be
   achieved either by using the "iss" response parameter, as defined in
   [<a href="#ref-oauth-iss-auth-resp">oauth-iss-auth-resp</a>], or by using the "iss" Claim of the ID token
   when OpenID Connect is used.

   Alternative countermeasures, such as using distinct redirect URIs for
   each issuer, <em>SHOULD</em> only be used if identifying the issuer as
   described is not possible.

   Section 4.4 of [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] provides additional details
   about mix-up attacks and the countermeasures mentioned above.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.6.%20%20Cross-Domain%20Requests"></a></body></html><a class="selflink" href="#section-9.6" id="section-9.6">9.6</a>.  Cross-Domain Requests</span>

   To complete the Authorization Code flow, the browser-based
   application will need to exchange the authorization code for an
   access token at the token endpoint.  If the authorization server
   provides additional endpoints to the application, such as metadata
   URLs, dynamic client registration, revocation, introspection,
   discovery or user info endpoints, these endpoints may also be
   accessed by the browser-based app.  Since these requests will be made
   from a browser, authorization servers <em>MUST</em> support the necessary CORS
   headers (defined in [<a href="#ref-Fetch" title='"Fetch"'>Fetch</a>]) to allow the browser to make the
   request.

   This specification does not include guidelines for deciding whether a
   CORS policy for the token endpoint should be a wildcard origin or
   more restrictive.  Note, however, that the browser will attempt to
   GET or POST to the API endpoint before knowing any CORS policy; it
   simply hides the succeeding or failing result from JavaScript if the
   policy does not allow sharing.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.7.%20%20Content%20Security%20Policy"></a></body></html><a class="selflink" href="#section-9.7" id="section-9.7">9.7</a>.  Content Security Policy</span>

   A browser-based application that wishes to use either long-lived
   refresh tokens or privileged scopes <em>SHOULD</em> restrict its JavaScript
   execution to a set of statically hosted scripts via a Content
   Security Policy ([<a href="#ref-CSP2" title='"Content Security Policy"'>CSP2</a>]) or similar mechanism.  A strong Content
   Security Policy can limit the potential attack vectors for malicious
   JavaScript to be executed on the page.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.%20%20OAuth%20Implicit%20Flow"></a></body></html><a class="selflink" href="#section-9.8" id="section-9.8">9.8</a>.  OAuth Implicit Flow</span>

   The OAuth 2.0 Implicit flow (defined in <a href="#section-4.2">Section 4.2</a> of OAuth 2.0
   [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>]) works by the authorization server issuing an access token
   in the authorization response (front channel) without the code
   exchange step.  In this case, the access token is returned in the



<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   fragment part of the redirect URI, providing an attacker with several
   opportunities to intercept and steal the access token.

   Authorization servers <em>MUST NOT</em> issue access tokens in the
   authorization response, and <em>MUST</em> issue access tokens only from the
   token endpoint.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.1.%20%20Attacks%20on%20the%20Implicit%20Flow"></a></body></html><a class="selflink" href="#section-9.8.1" id="section-9.8.1">9.8.1</a>.  Attacks on the Implicit Flow</span>

   Many attacks on the Implicit flow described by [<a href="/doc/html/rfc6819" title='"OAuth 2.0 Threat Model and Security Considerations"'>RFC6819</a>] and
   Section 4.1.2 of [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] do not have sufficient
   mitigation strategies.  The following sections describe the specific
   attacks that cannot be mitigated while continuing to use the Implicit
   flow.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.1.1.%20%20Threat%3A%20Manipulation%20of%20the%20Redirect%20URI"></a></body></html><a class="selflink" href="#section-9.8.1.1" id="section-9.8.1.1">9.8.1.1</a>.  Threat: Manipulation of the Redirect URI</span>

   If an attacker is able to cause the authorization response to be sent
   to a URI under their control, they will directly get access to the
   authorization response including the access token.  Several methods
   of performing this attack are described in detail in
   [<a href="#ref-oauth-security-topics">oauth-security-topics</a>].

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.1.2.%20%20Threat%3A%20Access%20Token%20Leak%20in%20Browser%20History"></a></body></html><a class="selflink" href="#section-9.8.1.2" id="section-9.8.1.2">9.8.1.2</a>.  Threat: Access Token Leak in Browser History</span>

   An attacker could obtain the access token from the browser's history.
   The countermeasures recommended by [<a href="/doc/html/rfc6819" title='"OAuth 2.0 Threat Model and Security Considerations"'>RFC6819</a>] are limited to using
   short expiration times for tokens, and indicating that browsers
   should not cache the response.  Neither of these fully prevent this
   attack, they only reduce the potential damage.

   Additionally, many browsers now also sync browser history to cloud
   services and to multiple devices, providing an even wider attack
   surface to extract access tokens out of the URL.

   This is discussed in more detail in Section 4.3.2 of
   [<a href="#ref-oauth-security-topics">oauth-security-topics</a>].

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.1.3.%20%20Threat%3A%20Manipulation%20of%20Scripts"></a></body></html><a class="selflink" href="#section-9.8.1.3" id="section-9.8.1.3">9.8.1.3</a>.  Threat: Manipulation of Scripts</span>

   An attacker could modify the page or inject scripts into the browser
   through various means, including when the browser's HTTPS connection
   is being intercepted by, for example, a corporate network.  While
   man-in-the-middle attacks are typically out of scope of basic
   security recommendations to prevent, in the case of browser-based
   apps they are much easier to perform.  An injected script can enable
   an attacker to have access to everything on the page.




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   The risk of a malicious script running on the page may be amplified
   when the application uses a known standard way of obtaining access
   tokens, namely that the attacker can always look at the
   "window.location" variable to find an access token.  This threat
   profile is different from an attacker specifically targeting an
   individual application by knowing where or how an access token
   obtained via the Authorization Code flow may end up being stored.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.1.4.%20%20Threat%3A%20Access%20Token%20Leak%20to%20Third-Party%20Scripts"></a></body></html><a class="selflink" href="#section-9.8.1.4" id="section-9.8.1.4">9.8.1.4</a>.  Threat: Access Token Leak to Third-Party Scripts</span>

   It is relatively common to use third-party scripts in browser-based
   apps, such as analytics tools, crash reporting, and even things like
   a Facebook or Twitter "like" button.  In these situations, the author
   of the application may not be able to be fully aware of the entirety
   of the code running in the application.  When an access token is
   returned in the fragment, it is visible to any third-party scripts on
   the page.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.2.%20%20Countermeasures"></a></body></html><a class="selflink" href="#section-9.8.2" id="section-9.8.2">9.8.2</a>.  Countermeasures</span>

   In addition to the countermeasures described by [<a href="/doc/html/rfc6819" title='"OAuth 2.0 Threat Model and Security Considerations"'>RFC6819</a>] and
   [<a href="#ref-oauth-security-topics">oauth-security-topics</a>], using the Authorization Code flow with PKCE
   extension prevents the attacks described above by avoiding returning
   the access token in the redirect response at all.

   When PKCE is used, if an authorization code is stolen in transport,
   the attacker is unable to do anything with the authorization code.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.3.%20%20Disadvantages%20of%20the%20Implicit%20Flow"></a></body></html><a class="selflink" href="#section-9.8.3" id="section-9.8.3">9.8.3</a>.  Disadvantages of the Implicit Flow</span>

   There are several additional reasons the Implicit flow is
   disadvantageous compared to using the standard Authorization Code
   flow.

   o  OAuth 2.0 provides no mechanism for a client to verify that a
      particular access token was intended for that client, which could
      lead to misuse and possible impersonation attacks if a malicious
      party hands off an access token it retrieved through some other
      means to the client.

   o  Returning an access token in the front-channel redirect gives the
      authorization server no assurance that the access token will
      actually end up at the application, since there are many ways this
      redirect may fail or be intercepted.

   o  Supporting the Implicit flow requires additional code, more upkeep
      and understanding of the related security considerations, while




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


      limiting the authorization server to just the Authorization Code
      flow reduces the attack surface of the implementation.

   o  If the JavaScript application gets wrapped into a native app, then
      [<a href="/doc/html/rfc8252" title='"OAuth 2.0 for Native Apps"'>RFC8252</a>] also requires the use of the Authorization Code flow
      with PKCE anyway.

   In OpenID Connect, the id_token is sent in a known format (as a JWT),
   and digitally signed.  Returning an id_token using the Implicit flow
   ("response_type=id_token") requires the client validate the JWT
   signature, as malicious parties could otherwise craft and supply
   fraudulent id_tokens.  Performing OpenID Connect using the
   Authorization Code flow provides the benefit of the client not
   needing to verify the JWT signature, as the ID token will have been
   fetched over an HTTPS connection directly from the authorization
   server.  Additionally, in many cases an application will request both
   an ID token and an access token, so it is simplier and provides fewer
   attack vectors to obtain both via the Authorization Code flow.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.4.%20%20Historic%20Note"></a></body></html><a class="selflink" href="#section-9.8.4" id="section-9.8.4">9.8.4</a>.  Historic Note</span>

   Historically, the Implicit flow provided an advantage to browser-
   based apps since JavaScript could always arbitrarily read and
   manipulate the fragment portion of the URL without triggering a page
   reload.  This was necessary in order to remove the access token from
   the URL after it was obtained by the app.

   Modern browsers now have the Session History API (described in
   "Session history and navigation" of [<a href="#ref-HTML" title='"HTML"'>HTML</a>]), which provides a
   mechanism to modify the path and query string component of the URL
   without triggering a page reload.  This means modern browser-based
   apps can use the unmodified OAuth 2.0 Authorization Code flow, since
   they have the ability to remove the authorization code from the query
   string without triggering a page reload thanks to the Session History
   API.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.9.%20%20Additional%20Security%20Considerations"></a></body></html><a class="selflink" href="#section-9.9" id="section-9.9">9.9</a>.  Additional Security Considerations</span>

   The OWASP Foundation (<a href="https://www.owasp.org/">https://www.owasp.org/</a>) maintains a set of
   security recommendations and best practices for web applications, and
   it is <em>RECOMMENDED</em> to follow these best practices when creating an
   OAuth 2.0 Browser-Based application.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.%20%20IANA%20Considerations"></a></body></html><a class="selflink" href="#section-10" id="section-10">10</a>.  IANA Considerations</span>

   This document does not require any IANA actions.





<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/11.%20%20References"></a></body></html><a class="selflink" href="#section-11" id="section-11">11</a>.  References</span>

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/11.1.%20%20Normative%20References"></a></body></html><a class="selflink" href="#section-11.1" id="section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-CSP2">CSP2</a>]     West, M., "Content Security Policy", October 2018.

   [<a id="ref-Fetch">Fetch</a>]    whatwg, "Fetch", 2018.

   [<a id="ref-oauth-iss-auth-resp">oauth-iss-auth-resp</a>]
              Meyer zu Selhausen, K. and D. Fett, "OAuth 2.0
              Authorization Server Issuer Identifier in Authorization
              Response", January 2021.

   [<a id="ref-oauth-security-topics">oauth-security-topics</a>]
              Lodderstedt, T., Bradley, J., Labunets, A., and D. Fett,
              "OAuth 2.0 Security Best Current Practice", April 2021.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC6749">RFC6749</a>]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              <a href="/doc/html/rfc6749">RFC 6749</a>, DOI 10.17487/RFC6749, October 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6749">https://www.rfc-editor.org/info/rfc6749</a>&gt;.

   [<a id="ref-RFC6750">RFC6750</a>]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", <a href="/doc/html/rfc6750">RFC 6750</a>,
              DOI 10.17487/RFC6750, October 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6750">https://www.rfc-editor.org/info/rfc6750</a>&gt;.

   [<a id="ref-RFC6819">RFC6819</a>]  Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0
              Threat Model and Security Considerations", <a href="/doc/html/rfc6819">RFC 6819</a>,
              DOI 10.17487/RFC6819, January 2013,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6819">https://www.rfc-editor.org/info/rfc6819</a>&gt;.

   [<a id="ref-RFC7636">RFC7636</a>]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key
              for Code Exchange by OAuth Public Clients", <a href="/doc/html/rfc7636">RFC 7636</a>,
              DOI 10.17487/RFC7636, September 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7636">https://www.rfc-editor.org/info/rfc7636</a>&gt;.

   [<a id="ref-RFC8252">RFC8252</a>]  Denniss, W. and J. Bradley, "OAuth 2.0 for Native Apps",
              <a href="/doc/html/bcp212">BCP 212</a>, <a href="/doc/html/rfc8252">RFC 8252</a>, DOI 10.17487/RFC8252, October 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8252">https://www.rfc-editor.org/info/rfc8252</a>&gt;.







<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/11.2.%20%20Informative%20References"></a></body></html><a class="selflink" href="#section-11.2" id="section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-HTML">HTML</a>]     whatwg, "HTML", 2020.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20A.%20%20Server%20Support%20Checklist"></a></body></html><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Server Support Checklist</span>

   OAuth authorization servers that support browser-based apps <em>MUST</em>:

   1.  Require "https" scheme redirect URIs.

   2.  Require exact matching of registered redirect URIs.

   3.  Support PKCE [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>].  Required to protect authorization code
       grants sent to public clients.  See <a href="#section-7.1">Section 7.1</a>

   4.  Support cross-domain requests at the token endpoint in order to
       allow browsers to make the authorization code exchange request.
       See <a href="#section-9.6">Section 9.6</a>

   5.  Not assume that browser-based clients can keep a secret, and
       <em>SHOULD NOT</em> issue secrets to applications of this type.

   6.  Not support the Resource Owner Password grant for browser-based
       clients.

   7.  Follow the [<a href="#ref-oauth-security-topics">oauth-security-topics</a>] recommendations on refresh
       tokens, as well as the additional requirements described in
       <a href="#section-8">Section 8</a>.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20B.%20%20Document%20History"></a></body></html><a class="selflink" href="#appendix-B" id="appendix-B">Appendix B</a>.  Document History</span>

   [[ To be removed from the final specification ]]

   -08

   o  Added a note to use the "Secure" cookie attribute in addition to
      SameSite etc

   o  Updates to bring this draft in sync with the latest Security BCP

   o  Updated text for mix-up countermeasures to reference the new "iss"
      extension

   o  Changed "<em>SHOULD</em>" for refresh token rotation to <em>MUST</em> either use
      rotation or sender-constraining to match the Security BCP

   o  Fixed references to other specs and extensions




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   o  Editorial improvements in descriptions of the different
      architectures

   -07

   o  Clarify PKCE requirements apply only to issuing access tokens

   o  Change "<em>MUST</em>" to "<em>SHOULD</em>" for refresh token rotation

   o  Editorial clarifications

   -06

   o  Added refresh token requirements to AS summary

   o  Editorial clarifications

   -05

   o  Incorporated editorial and substantive feedback from Mike Jones

   o  Added references to "nonce" as another way to prevent CSRF attacks

   o  Updated headers in the Implicit Flow section to better represent
      the relationship between the paragraphs

   -04

   o  Disallow the use of the Password Grant

   o  Add PKCE support to summary list for authorization server
      requirements

   o  Rewrote refresh token section to allow refresh tokens if they are
      time-limited, rotated on each use, and requiring that the rotated
      refresh token lifetimes do not extend past the lifetime of the
      initial refresh token, and to bring it in line with the Security
      BCP

   o  Updated recommendations on using state to reflect the Security BCP

   o  Updated server support checklist to reflect latest changes

   o  Updated the same-domain JS architecture section to emphasize the
      architecture rather than domain

   o  Editorial clarifications in the section that talks about OpenID
      Connect ID tokens



<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   -03

   o  Updated the historic note about the fragment URL clarifying that
      the Session History API means browsers can use the unmodified
      authorization code flow

   o  Rephrased "Authorization Code Flow" intro paragraph to better lead
      into the next two sections

   o  Softened "is likely a better decision to avoid using OAuth
      entirely" to "it may be..." for common-domain deployments

   o  Updated abstract to not be limited to public clients, since the
      later sections talk about confidential clients

   o  Removed references to avoiding OpenID Connect for same-domain
      architectures

   o  Updated headers to better describe architectures (Apps Served from
      a Static Web Server -&gt; JavaScript Applications without a Backend)

   o  Expanded "same-domain architecture" section to better explain the
      problems that OAuth has in this scenario

   o  Referenced Security BCP in implicit flow attacks where possible

   o  Minor typo corrections

   -02

   o  Rewrote overview section incorporating feedback from Leo Tohill

   o  Updated summary recommendation bullet points to split out
      application and server requirements

   o  Removed the allowance on hostname-only redirect URI matching, now
      requiring exact redirect URI matching

   o  Updated <a href="#section-6.2">Section 6.2</a> to drop reference of SPA with a backend
      component being a public client

   o  Expanded the architecture section to explicitly mention three
      architectural patterns available to JS apps

   -01

   o  Incorporated feedback from Torsten Lodderstedt




<span class="grey">Parecki &amp; Waite         Expires November 18, 2021              [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey">Internet-Draft      OAuth 2.0 for Browser-Based Apps            May 2021</span>


   o  Updated abstract

   o  Clarified the definition of browser-based apps to not exclude
      applications cached in the browser, e.g. via Service Workers

   o  Clarified use of the state parameter for CSRF protection

   o  Added background information about the original reason the
      implicit flow was created due to lack of CORS support

   o  Clarified the same-domain use case where the SPA and API share a
      cookie domain

   o  Moved historic note about the fragment URL into the Overview

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20C.%20%20Acknowledgements"></a></body></html><a class="selflink" href="#appendix-C" id="appendix-C">Appendix C</a>.  Acknowledgements</span>

   The authors would like to acknowledge the work of William Denniss and
   John Bradley, whose recommendation for native apps informed many of
   the best practices for browser-based applications.  The authors would
   also like to thank Hannes Tschofenig and Torsten Lodderstedt, the
   attendees of the Internet Identity Workshop 27 session at which this
   BCP was originally proposed, and the following individuals who
   contributed ideas, feedback, and wording that shaped and formed the
   final specification:

   Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka,
   Daniel Fett, George Fletcher, Hannes Tschofenig, Janak Amarasena,
   John Bradley, Joseph Heenan, Justin Richer, Karl McGuinness, Karsten
   Meyer zu Selhausen, Leo Tohill, Mike Jones, Tomek Stojecki, Torsten
   Lodderstedt, and Vittorio Bertocci.

Authors' Addresses

   Aaron Parecki
   Okta

   Email: aaron@parecki.com
   URI:   <a href="https://aaronparecki.com">https://aaronparecki.com</a>


   David Waite
   Ping Identity

   Email: david@alkaline-solutions.com






Parecki &amp; Waite         Expires November 18, 2021              [Page 21]
</pre>
</div>
</div>
</div>
<script>$(".visible-nojs").removeClass("visible-nojs");</script>
<script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
<script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>
</body>
</html>
