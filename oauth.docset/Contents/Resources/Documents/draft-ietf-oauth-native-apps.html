<!DOCTYPE html>
<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html --><html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<title>
  
    draft-ietf-oauth-native-apps-12
  
</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>
<!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.38.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.38.0/respond/dest/respond.min.js"></script>
    <![endif]-->
<link href="/feed/document-changes/draft-ietf-oauth-native-apps/" rel="alternate" title="Document changes" type="application/atom+xml"/>
<meta content="OAuth 2.0 for Native Apps (Internet-Draft, 2017)" name="description"/>
<script src="https://www.ietf.org/lib/dt/7.38.0/d3/d3.min.js"></script>
<script src="https://www.ietf.org/lib/dt/7.38.0/jquery/jquery.min.js"></script>
<link href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/ietf-icon-blue3.png" rel="shortcut icon"/>
<link href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/apple-touch-icon.png" rel="apple-touch-icon"/>
</head>
<body style="padding-top: 0;">
<div class="content" id="content">
<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
<div class="rfcmarkup">
<div class="noprint" style="height: 6px;">
<div class="meta-info bgred" onclick="showLegend();" onmouseout="hideLegend()" onmouseover="this.style.cursor='pointer';" style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; " title="Click for colour legend.">Â </div>
<div class="meta-info noprint pre legend" id="legend" onmouseout="hideLegend();" onmouseover="showLegend();" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
</div>
</div>
<div class="noprint">
<pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.ietf.org/archive/id/draft-ietf-oauth-native-apps-12.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.ietf.org/archive/id/draft-ietf-oauth-native-apps-12.xml" title="XML source for this document">xml</a>|<a href="https://tools.ietf.org/pdf/draft-ietf-oauth-native-apps-12.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/draft-ietf-oauth-native-apps/12/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/draft-ietf-oauth-native-apps/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/oauth/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-oauth-native-apps@ietf.org?subject=draft-ietf-oauth-native-apps" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=draft-ietf-oauth-native-apps-12.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-oauth-native-apps-12.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-oauth-native-apps-12.txt" title="Run an idnits check of this document">Nits</a>]

Versions: (<a href="/doc/html/draft-wdenniss-oauth-native-apps">draft-wdenniss-oauth-native-apps</a>)  <a href="/doc/html/draft-ietf-oauth-native-apps-00">00</a>   Best Current Practice
          <a href="/doc/html/draft-ietf-oauth-native-apps-01">01</a> <a href="/doc/html/draft-ietf-oauth-native-apps-02">02</a> <a href="/doc/html/draft-ietf-oauth-native-apps-03">03</a> <a href="/doc/html/draft-ietf-oauth-native-apps-04">04</a> <a href="/doc/html/draft-ietf-oauth-native-apps-05">05</a> <a href="/doc/html/draft-ietf-oauth-native-apps-06">06</a> <a href="/doc/html/draft-ietf-oauth-native-apps-07">07</a> <a href="/doc/html/draft-ietf-oauth-native-apps-08">08</a> <a href="/doc/html/draft-ietf-oauth-native-apps-09">09</a> <a href="/doc/html/draft-ietf-oauth-native-apps-10">10</a> <a href="/doc/html/draft-ietf-oauth-native-apps-11">11</a> <a href="/doc/html/draft-ietf-oauth-native-apps-12"><b>12</b></a>                           
          <a href="/doc/html/rfc8252">rfc8252</a>                                                       </pre>
</div>
<div class="draftcontent">
<pre>OAuth Working Group                                           W. Denniss
Internet-Draft                                                    Google
Updates: <a href="/doc/html/rfc6749">6749</a> (if approved)                                   J. Bradley
Intended status: Best Current Practice                     Ping Identity
Expires: December 11, 2017                                  June 9, 2017


                       <span class="h1">OAuth 2.0 for Native Apps</span>
                    <span class="h1">draft-ietf-oauth-native-apps-12</span>

Abstract

   OAuth 2.0 authorization requests from native apps should only be made
   through external user-agents, primarily the user's browser.  This
   specification details the security and usability reasons why this is
   the case, and how native apps and authorization servers can implement
   this best practice.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="/doc/html/bcp78">BCP 78</a> and <a href="/doc/html/bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on December 11, 2017.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in <a href="#section-4">Section 4</a>.e of




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Notational Conventions  . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-4">4</a>.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-4.1">4.1</a>.  Authorization Flow for Native Apps Using the Browser  . .   <a href="#page-5">5</a>
   <a href="#section-5">5</a>.  Using Inter-app URI Communication for OAuth . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-6">6</a>.  Initiating the Authorization Request from a Native App  . . .   <a href="#page-6">6</a>
   <a href="#section-7">7</a>.  Receiving the Authorization Response in a Native App  . . . .   <a href="#page-7">7</a>
     <a href="#section-7.1">7.1</a>.  Private-use URI Scheme Redirection  . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-7.2">7.2</a>.  Claimed HTTPS URI Redirection . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-7.3">7.3</a>.  Loopback Interface Redirection  . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-8">8</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-8.1">8.1</a>.  Protecting the Authorization Code . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-8.2">8.2</a>.  OAuth Implicit Grant Authorization Flow . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-8.3">8.3</a>.  Loopback Redirect Considerations  . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-8.4">8.4</a>.  Registration of Native App Clients  . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-8.5">8.5</a>.  Client Authentication . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-8.6">8.6</a>.  Client Impersonation  . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-8.7">8.7</a>.  Fake External User-Agent  . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-8.8">8.8</a>.  Malicious External User-Agent . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-8.9">8.9</a>.  Cross-App Request Forgery Protections . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-8.10">8.10</a>. Authorization Server Mix-Up Mitigation  . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-8.11">8.11</a>. Non-Browser External User-Agents  . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-8.12">8.12</a>. Embedded User-Agents  . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-9">9</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-10">10</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-10.1">10.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-10.2">10.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#appendix-A">Appendix A</a>.  Server Support Checklist . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#appendix-B">Appendix B</a>.  Operating System Specific Implementation Details . .  <a href="#page-17">17</a>
     <a href="#appendix-B.1">B.1</a>.  iOS Implementation Details  . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#appendix-B.2">B.2</a>.  Android Implementation Details  . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#appendix-B.3">B.3</a>.  Windows Implementation Details  . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#appendix-B.4">B.4</a>.  macOS Implementation Details  . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#appendix-B.5">B.5</a>.  Linux Implementation Details  . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#appendix-C">Appendix C</a>.  Acknowledgements . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.%20%20Introduction"></a></body></html><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   The OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>] authorization framework documents two
   approaches in <a href="#section-9">Section 9</a> for native apps to interact with the




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   authorization endpoint: an embedded user-agent, and an external user-
   agent.

   This best current practice requires that only external user-agents
   like the browser are used for OAuth by native apps.  It documents how
   native apps can implement authorization flows using the browser as
   the preferred external user-agent, and the requirements for
   authorization servers to support such usage.

   This practice is also known as the AppAuth pattern, in reference to
   open source libraries [<a href="#ref-AppAuth" title='"AppAuth"'>AppAuth</a>] that implement it.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.%20%20Notational%20Conventions"></a></body></html><a class="selflink" href="#section-2" id="section-2">2</a>.  Notational Conventions</span>

   The key words "<em>MUST</em>", "<em>MUST NOT</em>", "<em>REQUIRED</em>", "<em>SHALL</em>", "<em>SHALL NOT</em>",
   "<em>SHOULD</em>", "<em>SHOULD NOT</em>", "<em>RECOMMENDED</em>", "NOT <em>RECOMMENDED</em>", "<em>MAY</em>", and
   "<em>OPTIONAL</em>" in this document are to be interpreted as described in Key
   words for use in RFCs to Indicate Requirement Levels [<a href="/doc/html/rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].  If
   these words are used without being spelled in uppercase then they are
   to be interpreted with their normal natural language meanings.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.%20%20Terminology"></a></body></html><a class="selflink" href="#section-3" id="section-3">3</a>.  Terminology</span>

   In addition to the terms defined in referenced specifications, this
   document uses the following terms:

   "native app"  An app or application that is installed by the user to
      their device, as distinct from a web app that runs in the browser
      context only.  Apps implemented using web-based technology but
      distributed as a native app, so-called hybrid apps, are considered
      equivalent to native apps for the purpose of this specification.

   "app"  In this document, "app" means a "native app" unless further
      specified.

   "app store"  An ecommerce store where users can download and purchase
      apps.

   "OAuth"  In this document, OAuth refers to the OAuth 2.0
      Authorization Framework [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>].

   "external user-agent"  A user-agent capable of handling the
      authorization request that is a separate entity or security domain
      to the native app making the request (such as a browser), such
      that the app cannot access the cookie storage, nor inspect or
      modify page content.





<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   "embedded user-agent"  A user-agent hosted inside the native app
      itself (such as via a web-view), with which the app has control
      over to the extent it is capable of accessing the cookie storage
      and/or modifying the page content.

   "browser"  The default application launched by the operating system
      to handle "http" and "https" scheme URI content.

   "in-app browser tab"  A programmatic instantiation of the browser
      that is displayed inside a host app, but retains the full security
      properties and authentication state of the browser.  Has different
      platform-specific product names, such as SFSafariViewController on
      iOS, and Custom Tabs on Android.

   "inter-app communication"  Communication between two apps on a
      device.

   "claimed HTTPS URI"  Some platforms allow apps to claim a HTTPS
      scheme URI after proving ownership of the domain name.  URIs
      claimed in such a way are then opened in the app instead of the
      browser.

   "private-use URI scheme"  A private-use URI scheme defined by the app
      and registered with the operating system.  URI requests to such
      schemes trigger the app which registered it to be launched to
      handle the request.

   "web-view"  A web browser UI (user interface) component that can be
      embedded in apps to render web pages, used to create embedded
      user-agents.

   "reverse domain name notation"  A naming convention based on the
      domain name system, but where the domain components are reversed,
      for example "app.example.com" becomes "com.example.app".

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.%20%20Overview"></a></body></html><a class="selflink" href="#section-4" id="section-4">4</a>.  Overview</span>

   The best current practice for authorizing users in native apps is to
   perform the OAuth authorization request in an external user-agent
   (typically the browser), rather than an embedded user-agent (such as
   one implemented with web-views).

   Previously it was common for native apps to use embedded user-agents
   (commonly implemented with web-views) for OAuth authorization
   requests.  That approach has many drawbacks, including the host app
   being able to copy user credentials and cookies, and the user needing
   to authenticate from scratch in each app.  See <a href="#section-8.12">Section 8.12</a> for a
   deeper analysis of using embedded user-agents for OAuth.



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   Native app authorization requests that use the browser are more
   secure and can take advantage of the user's authentication state.
   Being able to use the existing authentication session in the browser
   enables single sign-on, as users don't need to authenticate to the
   authorization server each time they use a new app (unless required by
   authorization server policy).

   Supporting authorization flows between a native app and the browser
   is possible without changing the OAuth protocol itself, as the
   authorization request and response are already defined in terms of
   URIs, which encompasses URIs that can be used for inter-app
   communication.  Some OAuth server implementations that assume all
   clients are confidential web-clients will need to add an
   understanding of public native app clients and the types of redirect
   URIs they use to support this best practice.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.%20%20Authorization%20Flow%20for%20Native%20Apps%20Using%20the%20Browser"></a></body></html><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  Authorization Flow for Native Apps Using the Browser</span>

  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  |          User Device          |
  |                               |
  | +--------------------------+  | (5) Authorization  +---------------+
  | |                          |  |     Code           |               |
  | |        Client App        |----------------------&gt;|     Token     |
  | |                          |&lt;----------------------|    Endpoint   |
  | +--------------------------+  | (6) Access Token,  |               |
  |   |             ^             |     Refresh Token  +---------------+
  |   |             |             |
  |   |             |             |
  |   | (1)         | (4)         |
  |   | Authorizat- | Authoriza-  |
  |   | ion Request | tion Code   |
  |   |             |             |
  |   |             |             |
  |   v             |             |
  | +---------------------------+ | (2) Authorization  +---------------+
  | |                           | |     Request        |               |
  | |          Browser          |---------------------&gt;| Authorization |
  | |                           |&lt;---------------------|    Endpoint   |
  | +---------------------------+ | (3) Authorization  |               |
  |                               |     Code           +---------------+
  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

        Figure 1: Native App Authorization via External User-agent

   Figure 1 illustrates the interaction of the native app with a browser
   external user-agent to authorize the user.




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   (1)  The client app opens a browser tab with the authorization
        request.

   (2)  Authorization endpoint receives the authorization request,
        authenticates the user and obtains authorization.
        Authenticating the user may involve chaining to other
        authentication systems.

   (3)  Authorization server issues an authorization code to the
        redirect URI.

   (4)  Client receives the authorization code from the redirect URI.

   (5)  Client app presents the authorization code at the token
        endpoint.

   (6)  Token endpoint validates the authorization code and issues the
        tokens requested.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/5.%20%20Using%20Inter-app%20URI%20Communication%20for%20OAuth"></a></body></html><a class="selflink" href="#section-5" id="section-5">5</a>.  Using Inter-app URI Communication for OAuth</span>

   Just as URIs are used for OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>] on the web to initiate
   the authorization request and return the authorization response to
   the requesting website, URIs can be used by native apps to initiate
   the authorization request in the device's browser and return the
   response to the requesting native app.

   By adopting the same methods used on the web for OAuth, benefits seen
   in the web context like the usability of a single sign-on session and
   the security of a separate authentication context are likewise gained
   in the native app context.  Re-using the same approach also reduces
   the implementation complexity and increases interoperability by
   relying on standards-based web flows that are not specific to a
   particular platform.

   To conform to this best practice, native apps <em>MUST</em> use an external
   user-agent to perform OAuth authentication requests.  This is
   achieved by opening the authorization request in the browser
   (detailed in <a href="#section-6">Section 6</a>), and using a redirect URI that will return
   the authorization response back to the native app, as defined in
   <a href="#section-7">Section 7</a>.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/6.%20%20Initiating%20the%20Authorization%20Request%20from%20a%20Native%20App"></a></body></html><a class="selflink" href="#section-6" id="section-6">6</a>.  Initiating the Authorization Request from a Native App</span>

   Native apps needing user authorization create an authorization
   request URI with the authorization code grant type per <a href="#section-4.1">Section 4.1</a> of
   OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>], using a redirect URI capable of being received
   by the native app.



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   The function of the redirect URI for a native app authorization
   request is similar to that of a web-based authorization request.
   Rather than returning the authorization response to the OAuth
   client's server, the redirect URI used by a native app returns the
   response to the app.  Several options for a redirect URI that will
   return the authorization response to the native app in different
   platforms are documented in <a href="#section-7">Section 7</a>.  Any redirect URI that allows
   the app to receive the URI and inspect its parameters is viable.

   Public native app clients <em>MUST</em> implement the Proof Key for Code
   Exchange (PKCE [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>]) extension to OAuth, and authorization
   servers <em>MUST</em> support PKCE for such clients, for the reasons detailed
   in <a href="#section-8.1">Section 8.1</a>.

   After constructing the authorization request URI, the app uses
   platform-specific APIs to open the URI in an external user-agent.
   Typically the external user-agent used is the default browser, that
   is, the application configured for handling "http" and "https" scheme
   URIs on the system, but different browser selection criteria and
   other categories of external user-agents <em>MAY</em> be used.

   This best practice focuses on the browser as the <em>RECOMMENDED</em> external
   user-agent for native apps.  An external user-agent designed
   specifically for processing authorization requests capable of
   processing the request and redirect URIs in the same way <em>MAY</em> also be
   used.  Other external user-agents, such as a native app provided by
   the authorization server may meet the criteria set out in this best
   practice, including using the same redirection URI properties, but
   their use is out of scope for this specification.

   Some platforms support a browser feature known as in-app browser
   tabs, where an app can present a tab of the browser within the app
   context without switching apps, but still retain key benefits of the
   browser such as a shared authentication state and security context.
   On platforms where they are supported, it is <em>RECOMMENDED</em> for
   usability reasons that apps use in-app browser tabs for the
   authorization request.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.%20%20Receiving%20the%20Authorization%20Response%20in%20a%20Native%20App"></a></body></html><a class="selflink" href="#section-7" id="section-7">7</a>.  Receiving the Authorization Response in a Native App</span>

   There are several redirect URI options available to native apps for
   receiving the authorization response from the browser, the
   availability and user experience of which varies by platform.

   To fully support this best practice, authorization servers <em>MUST</em> offer
   at least the following three redirect URI options to native apps.
   Native apps <em>MAY</em> use whichever redirect option suits their needs best,
   taking into account platform specific implementation details.



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.1.%20%20Private-use%20URI%20Scheme%20Redirection"></a></body></html><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a>.  Private-use URI Scheme Redirection</span>

   Many mobile and desktop computing platforms support inter-app
   communication via URIs by allowing apps to register private-use URI
   schemes (sometimes colloquially referred to as custom URL schemes)
   like "com.example.app".  When the browser or another app attempts to
   load a URI with a custom scheme, the app that registered it is
   launched to handle the request.

   To perform an OAuth 2.0 authorization request with a private-use URI
   scheme redirect, the native app launches the browser with a standard
   authorization request, but one where the redirection URI utilizes a
   custom URI scheme it registered with the operating system.

   When choosing a URI scheme to associate with the app, apps <em>MUST</em> use a
   URI scheme based on a domain name under their control, expressed in
   reverse order, as recommended by <a href="/doc/html/rfc7595#section-3.8">SectionÂ 3.8 of [RFC7595]</a> for
   private-use URI schemes.

   For example, an app that controls the domain name "app.example.com"
   can use "com.example.app" as their scheme.  Some authorization
   servers assign client identifiers based on domain names, for example
   "client1234.usercontent.example.net", which can also be used as the
   domain name for the scheme when reversed in the same manner.  A
   scheme such as "myapp" however would not meet this requirement, as it
   is not based on a domain name.

   Care must be taken when there are multiple apps by the same publisher
   that each scheme is unique within that group.  On platforms that use
   app identifiers that are also based on reverse order domain names,
   those can be reused as the private-use URI scheme for the OAuth
   redirect to help avoid this problem.

   Following the requirements of <a href="/doc/html/rfc3986#section-3.2">[RFC3986] SectionÂ 3.2</a>, as there is no
   naming authority for private-use URI scheme redirects, only a single
   slash ("/") appears after the scheme component.  A complete example
   of a redirect URI utilizing a private-use URI scheme:

     com.example.app:/oauth2redirect/example-provider

   When the authentication server completes the request, it redirects to
   the client's redirection URI as it would normally.  As the
   redirection URI uses a custom scheme it results in the operating
   system launching the native app, passing in the URI as a launch
   parameter.  The native app then processes the authorization response
   like normal.





<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.%20%20Claimed%20HTTPS%20URI%20Redirection"></a></body></html><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a>.  Claimed HTTPS URI Redirection</span>

   Some operating systems allow apps to claim HTTPS scheme [<a href="/doc/html/rfc7230" title='"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing"'>RFC7230</a>]
   URIs in domains they control.  When the browser encounters a claimed
   URI, instead of the page being loaded in the browser, the native app
   is launched with the URI supplied as a launch parameter.

   Such URIs can be used as redirect URIs by native apps.  They are
   indistinguishable to the authorization server from a regular web-
   based client redirect URI.  An example is:

     https://app.example.com/oauth2redirect/example-provider

   As the redirect URI alone is not enough to distinguish public native
   app clients from confidential web clients, it is <em>REQUIRED</em> in
   <a href="#section-8.4">Section 8.4</a> that the client type be recorded during client
   registration to enable the server to determine the client type and
   act accordingly.

   App-claimed HTTPS redirect URIs have some advantages compared to
   other native app redirect options in that the identity of the
   destination app is guaranteed to the authorization server by the
   operating system.  For this reason, native apps <em>SHOULD</em> use them over
   the other options where possible.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.3.%20%20Loopback%20Interface%20Redirection"></a></body></html><a class="selflink" href="#section-7.3" id="section-7.3">7.3</a>.  Loopback Interface Redirection</span>

   Native apps that are able to open a port on the loopback network
   interface without needing special permissions (typically, those on
   desktop operating systems) can use the loopback interface to receive
   the OAuth redirect.

   Loopback redirect URIs use the HTTP scheme and are constructed with
   the loopback IP literal and whatever port the client is listening on.
   That is, "http://127.0.0.1:{port}/{path}" for IPv4, and
   "http://[::1]:{port}/{path}" for IPv6.  An example redirect using the
   IPv4 loopback interface with a randomly assigned port:

     <a href="http://127.0.0.1:50719/oauth2redirect/example-provider">http://127.0.0.1:50719/oauth2redirect/example-provider</a>

   An example redirect using the IPv6 loopback interface with a randomly
   assigned port:

     http://[::1]:61023/oauth2redirect/example-provider

   The authorization server <em>MUST</em> allow any port to be specified at the
   time of the request for loopback IP redirect URIs, to accommodate




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017               [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   clients that obtain an available ephemeral port from the operating
   system at the time of the request.

   Clients <em>SHOULD NOT</em> assume the device supports a particular version of
   the Internet Protocol.  It is <em>RECOMMENDED</em> that clients attempt to
   bind to the loopback interface using both IPv4 and IPv6, and use
   whichever is available.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.%20%20Security%20Considerations"></a></body></html><a class="selflink" href="#section-8" id="section-8">8</a>.  Security Considerations</span>

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.1.%20%20Protecting%20the%20Authorization%20Code"></a></body></html><a class="selflink" href="#section-8.1" id="section-8.1">8.1</a>.  Protecting the Authorization Code</span>

   The redirect URI options documented in <a href="#section-7">Section 7</a> share the benefit
   that only a native app on the same device can receive the
   authorization code which limits the attack surface, however code
   interception by a different native app running on the same device may
   be possible.

   A limitation of using private-use URI schemes for redirect URIs is
   that multiple apps can typically register the same scheme, which
   makes it indeterminate as to which app will receive the Authorization
   Code.  <a href="#section-1">Section 1</a> of PKCE [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>] details how this limitation can be
   used to execute a code interception attack.

   Loopback IP based redirect URIs may be susceptible to interception by
   other apps accessing the same loopback interface on some operating
   systems.

   App-claimed HTTPS redirects are less susceptible to URI interception
   due to the presence of the URI authority, but they are still public
   clients and the URI is sent using the operating system's URI dispatch
   handler with unknown security properties.

   The Proof Key for Code Exchange by OAuth Public Clients (PKCE
   [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>]) standard was created specifically to mitigate against this
   attack.  It is a proof of possession extension to OAuth 2.0 that
   protects the code grant from being used if it is intercepted.  It
   achieves this by having the client generate a secret verifier, a hash
   of which it passes in the initial authorization request, and which it
   must present in full when redeeming the authorization code grant.  An
   app that intercepted the authorization code would not be in
   possession of this secret, rendering the code useless.

   <a href="#section-6">Section 6</a> requires that both clients and servers use PKCE for public
   native app clients.  Authorization servers <em>SHOULD</em> reject
   authorization requests from native apps that don't use PKCE by
   returning an error message as defined in <a href="#section-4.4.1">Section 4.4.1</a> of PKCE
   [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>].



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.2.%20%20OAuth%20Implicit%20Grant%20Authorization%20Flow"></a></body></html><a class="selflink" href="#section-8.2" id="section-8.2">8.2</a>.  OAuth Implicit Grant Authorization Flow</span>

   The OAuth 2.0 implicit grant authorization flow as defined in
   <a href="#section-4.2">Section 4.2</a> of OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>] generally works with the practice
   of performing the authorization request in the browser, and receiving
   the authorization response via URI-based inter-app communication.
   However, as the implicit flow cannot be protected by PKCE [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>]
   (which is a required in <a href="#section-8.1">Section 8.1</a>), the use of the Implicit Flow
   with native apps is NOT <em>RECOMMENDED</em>.

   Tokens granted via the implicit flow also cannot be refreshed without
   user interaction, making the authorization code grant flow - which
   can issue refresh tokens - the more practical option for native app
   authorizations that require refreshing.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.3.%20%20Loopback%20Redirect%20Considerations"></a></body></html><a class="selflink" href="#section-8.3" id="section-8.3">8.3</a>.  Loopback Redirect Considerations</span>

   Loopback interface redirect URIs use the "http" scheme (i.e., without
   TLS).  This is acceptable for loopback interface redirect URIs as the
   HTTP request never leaves the device.

   Clients should open the network port only when starting the
   authorization request, and close it once the response is returned.

   Clients should listen on the loopback network interface only, to
   avoid interference by other network actors.

   While redirect URIs using localhost (i.e.,
   "http://localhost:{port}/") function similarly to loopback IP
   redirects described in <a href="#section-7.3">Section 7.3</a>, the use of "localhost" is NOT
   <em>RECOMMENDED</em>.  Specifying a redirect URI with the loopback IP literal
   rather than localhost avoids inadvertently listening on network
   interfaces other than the loopback interface.  It is also less
   susceptible to client side firewalls, and misconfigured host name
   resolution on the user's device.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.4.%20%20Registration%20of%20Native%20App%20Clients"></a></body></html><a class="selflink" href="#section-8.4" id="section-8.4">8.4</a>.  Registration of Native App Clients</span>

   Native apps, except when using a mechanism like Dynamic Client
   Registration [<a href="/doc/html/rfc7591" title='"OAuth 2.0 Dynamic Client Registration Protocol"'>RFC7591</a>] to provision per-instance secrets, are
   classified as public clients, as defined by <a href="#section-2.1">Section 2.1</a> of OAuth 2.0
   [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>] and <em>MUST</em> be registered with the authorization server as
   such.  Authorization servers <em>MUST</em> record the client type in the
   client registration details in order to identify and process requests
   accordingly.

   Authorization servers <em>MUST</em> require clients to register their complete
   redirect URI (including the path component), and reject authorization



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   requests that specify a redirect URI that doesn't exactly match the
   one that was registered, with the exception of loopback redirects,
   where an exact match is required except for the port URI component.

   For private-use URI scheme based redirects, authorization servers
   <em>SHOULD</em> enforce the requirement in <a href="#section-7.1">Section 7.1</a> that clients use
   reverse domain name based schemes.  At a minimum, any scheme that
   doesn't contain a period character ("."), <em>SHOULD</em> be rejected.

   In addition to the collision resistant properties, requiring a URI
   scheme based on a domain name that is under the control of the app
   can help to prove ownership in the event of a dispute where two apps
   claim the same private-use URI scheme (where one app is acting
   maliciously).  For example, if two apps claimed "com.example.app",
   the owner of "example.com" could petition the app store operator to
   remove the counterfeit app.  Such a petition is harder to prove if a
   generic URI scheme was used.

   Authorization servers <em>MAY</em> request the inclusion of other platform-
   specific information, such as the app package or bundle name, or
   other information used to associate the app that may be useful for
   verifying the calling app's identity, on operating systems that
   support such functions.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.5.%20%20Client%20Authentication"></a></body></html><a class="selflink" href="#section-8.5" id="section-8.5">8.5</a>.  Client Authentication</span>

   Secrets that are statically included as part of an app distributed to
   multiple users should not be treated as confidential secrets, as one
   user may inspect their copy and learn the shared secret.  For this
   reason, and those stated in <a href="/doc/html/rfc6819#section-5.3.1">SectionÂ 5.3.1 of [RFC6819]</a>, it is NOT
   <em>RECOMMENDED</em> for authorization servers to require client
   authentication of public native apps clients using a shared secret,
   as this serves little value beyond client identification which is
   already provided by the "client_id" request parameter.

   Authorization servers that still require a statically included shared
   secret for native app clients <em>MUST</em> treat the client as a public
   client (as defined by <a href="#section-2.1">Section 2.1</a> of OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>]), and not
   accept the secret as proof of the client's identity.  Without
   additional measures, such clients are subject to client impersonation
   (see <a href="#section-8.6">Section 8.6</a>).

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.6.%20%20Client%20Impersonation"></a></body></html><a class="selflink" href="#section-8.6" id="section-8.6">8.6</a>.  Client Impersonation</span>

   As stated in <a href="#section-10.2">Section 10.2</a> of OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>], the authorization
   server <em>SHOULD NOT</em> process authorization requests automatically
   without user consent or interaction, except when the identity of the
   client can be assured.  This includes the case where the user has



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   previously approved an authorization request for a given client id -
   unless the identity of the client can be proven, the request <em>SHOULD</em>
   be processed as if no previous request had been approved.

   Measures such as claimed HTTPS redirects <em>MAY</em> be accepted by
   authorization servers as identity proof.  Some operating systems may
   offer alternative platform-specific identity features which <em>MAY</em> be
   accepted, as appropriate.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.7.%20%20Fake%20External%20User-Agent"></a></body></html><a class="selflink" href="#section-8.7" id="section-8.7">8.7</a>.  Fake External User-Agent</span>

   The native app which is initiating the authorization request has a
   large degree of control over the user interface and can potentially
   present a fake external user-agent, that is, an embedded user-agent
   made to appear as an external user agent.

   The advantage when all good actors are using external user-agents is
   that it is possible for security experts to detect bad actors, as
   anyone faking an external user-agent is provably bad.  If good and
   bad actors alike are using embedded user-agents, bad actors don't
   need to fake anything, making them harder to detect.  Once malicious
   apps are detected, it may be possible to use this knowledge to
   blacklist the apps signatures in malware scanning software, take
   removal action in the case of apps distributed by app stores, and
   other steps to reduce the impact and spread of the malicious app.

   Authorization servers can also directly protect against fake external
   user-agents by requiring an authentication factor only available to
   true external user-agents.

   Users who are particularly concerned about their security when using
   in-app browser tabs may also take the additional step of opening the
   request in the full browser from the in-app browser tab, and complete
   the authorization there, as most implementations of the in-app
   browser tab pattern offer such functionality.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.8.%20%20Malicious%20External%20User-Agent"></a></body></html><a class="selflink" href="#section-8.8" id="section-8.8">8.8</a>.  Malicious External User-Agent</span>

   If a malicious app is able to configure itself as the default handler
   for "https" scheme URIs in the operating system, it will be able to
   intercept authorization requests that use the default browser and
   abuse this position of trust for malicious ends such as phishing the
   user.

   Many operating systems mitigate this issue by requiring an explicit
   user action to change the default handler for HTTP URIs.  This attack
   is not confined to OAuth for Native Apps, a malicious app configured




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   in this way would present a general and ongoing risk to the user
   beyond OAuth usage.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.9.%20%20Cross-App%20Request%20Forgery%20Protections"></a></body></html><a class="selflink" href="#section-8.9" id="section-8.9">8.9</a>.  Cross-App Request Forgery Protections</span>

   <a href="/doc/html/rfc6819#section-5.3.5">SectionÂ 5.3.5 of [RFC6819]</a> recommends using the "state" parameter to
   link client requests and responses to prevent CSRF (Cross Site
   Request Forgery) attacks.

   To mitigate CSRF style attacks using inter-app URI communication, it
   is similarly <em>RECOMMENDED</em> that native apps include a high entropy
   secure random number in the "state" parameter of the authorization
   request, and reject any incoming authorization responses without a
   state value that matches a pending outgoing authorization request.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.10.%20%20Authorization%20Server%20Mix-Up%20Mitigation"></a></body></html><a class="selflink" href="#section-8.10" id="section-8.10">8.10</a>.  Authorization Server Mix-Up Mitigation</span>

   To protect against a compromised or malicious authorization server
   attacking another authorization server used by the same app, it is
   <em>REQUIRED</em> that a unique redirect URI is used for each authorization
   server used by the app (for example, by varying the path component),
   and that authorization responses are rejected if the redirect URI
   they were received on doesn't match the redirect URI in a outgoing
   authorization request.

   The native app <em>MUST</em> store the redirect URI used in the authorization
   request with the authorization session data (i.e., along with "state"
   and other related data), and <em>MUST</em> verify that the URI on which the
   authorization response was received exactly matches it.

   The requirements of <a href="#section-8.4">Section 8.4</a> that authorization servers reject
   requests with URIs that don't match what was registered are also
   required to prevent such attacks.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.11.%20%20Non-Browser%20External%20User-Agents"></a></body></html><a class="selflink" href="#section-8.11" id="section-8.11">8.11</a>.  Non-Browser External User-Agents</span>

   This best practice recommends a particular type of external user-
   agent, the user's browser.  Other external user-agent patterns may
   also be viable for secure and usable OAuth.  This document makes no
   comment on those patterns.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.12.%20%20Embedded%20User-Agents"></a></body></html><a class="selflink" href="#section-8.12" id="section-8.12">8.12</a>.  Embedded User-Agents</span>

   OAuth 2.0 <a href="/doc/html/rfc6749#section-9">[RFC6749] SectionÂ 9</a> documents two approaches for native
   apps to interact with the authorization endpoint.  This best current
   practice requires that native apps <em>MUST NOT</em> use embedded user-agents
   to perform authorization requests, and allows that authorization
   endpoints <em>MAY</em> take steps to detect and block authorization requests



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   in embedded user-agents.  The security considerations for these
   requirements are detailed herein.

   Embedded user-agents are an alternative method for authorizing native
   apps.  These embedded user agents are unsafe for use by third-parties
   to the authorization server by definition, as the app that hosts the
   embedded user-agent can access the user's full authentication
   credential, not just the OAuth authorization grant that was intended
   for the app.

   In typical web-view based implementations of embedded user-agents,
   the host application can: log every keystroke entered in the form to
   capture usernames and passwords; automatically submit forms and
   bypass user-consent; copy session cookies and use them to perform
   authenticated actions as the user.

   Even when used by trusted apps belonging to the same party as the
   authorization server, embedded user-agents violate the principle of
   least privilege by having access to more powerful credentials than
   they need, potentially increasing the attack surface.

   Encouraging users to enter credentials in an embedded user-agent
   without the usual address bar and visible certificate validation
   features that browsers have makes it impossible for the user to know
   if they are signing in to the legitimate site, and even when they
   are, it trains them that it's OK to enter credentials without
   validating the site first.

   Aside from the security concerns, embedded user-agents do not share
   the authentication state with other apps or the browser, requiring
   the user to login for every authorization request which is often
   considered an inferior user experience.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.%20%20IANA%20Considerations"></a></body></html><a class="selflink" href="#section-9" id="section-9">9</a>.  IANA Considerations</span>

   [RFC Editor: please do NOT remove this section.]

   This document has no IANA actions.

   <a href="#section-7.1">Section 7.1</a> specifies how private-use URI schemes are used for inter-
   app communication in OAuth protocol flows.  This document requires in
   <a href="#section-7.1">Section 7.1</a> that such schemes are based on domain names owned or
   assigned to the app, as recommended in <a href="/doc/html/rfc7595#section-3.8">SectionÂ 3.8 of [RFC7595]</a>.  Per
   <a href="/doc/html/rfc7595#section-6">SectionÂ 6 of [RFC7595]</a>, registration of domain based URI schemes with
   IANA is not required.






<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.%20%20References"></a></body></html><a class="selflink" href="#section-10" id="section-10">10</a>.  References</span>

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.1.%20%20Normative%20References"></a></body></html><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="/doc/html/rfc3986">RFC 3986</a>, DOI 10.17487/RFC3986, January 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a id="ref-RFC6749">RFC6749</a>]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              <a href="/doc/html/rfc6749">RFC 6749</a>, DOI 10.17487/RFC6749, October 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6749">http://www.rfc-editor.org/info/rfc6749</a>&gt;.

   [<a id="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              <a href="/doc/html/rfc7230">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.

   [<a id="ref-RFC7595">RFC7595</a>]  Thaler, D., Ed., Hansen, T., and T. Hardie, "Guidelines
              and Registration Procedures for URI Schemes", <a href="/doc/html/bcp35">BCP 35</a>,
              <a href="/doc/html/rfc7595">RFC 7595</a>, DOI 10.17487/RFC7595, June 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7595">http://www.rfc-editor.org/info/rfc7595</a>&gt;.

   [<a id="ref-RFC7636">RFC7636</a>]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key
              for Code Exchange by OAuth Public Clients", <a href="/doc/html/rfc7636">RFC 7636</a>,
              DOI 10.17487/RFC7636, September 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7636">http://www.rfc-editor.org/info/rfc7636</a>&gt;.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.2.%20%20Informative%20References"></a></body></html><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-RFC6819">RFC6819</a>]  Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0
              Threat Model and Security Considerations", <a href="/doc/html/rfc6819">RFC 6819</a>,
              DOI 10.17487/RFC6819, January 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6819">http://www.rfc-editor.org/info/rfc6819</a>&gt;.

   [<a id="ref-RFC7591">RFC7591</a>]  Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and
              P. Hunt, "OAuth 2.0 Dynamic Client Registration Protocol",
              <a href="/doc/html/rfc7591">RFC 7591</a>, DOI 10.17487/RFC7591, July 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7591">http://www.rfc-editor.org/info/rfc7591</a>&gt;.

   [<a id="ref-AppAuth">AppAuth</a>]  Denniss, W., Wright, S., McGinniss, I., Ravikumar, R., and
              others, "AppAuth", May 22, &lt;<a href="https://appauth.io">https://appauth.io</a>&gt;.




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   [<a id="ref-AppAuth.iOSmacOS">AppAuth.iOSmacOS</a>]
              Wright, S., Denniss, W., and others, "AppAuth for iOS and
              macOS", February 2016, &lt;<a href="https://github.com/openid/AppAuth-iOS">https://github.com/openid/AppAuth-</a>
              <a href="https://github.com/openid/AppAuth-iOS">iOS</a>&gt;.

   [<a id="ref-AppAuth.Android">AppAuth.Android</a>]
              McGinniss, I., Denniss, W., and others, "AppAuth for
              Android", February 2016, &lt;<a href="https://github.com/openid/AppAuth-Android">https://github.com/openid/</a>
              <a href="https://github.com/openid/AppAuth-Android">AppAuth-Android</a>&gt;.

   [<a id="ref-SamplesForWindows">SamplesForWindows</a>]
              Denniss, W., "OAuth for Apps: Samples for Windows", July
              2016, &lt;<a href="https://github.com/googlesamples/oauth-apps-for-windows">https://github.com/googlesamples/oauth-apps-for-</a>
              <a href="https://github.com/googlesamples/oauth-apps-for-windows">windows</a>&gt;.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20A.%20%20Server%20Support%20Checklist"></a></body></html><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Server Support Checklist</span>

   OAuth servers that support native apps must:

   1.  Support private-use URI scheme redirect URIs.  This is required
       to support mobile operating systems.  See <a href="#section-7.1">Section 7.1</a>.

   2.  Support HTTPS scheme redirect URIs for use with public native app
       clients.  This is used by apps on advanced mobile operating
       systems that allow app-claimed URIs.  See <a href="#section-7.2">Section 7.2</a>.

   3.  Support loopback IP redirect URIs.  This is required to support
       desktop operating systems.  See <a href="#section-7.3">Section 7.3</a>.

   4.  Not assume native app clients can keep a secret.  If secrets are
       distributed to multiple installs of the same native app, they
       should not be treated as confidential.  See <a href="#section-8.5">Section 8.5</a>.

   5.  Support PKCE [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>].  Required to protect authorization code
       grants sent to public clients over inter-app communication
       channels.  See <a href="#section-8.1">Section 8.1</a>

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20B.%20%20Operating%20System%20Specific%20Implementation%20Details"></a></body></html><a class="selflink" href="#appendix-B" id="appendix-B">Appendix B</a>.  Operating System Specific Implementation Details</span>

   This document primarily defines best practices in a generic manner,
   referencing techniques commonly available in a variety of
   environments.  This non-normative section documents operating system
   specific implementation details of the best practice.

   The implementation details herein are considered accurate at the time
   of publishing but will likely change over time.  It is hoped that
   such change won't invalidate the generic principles in the rest of




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   the document, and those principles should take precedence in the
   event of a conflict.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/B.1.%20%20iOS%20Implementation%20Details"></a></body></html><a class="selflink" href="#appendix-B.1" id="appendix-B.1">B.1</a>.  iOS Implementation Details</span>

   Apps can initiate an authorization request in the browser without the
   user leaving the app, through the SFSafariViewController class which
   implements the in-app browser tab pattern.  Safari can be used to
   handle requests on old versions of iOS without
   SFSafariViewController.

   To receive the authorization response, both private-use URI scheme
   redirects (referred to as Custom URL Schemes) and claimed HTTPS links
   (known as Universal Links) are viable choices, and function the same
   whether the request is loaded in SFSafariViewController or the Safari
   app.  Apps can claim Custom URI schemes with the "CFBundleURLTypes"
   key in the application's property list file "Info.plist", and HTTPS
   links using the Universal Links feature with an entitlement file and
   an association file on the domain.

   Universal Links are the preferred choice on iOS 9 and above due to
   the ownership proof that is provided by the operating system.

   A complete open source sample is included in the AppAuth for iOS and
   macOS [<a href="#ref-AppAuth.iOSmacOS">AppAuth.iOSmacOS</a>] library.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/B.2.%20%20Android%20Implementation%20Details"></a></body></html><a class="selflink" href="#appendix-B.2" id="appendix-B.2">B.2</a>.  Android Implementation Details</span>

   Apps can initiate an authorization request in the browser without the
   user leaving the app, through the Android Custom Tab feature which
   implements the in-app browser tab pattern.  The user's default
   browser can be used to handle requests when no browser supports
   Custom Tabs.

   Android browser vendors should support the Custom Tabs protocol (by
   providing an implementation of the "CustomTabsService" class), to
   provide the in-app browser tab user experience optimization to their
   users.  Chrome is one such browser that implements Custom Tabs.

   To receive the authorization response, private-use URI schemes are
   broadly supported through Android Implicit Intents.  Claimed HTTPS
   redirect URIs through Android App Links are available on Android 6.0
   and above.  Both types of redirect URIs are registered in the
   application's manifest.

   A complete open source sample is included in the AppAuth for Android
   [<a href="#ref-AppAuth.Android">AppAuth.Android</a>] library.




<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/B.3.%20%20Windows%20Implementation%20Details"></a></body></html><a class="selflink" href="#appendix-B.3" id="appendix-B.3">B.3</a>.  Windows Implementation Details</span>

   Both traditional and Universal Windows Platform (UWP) apps can
   perform authorization requests in the user's browser.  Traditional
   apps typically use a loopback redirect to receive the authorization
   response, and listening on the loopback interface is allowed by
   default firewall rules.  When creating the loopback network socket,
   apps <em>SHOULD</em> set the "SO_EXCLUSIVEADDRUSE" socket option to prevent
   other apps binding to the same socket.

   UWP apps can use private-use URI scheme redirects to receive the
   authorization response from the browser, which will bring the app to
   the foreground.  Known on the platform as "URI Activation", the URI
   scheme is limited to 39 characters in length, and may include the "."
   character, making short reverse domain name based schemes (as
   recommended in <a href="#section-7.1">Section 7.1</a>) possible.

   UWP apps can alternatively use the Web Authentication Broker API in
   SSO (Single Sign-on) mode, which is an external user agent designed
   for authorization flows.  Cookies are shared between invocations of
   the broker but not the user's preferred browser, meaning the user
   will need to sign-in again even if they have an active session in
   their browser, but the session created in the broker will be
   available to subsequent apps that use the broker.  Personalisations
   the user has made to their browser, such as configuring a password
   manager may not available in the broker.  To qualify as an external
   user-agent, the broker <em>MUST</em> be used in SSO mode.

   To use the Web Authentication Broker in SSO mode, the redirect URI
   must be of the form "msapp://{appSID}" where "appSID" is the app's
   SID, which can be found in the app's registration information.  While
   Windows enforces the URI authority on such redirects, ensuring only
   the app with the matching SID can receive the response on Windows,
   the URI scheme could be claimed by apps on other platforms without
   the same authority present, thus this redirect type should be treated
   similar to private-use URI scheme redirects for security purposes.

   An open source sample demonstrating these patterns is available
   [<a href="#ref-SamplesForWindows">SamplesForWindows</a>].

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/B.4.%20%20macOS%20Implementation%20Details"></a></body></html><a class="selflink" href="#appendix-B.4" id="appendix-B.4">B.4</a>.  macOS Implementation Details</span>

   Apps can initiate an authorization request in the user's default
   browser using platform APIs for opening URIs in the browser.

   To receive the authorization response, private-use URI schemes are a
   good redirect URI choice on macOS, as the user is returned right back
   to the app they launched the request from.  These are registered in



<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   the application's bundle information property list using the
   "CFBundleURLSchemes" key.  Loopback IP redirects are another viable
   option, and listening on the loopback interface is allowed by default
   firewall rules.

   A complete open source sample is included in the AppAuth for iOS and
   macOS [<a href="#ref-AppAuth.iOSmacOS">AppAuth.iOSmacOS</a>] library.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/B.5.%20%20Linux%20Implementation%20Details"></a></body></html><a class="selflink" href="#appendix-B.5" id="appendix-B.5">B.5</a>.  Linux Implementation Details</span>

   Opening the Authorization Request in the user's default browser
   requires a distro-specific command, "xdg-open" is one such tool.

   The loopback redirect is the recommended redirect choice for desktop
   apps on Linux to receive the authorization response.  Apps <em>SHOULD NOT</em>
   set the "SO_REUSEPORT" or "SO_REUSEADDR" socket options, to prevent
   other apps binding to the same socket.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20C.%20%20Acknowledgements"></a></body></html><a class="selflink" href="#appendix-C" id="appendix-C">Appendix C</a>.  Acknowledgements</span>

   The author would like to acknowledge the work of Marius Scurtescu,
   and Ben Wiley Sittler whose design for using private-use URI schemes
   in native OAuth 2.0 clients at Google formed the basis of
   <a href="#section-7.1">Section 7.1</a>.

   The following individuals contributed ideas, feedback, and wording
   that shaped and formed the final specification:

   Andy Zmolek, Steven E Wright, Brian Campbell, Nat Sakimura, Eric
   Sachs, Paul Madsen, Iain McGinniss, Rahul Ravikumar, Breno de
   Medeiros, Hannes Tschofenig, Ashish Jain, Erik Wahlstrom, Bill
   Fisher, Sudhi Umarji, Michael B. Jones, Vittorio Bertocci, Dick
   Hardt, David Waite, Ignacio Fiorentino, Kathleen Moriarty, and Elwyn
   Davies.

Authors' Addresses

   William Denniss
   Google
   1600 Amphitheatre Pkwy
   Mountain View, CA  94043
   USA

   Email: wdenniss@google.com
   URI:   <a href="http://wdenniss.com/appauth">http://wdenniss.com/appauth</a>






<span class="grey">Denniss &amp; Bradley       Expires December 11, 2017              [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey">Internet-Draft          OAuth 2.0 for Native Apps              June 2017</span>


   John Bradley
   Ping Identity

   Phone: +1 202-630-5272
   Email: ve7jtb@ve7jtb.com
   URI:   <a href="http://www.thread-safe.com/p/appauth.html">http://www.thread-safe.com/p/appauth.html</a>













































Denniss &amp; Bradley       Expires December 11, 2017              [Page 21]
</pre>
</div>
</div>
</div>
<script>$(".visible-nojs").removeClass("visible-nojs");</script>
<script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
<script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>
</body>
</html>
