<!DOCTYPE html>
<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html --><html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<title>
  
    draft-parecki-oauth-v2-1-03
  
</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>
<!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.38.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.38.0/respond/dest/respond.min.js"></script>
    <![endif]-->
<link href="/feed/document-changes/draft-parecki-oauth-v2-1/" rel="alternate" title="Document changes" type="application/atom+xml"/>
<meta content="The OAuth 2.1 Authorization Framework (Internet-Draft, 2020)" name="description"/>
<script src="https://www.ietf.org/lib/dt/7.38.0/d3/d3.min.js"></script>
<script src="https://www.ietf.org/lib/dt/7.38.0/jquery/jquery.min.js"></script>
<link href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/ietf-icon-blue3.png" rel="shortcut icon"/>
<link href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/apple-touch-icon.png" rel="apple-touch-icon"/>
</head>
<body style="padding-top: 0;">
<div class="content" id="content">
<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
<div class="rfcmarkup">
<div class="noprint" style="height: 6px;">
<div class="meta-info bgred" onclick="showLegend();" onmouseout="hideLegend()" onmouseover="this.style.cursor='pointer';" style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; " title="Click for colour legend.">Â </div>
<div class="meta-info noprint pre legend" id="legend" onmouseout="hideLegend();" onmouseover="showLegend();" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
</div>
</div>
<div class="noprint">
<pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.ietf.org/archive/id/draft-parecki-oauth-v2-1-03.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.ietf.org/archive/id/draft-parecki-oauth-v2-1-03.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.ietf.org/archive/id/draft-parecki-oauth-v2-1-03.xml" title="XML source for this document">xml</a>|<a href="https://tools.ietf.org/pdf/draft-parecki-oauth-v2-1-03.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/draft-parecki-oauth-v2-1/03/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/draft-parecki-oauth-v2-1/" title="Datatracker information for this document">Tracker</a>] [<a href="mailto:draft-parecki-oauth-v2-1@ietf.org?subject=draft-parecki-oauth-v2-1" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=draft-parecki-oauth-v2-1-03.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-parecki-oauth-v2-1-03.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-parecki-oauth-v2-1-03.txt" title="Run an idnits check of this document">Nits</a>]

Versions: <a href="/doc/html/draft-parecki-oauth-v2-1-00">00</a> <a href="/doc/html/draft-parecki-oauth-v2-1-01">01</a> <a href="/doc/html/draft-parecki-oauth-v2-1-02">02</a> <a href="/doc/html/draft-parecki-oauth-v2-1-03"><b>03</b></a> <a href="/doc/html/draft-ietf-oauth-v2-1">draft-ietf-oauth-v2-1</a>                             </pre>
</div>
<div class="draftcontent">
<pre>OAuth Working Group                                             D. Hardt
Internet-Draft                                                SignIn.Org
Intended status: Standards Track                              A. Parecki
Expires: 6 January 2021                                             Okta
                                                          T. Lodderstedt
                                                                 yes.com
                                                             5 July 2020


                 <span class="h1">The OAuth 2.1 Authorization Framework</span>
                      <span class="h1">draft-parecki-oauth-v2-1-03</span>

Abstract

   The OAuth 2.1 authorization framework enables a third-party
   application to obtain limited access to an HTTP service, either on
   behalf of a resource owner by orchestrating an approval interaction
   between the resource owner and the HTTP service, or by allowing the
   third-party application to obtain access on its own behalf.  This
   specification replaces and obsoletes the OAuth 2.0 Authorization
   Framework described in <a href="/doc/html/rfc6749">RFC 6749</a>.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="/doc/html/bcp78">BCP 78</a> and <a href="/doc/html/bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 6 January 2021.

Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/</a>
   <a href="https://trustee.ietf.org/license-info">license-info</a>) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights



<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the <a href="https://trustee.ietf.org/license-info">Trust Legal Provisions</a> and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-1.1">1.1</a>.  Roles . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-1.2">1.2</a>.  Protocol Flow . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-1.3">1.3</a>.  Authorization Grant . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
       <a href="#section-1.3.1">1.3.1</a>.  Authorization Code  . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
       <a href="#section-1.3.2">1.3.2</a>.  Client Credentials  . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-1.4">1.4</a>.  Access Token  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-1.5">1.5</a>.  Refresh Token . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-1.6">1.6</a>.  TLS Version . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-1.7">1.7</a>.  HTTP Redirections . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-1.8">1.8</a>.  Interoperability  . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-1.9">1.9</a>.  Notational Conventions  . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
   <a href="#section-2">2</a>.  Client Registration . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-2.1">2.1</a>.  Client Types  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-2.2">2.2</a>.  Client Identifier . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-2.3">2.3</a>.  Client Authentication . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
       <a href="#section-2.3.1">2.3.1</a>.  Client Password . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
       <a href="#section-2.3.2">2.3.2</a>.  Other Authentication Methods  . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-2.4">2.4</a>.  Unregistered Clients  . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#section-3">3</a>.  Protocol Endpoints  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-3.1">3.1</a>.  Authorization Endpoint  . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
       <a href="#section-3.1.1">3.1.1</a>.  Response Type . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
       <a href="#section-3.1.2">3.1.2</a>.  Redirection Endpoint  . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-3.2">3.2</a>.  Token Endpoint  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
       <a href="#section-3.2.1">3.2.1</a>.  Client Authentication . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-3.3">3.3</a>.  Access Token Scope  . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-4">4</a>.  Obtaining Authorization . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
     <a href="#section-4.1">4.1</a>.  Authorization Code Grant  . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
       <a href="#section-4.1.1">4.1.1</a>.  Authorization Request . . . . . . . . . . . . . . . .  <a href="#page-24">24</a>
       <a href="#section-4.1.2">4.1.2</a>.  Authorization Response  . . . . . . . . . . . . . . .  <a href="#page-27">27</a>
       <a href="#section-4.1.3">4.1.3</a>.  Access Token Request  . . . . . . . . . . . . . . . .  <a href="#page-30">30</a>
       <a href="#section-4.1.4">4.1.4</a>.  Access Token Response . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
     <a href="#section-4.2">4.2</a>.  Client Credentials Grant  . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
       <a href="#section-4.2.1">4.2.1</a>.  Authorization Request and Response  . . . . . . . . .  <a href="#page-32">32</a>
       <a href="#section-4.2.2">4.2.2</a>.  Access Token Request  . . . . . . . . . . . . . . . .  <a href="#page-32">32</a>
       <a href="#section-4.2.3">4.2.3</a>.  Access Token Response . . . . . . . . . . . . . . . .  <a href="#page-33">33</a>
     <a href="#section-4.3">4.3</a>.  Extension Grants  . . . . . . . . . . . . . . . . . . . .  <a href="#page-33">33</a>
   <a href="#section-5">5</a>.  Issuing an Access Token . . . . . . . . . . . . . . . . . . .  <a href="#page-34">34</a>
     <a href="#section-5.1">5.1</a>.  Successful Response . . . . . . . . . . . . . . . . . . .  <a href="#page-34">34</a>
     <a href="#section-5.2">5.2</a>.  Error Response  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-35">35</a>
   <a href="#section-6">6</a>.  Refreshing an Access Token  . . . . . . . . . . . . . . . . .  <a href="#page-37">37</a>



<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


     <a href="#section-6.1">6.1</a>.  Refresh Token Protection  . . . . . . . . . . . . . . . .  <a href="#page-38">38</a>
   <a href="#section-7">7</a>.  Accessing Protected Resources . . . . . . . . . . . . . . . .  <a href="#page-40">40</a>
     <a href="#section-7.1">7.1</a>.  Access Token Types  . . . . . . . . . . . . . . . . . . .  <a href="#page-40">40</a>
     <a href="#section-7.2">7.2</a>.  Bearer Tokens . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-41">41</a>
       <a href="#section-7.2.1">7.2.1</a>.  Authenticated Requests  . . . . . . . . . . . . . . .  <a href="#page-41">41</a>
       <a href="#section-7.2.2">7.2.2</a>.  The WWW-Authenticate Response Header Field  . . . . .  <a href="#page-43">43</a>
       <a href="#section-7.2.3">7.2.3</a>.  Error Codes . . . . . . . . . . . . . . . . . . . . .  <a href="#page-44">44</a>
     <a href="#section-7.3">7.3</a>.  Error Response  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-45">45</a>
       <a href="#section-7.3.1">7.3.1</a>.  Extension Token Types . . . . . . . . . . . . . . . .  <a href="#page-45">45</a>
     <a href="#section-7.4">7.4</a>.  Access Token Security Considerations  . . . . . . . . . .  <a href="#page-45">45</a>
       <a href="#section-7.4.1">7.4.1</a>.  Security Threats  . . . . . . . . . . . . . . . . . .  <a href="#page-46">46</a>
       <a href="#section-7.4.2">7.4.2</a>.  Threat Mitigation . . . . . . . . . . . . . . . . . .  <a href="#page-46">46</a>
       <a href="#section-7.4.3">7.4.3</a>.  Summary of Recommendations  . . . . . . . . . . . . .  <a href="#page-48">48</a>
       <a href="#section-7.4.4">7.4.4</a>.  Token Replay Prevention . . . . . . . . . . . . . . .  <a href="#page-49">49</a>
       <a href="#section-7.4.5">7.4.5</a>.  Access Token Privilege Restriction  . . . . . . . . .  <a href="#page-50">50</a>
   <a href="#section-8">8</a>.  Extensibility . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-50">50</a>
     <a href="#section-8.1">8.1</a>.  Defining Access Token Types . . . . . . . . . . . . . . .  <a href="#page-50">50</a>
     <a href="#section-8.2">8.2</a>.  Defining New Endpoint Parameters  . . . . . . . . . . . .  <a href="#page-51">51</a>
     <a href="#section-8.3">8.3</a>.  Defining New Authorization Grant Types  . . . . . . . . .  <a href="#page-51">51</a>
     <a href="#section-8.4">8.4</a>.  Defining New Authorization Endpoint Response Types  . . .  <a href="#page-51">51</a>
     <a href="#section-8.5">8.5</a>.  Defining Additional Error Codes . . . . . . . . . . . . .  <a href="#page-52">52</a>
   <a href="#section-9">9</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-52">52</a>
     <a href="#section-9.1">9.1</a>.  Client Authentication . . . . . . . . . . . . . . . . . .  <a href="#page-53">53</a>
       <a href="#section-9.1.1">9.1.1</a>.  Client Authentication of Native Apps  . . . . . . . .  <a href="#page-53">53</a>
     <a href="#section-9.2">9.2</a>.  Registration of Native App Clients  . . . . . . . . . . .  <a href="#page-54">54</a>
     <a href="#section-9.3">9.3</a>.  Client Impersonation  . . . . . . . . . . . . . . . . . .  <a href="#page-54">54</a>
       <a href="#section-9.3.1">9.3.1</a>.  Impersonation of Native Apps  . . . . . . . . . . . .  <a href="#page-55">55</a>
     <a href="#section-9.4">9.4</a>.  Access Tokens . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-55">55</a>
       <a href="#section-9.4.1">9.4.1</a>.  Access Token Privilege Restriction  . . . . . . . . .  <a href="#page-56">56</a>
       <a href="#section-9.4.2">9.4.2</a>.  Access Token Replay Prevention  . . . . . . . . . . .  <a href="#page-56">56</a>
     <a href="#section-9.5">9.5</a>.  Refresh Tokens  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-57">57</a>
     <a href="#section-9.6">9.6</a>.  Client Impersonating Resource Owner . . . . . . . . . . .  <a href="#page-57">57</a>
     <a href="#section-9.7">9.7</a>.  Protecting Redirect-Based Flows . . . . . . . . . . . . .  <a href="#page-58">58</a>
       <a href="#section-9.7.1">9.7.1</a>.  Loopback Redirect Considerations in Native Apps . . .  <a href="#page-58">58</a>
       <a href="#section-9.7.2">9.7.2</a>.  HTTP 307 Redirect . . . . . . . . . . . . . . . . . .  <a href="#page-59">59</a>
     <a href="#section-9.8">9.8</a>.  Authorization Codes . . . . . . . . . . . . . . . . . . .  <a href="#page-60">60</a>
     <a href="#section-9.9">9.9</a>.  Request Confidentiality . . . . . . . . . . . . . . . . .  <a href="#page-61">61</a>
     <a href="#section-9.10">9.10</a>. Ensuring Endpoint Authenticity  . . . . . . . . . . . . .  <a href="#page-61">61</a>
     <a href="#section-9.11">9.11</a>. Credentials-Guessing Attacks  . . . . . . . . . . . . . .  <a href="#page-62">62</a>
     <a href="#section-9.12">9.12</a>. Phishing Attacks  . . . . . . . . . . . . . . . . . . . .  <a href="#page-62">62</a>
     <a href="#section-9.13">9.13</a>. Fake External User-Agents in Native Apps  . . . . . . . .  <a href="#page-62">62</a>
     <a href="#section-9.14">9.14</a>. Malicious External User-Agents in Native Apps . . . . . .  <a href="#page-63">63</a>
     <a href="#section-9.15">9.15</a>. Cross-Site Request Forgery  . . . . . . . . . . . . . . .  <a href="#page-63">63</a>
     <a href="#section-9.16">9.16</a>. Clickjacking  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-64">64</a>
     <a href="#section-9.17">9.17</a>. Code Injection and Input Validation . . . . . . . . . . .  <a href="#page-65">65</a>
     <a href="#section-9.18">9.18</a>. Open Redirectors  . . . . . . . . . . . . . . . . . . . .  <a href="#page-65">65</a>
       <a href="#section-9.18.1">9.18.1</a>.  Client as Open Redirector  . . . . . . . . . . . . .  <a href="#page-65">65</a>
       <a href="#section-9.18.2">9.18.2</a>.  Authorization Server as Open Redirector  . . . . . .  <a href="#page-65">65</a>



<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


     <a href="#section-9.19">9.19</a>. Authorization Server Mix-Up Mitigation in Native Apps . .  <a href="#page-66">66</a>
     <a href="#section-9.20">9.20</a>. Embedded User Agents in Native Apps . . . . . . . . . . .  <a href="#page-66">66</a>
     <a href="#section-9.21">9.21</a>. Other Recommendations . . . . . . . . . . . . . . . . . .  <a href="#page-67">67</a>
   <a href="#section-10">10</a>. Native Applications . . . . . . . . . . . . . . . . . . . . .  <a href="#page-67">67</a>
     10.1.  Using Inter-App URI Communication for OAuth in Native
            Apps . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-68">68</a>
     10.2.  Initiating the Authorization Request from a Native
            App  . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-69">69</a>
     <a href="#section-10.3">10.3</a>.  Receiving the Authorization Response in a Native App . .  <a href="#page-70">70</a>
       <a href="#section-10.3.1">10.3.1</a>.  Private-Use URI Scheme Redirection . . . . . . . . .  <a href="#page-70">70</a>
       <a href="#section-10.3.2">10.3.2</a>.  Claimed "https" Scheme URI Redirection . . . . . . .  <a href="#page-71">71</a>
       <a href="#section-10.3.3">10.3.3</a>.  Loopback Interface Redirection . . . . . . . . . . .  <a href="#page-71">71</a>
   <a href="#section-11">11</a>. Browser-Based Apps  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-72">72</a>
   <a href="#section-12">12</a>. Differences from OAuth 2.0  . . . . . . . . . . . . . . . . .  <a href="#page-72">72</a>
   <a href="#section-13">13</a>. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-73">73</a>
   <a href="#section-14">14</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-73">73</a>
     <a href="#section-14.1">14.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-73">73</a>
     <a href="#section-14.2">14.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-76">76</a>
   <a href="#appendix-A">Appendix A</a>.  Augmented Backus-Naur Form (ABNF) Syntax . . . . . .  <a href="#page-79">79</a>
     <a href="#appendix-A.1">A.1</a>.  "client_id" Syntax  . . . . . . . . . . . . . . . . . . .  <a href="#page-79">79</a>
     <a href="#appendix-A.2">A.2</a>.  "client_secret" Syntax  . . . . . . . . . . . . . . . . .  <a href="#page-79">79</a>
     <a href="#appendix-A.3">A.3</a>.  "response_type" Syntax  . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
     <a href="#appendix-A.4">A.4</a>.  "scope" Syntax  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
     <a href="#appendix-A.5">A.5</a>.  "state" Syntax  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
     <a href="#appendix-A.6">A.6</a>.  "redirect_uri" Syntax . . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
     <a href="#appendix-A.7">A.7</a>.  "error" Syntax  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
     <a href="#appendix-A.8">A.8</a>.  "error_description" Syntax  . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
     <a href="#appendix-A.9">A.9</a>.  "error_uri" Syntax  . . . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#appendix-A.10">A.10</a>. "grant_type" Syntax . . . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#appendix-A.11">A.11</a>. "code" Syntax . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#appendix-A.12">A.12</a>. "access_token" Syntax . . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#appendix-A.13">A.13</a>. "token_type" Syntax . . . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#appendix-A.14">A.14</a>. "expires_in" Syntax . . . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#appendix-A.15">A.15</a>. "refresh_token" Syntax  . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#appendix-A.16">A.16</a>. Endpoint Parameter Syntax . . . . . . . . . . . . . . . .  <a href="#page-82">82</a>
     <a href="#appendix-A.17">A.17</a>. "code_verifier" Syntax  . . . . . . . . . . . . . . . . .  <a href="#page-82">82</a>
     <a href="#appendix-A.18">A.18</a>. "code_challenge" Syntax . . . . . . . . . . . . . . . . .  <a href="#page-82">82</a>
   <a href="#appendix-B">Appendix B</a>.  Use of application/x-www-form-urlencoded Media
           Type  . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-82">82</a>
   <a href="#appendix-C">Appendix C</a>.  Extensions . . . . . . . . . . . . . . . . . . . . .  <a href="#page-83">83</a>
   <a href="#appendix-D">Appendix D</a>.  Acknowledgements . . . . . . . . . . . . . . . . . .  <a href="#page-84">84</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-84">84</a>









<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.%20%20Introduction"></a></body></html><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   In the traditional client-server authentication model, the client
   requests an access-restricted resource (protected resource) on the
   server by authenticating with the server using the resource owner's
   credentials.  In order to provide third-party applications access to
   restricted resources, the resource owner shares its credentials with
   the third party.  This creates several problems and limitations:

   *  Third-party applications are required to store the resource
      owner's credentials for future use, typically a password in clear-
      text.

   *  Servers are required to support password authentication, despite
      the security weaknesses inherent in passwords.

   *  Third-party applications gain overly broad access to the resource
      owner's protected resources, leaving resource owners without any
      ability to restrict duration or access to a limited subset of
      resources.

   *  Resource owners cannot revoke access to an individual third party
      without revoking access to all third parties, and must do so by
      changing the third party's password.

   *  Compromise of any third-party application results in compromise of
      the end-user's password and all of the data protected by that
      password.

   OAuth addresses these issues by introducing an authorization layer
   and separating the role of the client from that of the resource
   owner.  In OAuth, the client requests access to resources controlled
   by the resource owner and hosted by the resource server, and is
   issued a different set of credentials than those of the resource
   owner.

   Instead of using the resource owner's credentials to access protected
   resources, the client obtains an access token - a string denoting a
   specific scope, lifetime, and other access attributes.  Access tokens
   are issued to third-party clients by an authorization server with the
   approval of the resource owner.  The client uses the access token to
   access the protected resources hosted by the resource server.









<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   For example, an end-user (resource owner) can grant a printing
   service (client) access to her protected photos stored at a photo-
   sharing service (resource server), without sharing her username and
   password with the printing service.  Instead, she authenticates
   directly with a server trusted by the photo-sharing service
   (authorization server), which issues the printing service delegation-
   specific credentials (access token).

   This specification is designed for use with HTTP ([<a href="/doc/html/rfc7230" title='"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing"'>RFC7230</a>]).  The
   use of OAuth over any protocol other than HTTP is out of scope.

   Since the publication of the OAuth 2.0 Authorization Framework
   ([<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>]) in October 2012, it has been updated by OAuth 2.0 for
   Native Apps ([<a href="/doc/html/rfc8252" title='"OAuth 2.0 for Native Apps"'>RFC8252</a>]), OAuth Security Best Current Practice
   ([<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]), and OAuth 2.0 for Browser-Based
   Apps ([<a href="#ref-I-D.ietf-oauth-browser-based-apps">I-D.ietf-oauth-browser-based-apps</a>]).  The OAuth 2.0
   Authorization Framework: Bearer Token Usage ([<a href="/doc/html/rfc6750" title='"The OAuth 2.0 Authorization Framework: Bearer Token Usage"'>RFC6750</a>]) has also been
   updated with ([<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]).  This Standards
   Track specification consolidates the information in all of these
   documents and removes features that have been found to be insecure in
   [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>].

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.1.%20%20Roles"></a></body></html><a class="selflink" href="#section-1.1" id="section-1.1">1.1</a>.  Roles</span>

   OAuth defines four roles:

   "resource owner":  An entity capable of granting access to a
      protected resource.  When the resource owner is a person, it is
      referred to as an end-user.  This is sometimes abbreviated as
      "RO".

   "resource server":  The server hosting the protected resources,
      capable of accepting and responding to protected resource requests
      using access tokens.  This is sometimes abbreviated as "RS".

   "client":  An application making protected resource requests on
      behalf of the resource owner and with its authorization.  The term
      "client" does not imply any particular implementation
      characteristics (e.g., whether the application executes on a
      server, a desktop, or other devices).

   "authorization server":  The server issuing access tokens to the
      client after successfully authenticating the resource owner and
      obtaining authorization.  This is sometimes abbreviated as "AS".

   The interaction between the authorization server and resource server
   is beyond the scope of this specification, however several extension
   have been defined to provide an option for interoperability between



<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   resource servers and authorization servers.  The authorization server
   may be the same server as the resource server or a separate entity.
   A single authorization server may issue access tokens accepted by
   multiple resource servers.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.2.%20%20Protocol%20Flow"></a></body></html><a class="selflink" href="#section-1.2" id="section-1.2">1.2</a>.  Protocol Flow</span>

        +--------+                               +---------------+
        |        |--(1)- Authorization Request -&gt;|   Resource    |
        |        |                               |     Owner     |
        |        |&lt;-(2)-- Authorization Grant ---|               |
        |        |                               +---------------+
        |        |
        |        |                               +---------------+
        |        |--(3)-- Authorization Grant --&gt;| Authorization |
        | Client |                               |     Server    |
        |        |&lt;-(4)----- Access Token -------|               |
        |        |                               +---------------+
        |        |
        |        |                               +---------------+
        |        |--(5)----- Access Token ------&gt;|    Resource   |
        |        |                               |     Server    |
        |        |&lt;-(6)--- Protected Resource ---|               |
        +--------+                               +---------------+

                      Figure 1: Abstract Protocol Flow

   The abstract OAuth 2.1 flow illustrated in Figure 1 describes the
   interaction between the four roles and includes the following steps:

   1.  The client requests authorization from the resource owner.  The
       authorization request can be made directly to the resource owner
       (as shown), or preferably indirectly via the authorization server
       as an intermediary.

   2.  The client receives an authorization grant, which is a credential
       representing the resource owner's authorization, expressed using
       one of two grant types defined in this specification or using an
       extension grant type.  The authorization grant type depends on
       the method used by the client to request authorization and the
       types supported by the authorization server.

   3.  The client requests an access token by authenticating with the
       authorization server and presenting the authorization grant.

   4.  The authorization server authenticates the client and validates
       the authorization grant, and if valid, issues an access token.




<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   5.  The client requests the protected resource from the resource
       server and authenticates by presenting the access token.

   6.  The resource server validates the access token, and if valid,
       serves the request.

   The preferred method for the client to obtain an authorization grant
   from the resource owner (depicted in steps (1) and (2)) is to use the
   authorization server as an intermediary, which is illustrated in
   Figure 3 in <a href="#section-4.1">Section 4.1</a>.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.3.%20%20Authorization%20Grant"></a></body></html><a class="selflink" href="#section-1.3" id="section-1.3">1.3</a>.  Authorization Grant</span>

   An authorization grant is a credential representing the resource
   owner's authorization (to access its protected resources) used by the
   client to obtain an access token.  This specification defines two
   grant types - authorization code and client credentials - as well as
   an extensibility mechanism for defining additional types.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.3.1.%20%20Authorization%20Code"></a></body></html><a class="selflink" href="#section-1.3.1" id="section-1.3.1">1.3.1</a>.  Authorization Code</span>

   The authorization code is obtained by using an authorization server
   as an intermediary between the client and resource owner.  Instead of
   requesting authorization directly from the resource owner, the client
   directs the resource owner to an authorization server (via its user-
   agent as defined in [<a href="/doc/html/rfc7231" title='"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"'>RFC7231</a>]), which in turn directs the resource
   owner back to the client with the authorization code.

   Before directing the resource owner back to the client with the
   authorization code, the authorization server authenticates the
   resource owner and obtains authorization.  Because the resource owner
   only authenticates with the authorization server, the resource
   owner's credentials are never shared with the client.

   The authorization code provides a few important security benefits,
   such as the ability to authenticate the client, as well as the
   transmission of the access token directly to the client without
   passing it through the resource owner's user-agent and potentially
   exposing it to others, including the resource owner.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.3.2.%20%20Client%20Credentials"></a></body></html><a class="selflink" href="#section-1.3.2" id="section-1.3.2">1.3.2</a>.  Client Credentials</span>

   The client credentials (or other forms of client authentication) can
   be used as an authorization grant when the authorization scope is
   limited to the protected resources under the control of the client,
   or to protected resources previously arranged with the authorization
   server.  Client credentials are used as an authorization grant
   typically when the client is acting on its own behalf (the client is



<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   also the resource owner) or is requesting access to protected
   resources based on an authorization previously arranged with the
   authorization server.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.4.%20%20Access%20Token"></a></body></html><a class="selflink" href="#section-1.4" id="section-1.4">1.4</a>.  Access Token</span>

   Access tokens are credentials used to access protected resources.  An
   access token is a string representing an authorization issued to the
   client.  The string is opaque to the client, but depending on the
   authorization server, may be parseable by the resource server.

   Tokens represent specific scopes and durations of access, granted by
   the resource owner, and enforced by the resource server and
   authorization server.

   The token may denote an identifier used to retrieve the authorization
   information or may self-contain the authorization information in a
   verifiable manner (i.e., a token string consisting of some data and a
   signature).  One example of a structured token format is
   [<a href="#ref-I-D.ietf-oauth-access-token-jwt">I-D.ietf-oauth-access-token-jwt</a>], a method of encoding access token
   data as a JSON Web Token [<a href="/doc/html/rfc7519" title='"JSON Web Token (JWT)"'>RFC7519</a>].

   Additional authentication credentials, which are beyond the scope of
   this specification, may be required in order for the client to use a
   token.  This is typically referred to as a sender-constrained access
   token, such as Mutual TLS Access Tokens [<a href="/doc/html/rfc8705" title='"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"'>RFC8705</a>].

   The access token provides an abstraction layer, replacing different
   authorization constructs (e.g., username and password) with a single
   token understood by the resource server.  This abstraction enables
   issuing access tokens more restrictive than the authorization grant
   used to obtain them, as well as removing the resource server's need
   to understand a wide range of authentication methods.

   Access tokens can have different formats, structures, and methods of
   utilization (e.g., cryptographic properties) based on the resource
   server security requirements.  Access token attributes and the
   methods used to access protected resources may be extended beyond
   what is described in this specification.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.5.%20%20Refresh%20Token"></a></body></html><a class="selflink" href="#section-1.5" id="section-1.5">1.5</a>.  Refresh Token</span>

   Refresh tokens are credentials used to obtain access tokens.  Refresh
   tokens are issued to the client by the authorization server and are
   used to obtain a new access token when the current access token
   becomes invalid or expires, or to obtain additional access tokens
   with identical or narrower scope (access tokens may have a shorter
   lifetime and fewer permissions than authorized by the resource



<span class="grey">Hardt, et al.            Expires 6 January 2021                 [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   owner).  Issuing a refresh token is optional at the discretion of the
   authorization server.  If the authorization server issues a refresh
   token, it is included when issuing an access token (i.e., step (4) in
   Figure 2).

   A refresh token is a string representing the authorization granted to
   the client by the resource owner.  The string is usually opaque to
   the client.  The token denotes an identifier used to retrieve the
   authorization information.  Unlike access tokens, refresh tokens are
   intended for use only with authorization servers and are never sent
   to resource servers.

   +--------+                                           +---------------+
   |        |--(1)------- Authorization Grant ---------&gt;|               |
   |        |                                           |               |
   |        |&lt;-(2)----------- Access Token -------------|               |
   |        |               &amp; Refresh Token             |               |
   |        |                                           |               |
   |        |                            +----------+   |               |
   |        |--(3)---- Access Token ----&gt;|          |   |               |
   |        |                            |          |   |               |
   |        |&lt;-(4)- Protected Resource --| Resource |   | Authorization |
   | Client |                            |  Server  |   |     Server    |
   |        |--(5)---- Access Token ----&gt;|          |   |               |
   |        |                            |          |   |               |
   |        |&lt;-(6)- Invalid Token Error -|          |   |               |
   |        |                            +----------+   |               |
   |        |                                           |               |
   |        |--(7)----------- Refresh Token -----------&gt;|               |
   |        |                                           |               |
   |        |&lt;-(8)----------- Access Token -------------|               |
   +--------+           &amp; Optional Refresh Token        +---------------+

                Figure 2: Refreshing an Expired Access Token

   The flow illustrated in Figure 2 includes the following steps:

   1.  The client requests an access token by authenticating with the
       authorization server and presenting an authorization grant.

   2.  The authorization server authenticates the client and validates
       the authorization grant, and if valid, issues an access token and
       optionally a refresh token.

   3.  The client makes a protected resource request to the resource
       server by presenting the access token.





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   4.  The resource server validates the access token, and if valid,
       serves the request.

   5.  Steps (3) and (4) repeat until the access token expires.  If the
       client knows the access token expired, it skips to step (7);
       otherwise, it makes another protected resource request.

   6.  Since the access token is invalid, the resource server returns an
       invalid token error.

   7.  The client requests a new access token by presenting the refresh
       token and providing client authentication if it has been issued
       credentials.  The client authentication requirements are based on
       the client type and on the authorization server policies.

   8.  The authorization server authenticates the client and validates
       the refresh token, and if valid, issues a new access token (and,
       optionally, a new refresh token).

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.6.%20%20TLS%20Version"></a></body></html><a class="selflink" href="#section-1.6" id="section-1.6">1.6</a>.  TLS Version</span>

   Whenever Transport Layer Security (TLS) is used by this
   specification, the appropriate version (or versions) of TLS will vary
   over time, based on the widespread deployment and known security
   vulnerabilities.  At the time of this writing, TLS version 1.3
   [<a href="/doc/html/rfc8446" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>RFC8446</a>] is the most recent version.

   Implementations <em>MAY</em> also support additional transport-layer security
   mechanisms that meet their security requirements.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.7.%20%20HTTP%20Redirections"></a></body></html><a class="selflink" href="#section-1.7" id="section-1.7">1.7</a>.  HTTP Redirections</span>

   This specification makes extensive use of HTTP redirections, in which
   the client or the authorization server directs the resource owner's
   user-agent to another destination.  While the examples in this
   specification show the use of the HTTP 302 status code, any other
   method available via the user-agent to accomplish this redirection,
   with the exception of HTTP 307, is allowed and is considered to be an
   implementation detail.  See <a href="#section-9.7.2">Section 9.7.2</a> for details.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.8.%20%20Interoperability"></a></body></html><a class="selflink" href="#section-1.8" id="section-1.8">1.8</a>.  Interoperability</span>

   OAuth 2.1 provides a rich authorization framework with well-defined
   security properties.







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   This specification leaves a few required components partially or
   fully undefined (e.g., client registration, authorization server
   capabilities, endpoint discovery).  Some of these behaviors are
   defined in optional extensions which implementations can choose to
   use.

   Please refer to <a href="#appendix-C">Appendix C</a> for a list of current known extensions at
   the time of this publication.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/1.9.%20%20Notational%20Conventions"></a></body></html><a class="selflink" href="#section-1.9" id="section-1.9">1.9</a>.  Notational Conventions</span>

   The key words "<em>MUST</em>", "<em>MUST NOT</em>", "<em>REQUIRED</em>", "<em>SHALL</em>", "<em>SHALL NOT</em>",
   "<em>SHOULD</em>", "<em>SHOULD NOT</em>", "<em>RECOMMENDED</em>", "NOT <em>RECOMMENDED</em>", "<em>MAY</em>", and
   "<em>OPTIONAL</em>" in this document are to be interpreted as described in <a href="/doc/html/bcp14">BCP</a>
   <a href="/doc/html/bcp14">14</a> [<a href="/doc/html/rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="/doc/html/rfc8174" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

   This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [<a href="/doc/html/rfc5234" title='"Augmented BNF for Syntax Specifications: ABNF"'>RFC5234</a>].  Additionally, the rule URI-reference is
   included from "Uniform Resource Identifier (URI): Generic Syntax"
   [<a href="/doc/html/rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>].

   Certain security-related terms are to be understood in the sense
   defined in [<a href="/doc/html/rfc4949" title='"Internet Security Glossary, Version 2"'>RFC4949</a>].  These terms include, but are not limited to,
   "attack", "authentication", "authorization", "certificate",
   "confidentiality", "credential", "encryption", "identity", "sign",
   "signature", "trust", "validate", and "verify".

   Unless otherwise noted, all the protocol parameter names and values
   are case sensitive.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.%20%20Client%20Registration"></a></body></html><a class="selflink" href="#section-2" id="section-2">2</a>.  Client Registration</span>

   Before initiating the protocol, the client registers with the
   authorization server.  The means through which the client registers
   with the authorization server are beyond the scope of this
   specification but typically involve end-user interaction with an HTML
   registration form, or by using Dynamic Client Registration
   ([<a href="/doc/html/rfc7591" title='"OAuth 2.0 Dynamic Client Registration Protocol"'>RFC7591</a>]).

   Client registration does not require a direct interaction between the
   client and the authorization server.  When supported by the
   authorization server, registration can rely on other means for
   establishing trust and obtaining the required client properties
   (e.g., redirect URI, client type).  For example, registration can be
   accomplished using a self-issued or third-party-issued assertion, or
   by the authorization server performing client discovery using a
   trusted channel.



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   When registering a client, the client developer <em>SHALL</em>:

   *  specify the client type as described in <a href="#section-2.1">Section 2.1</a>,

   *  provide its client redirect URIs as described in <a href="#section-3.1.2">Section 3.1.2</a>,
      and

   *  include any other information required by the authorization server
      (e.g., application name, website, description, logo image, the
      acceptance of legal terms).

   Dynamic Client Registration ([<a href="/doc/html/rfc7591" title='"OAuth 2.0 Dynamic Client Registration Protocol"'>RFC7591</a>]) defines a common general data
   model for clients that may be used even with manual client
   registration.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.1.%20%20Client%20Types"></a></body></html><a class="selflink" href="#section-2.1" id="section-2.1">2.1</a>.  Client Types</span>

   Clients are identified at the authorization server by a "client_id".
   It is, for example, used by the authorization server to determine the
   set of redirect URIs this client can use.

   Clients requiring a higher level of confidence in their identity by
   the authorization server use credentials to authenticate with the
   authorization server.  Such credentials are either issued by the
   authorization server or registered by the developer of the client
   with the authorization server.

   OAuth 2.1 defines three client types:

   "confidential":  Clients that have credentials and their identity has
      been confirmed by the AS are designated as "confidential clients"

   "credentialed":  Clients that have credentials and their identity has
      been not been confirmed by the AS are designated as "credentialed
      clients"

   "public":  Clients without credentials are called "public clients"

   Any clients with credentials <em>MUST</em> take precautions to prevent leakage
   and abuse of their credentials.

   Authorization servers <em>SHOULD</em> consider the level of confidence in a
   client's identity when deciding whether they allow such a client
   access to more critical functions, such as the Client Credentials
   grant type.

   A single "client_id" <em>MUST NOT</em> be treated as more than one type of
   client.



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   This specification has been designed around the following client
   profiles:

   "web application":  A web application is a confidential client
      running on a web server.  Resource owners access the client via an
      HTML user interface rendered in a user-agent on the device used by
      the resource owner.  The client credentials as well as any access
      token issued to the client are stored on the web server and are
      not exposed to or accessible by the resource owner.

   "browser-based application":  A browser-based application is a public
      client in which the client code is downloaded from a web server
      and executes within a user-agent (e.g., web browser) on the device
      used by the resource owner.  Protocol data and credentials are
      easily accessible (and often visible) to the resource owner.
      Since such applications reside within the user-agent, they can
      make seamless use of the user-agent capabilities when requesting
      authorization.

   "native application":  A native application is a public client
      installed and executed on the device used by the resource owner.
      Protocol data and credentials are accessible to the resource
      owner.  It is assumed that any client authentication credentials
      included in the application can be extracted.  On the other hand,
      dynamically issued credentials such as access tokens or refresh
      tokens can receive an acceptable level of protection.  At a
      minimum, these credentials are protected from hostile servers with
      which the application may interact.  On some platforms, these
      credentials might be protected from other applications residing on
      the same device.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.2.%20%20Client%20Identifier"></a></body></html><a class="selflink" href="#section-2.2" id="section-2.2">2.2</a>.  Client Identifier</span>

   The authorization server issues the registered client a client
   identifier - a unique string representing the registration
   information provided by the client.  The client identifier is not a
   secret; it is exposed to the resource owner and <em>MUST NOT</em> be used
   alone for client authentication.  The client identifier is unique to
   the authorization server.

   The client identifier string size is left undefined by this
   specification.  The client should avoid making assumptions about the
   identifier size.  The authorization server <em>SHOULD</em> document the size
   of any identifier it issues.

   Authorization servers <em>SHOULD NOT</em> allow clients to choose or influence
   their "client_id" value.  See <a href="#section-9.6">Section 9.6</a> for details.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.3.%20%20Client%20Authentication"></a></body></html><a class="selflink" href="#section-2.3" id="section-2.3">2.3</a>.  Client Authentication</span>

   If the client has credentials, (is a confidential or credentialed
   client), the client and authorization server establish a client
   authentication method suitable for the security requirements of the
   authorization server.  The authorization server <em>MAY</em> accept any form
   of client authentication meeting its security requirements.

   Confidential and credentialed clients are typically issued (or
   establish) a set of client credentials used for authenticating with
   the authorization server (e.g., password, public/private key pair).

   Authorization servers <em>SHOULD</em> use client authentication if possible.

   It is <em>RECOMMENDED</em> to use asymmetric (public-key based) methods for
   client authentication such as mTLS [<a href="/doc/html/rfc8705" title='"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"'>RFC8705</a>] or "private_key_jwt"
   [<a href="#ref-OpenID" title='"OpenID Connect Core 1.0"'>OpenID</a>].  When asymmetric methods for client authentication are
   used, authorization servers do not need to store sensitive symmetric
   keys, making these methods more robust against a number of attacks.

   The authorization server <em>MAY</em> establish a client authentication method
   with public clients, which converts them to credentialed clients.
   However, the authorization server <em>MUST NOT</em> rely on credentialed
   client authentication for the purpose of identifying the client.

   The client <em>MUST NOT</em> use more than one authentication method in each
   request.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.3.1.%20%20Client%20Password"></a></body></html><a class="selflink" href="#section-2.3.1" id="section-2.3.1">2.3.1</a>.  Client Password</span>

   Clients in possession of a client password, also known as a client
   secret, <em>MAY</em> use the HTTP Basic authentication scheme as defined in
   [<a href="/doc/html/rfc2617" title='"HTTP Authentication: Basic and Digest Access Authentication"'>RFC2617</a>] to authenticate with the authorization server.  The client
   identifier is encoded using the "application/x-www-form-urlencoded"
   encoding algorithm per <a href="#appendix-B">Appendix B</a>, and the encoded value is used as
   the username; the client secret is encoded using the same algorithm
   and used as the password.  The authorization server <em>MUST</em> support the
   HTTP Basic authentication scheme for authenticating clients that were
   issued a client secret.

   For example (with extra line breaks for display purposes only):

   Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3

   Alternatively, the authorization server <em>MAY</em> support including the
   client credentials in the request-body using the following
   parameters:




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   "client_id":  <em>REQUIRED</em>.  The client identifier issued to the client
      during the registration process described by <a href="#section-2.2">Section 2.2</a>.

   "client_secret":  <em>REQUIRED</em>.  The client secret.

   Including the client credentials in the request-body using the two
   parameters is NOT <em>RECOMMENDED</em> and <em>SHOULD</em> be limited to clients unable
   to directly utilize the HTTP Basic authentication scheme (or other
   password-based HTTP authentication schemes).  The parameters can only
   be transmitted in the request-body and <em>MUST NOT</em> be included in the
   request URI.

   For example, a request to refresh an access token (<a href="#section-6">Section 6</a>) using
   the body parameters (with extra line breaks for display purposes
   only):

   POST /token HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
   &amp;client_id=s6BhdRkqt3&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw

   The authorization server <em>MUST</em> require the use of TLS as described in
   <a href="#section-1.6">Section 1.6</a> when sending requests using password authentication.

   Since this client authentication method involves a password, the
   authorization server <em>MUST</em> protect any endpoint utilizing it against
   brute force attacks.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.3.2.%20%20Other%20Authentication%20Methods"></a></body></html><a class="selflink" href="#section-2.3.2" id="section-2.3.2">2.3.2</a>.  Other Authentication Methods</span>

   The authorization server <em>MAY</em> support any suitable authentication
   scheme matching its security requirements.  When using other
   authentication methods, the authorization server <em>MUST</em> define a
   mapping between the client identifier (registration record) and
   authentication scheme.

   Some additional authentication methods are defined in the "OAuth
   Token Endpoint Authentication Methods
   (<a href="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-endpoint-auth-method">https://www.iana.org/assignments/oauth-parameters/oauth-</a>
   <a href="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-endpoint-auth-method">parameters.xhtml#token-endpoint-auth-method</a>)" registry, and may be
   useful as generic client authentication methods beyond the specific
   use of protecting the token endpoint.







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/2.4.%20%20Unregistered%20Clients"></a></body></html><a class="selflink" href="#section-2.4" id="section-2.4">2.4</a>.  Unregistered Clients</span>

   This specification does not exclude the use of unregistered clients.
   However, the use of such clients is beyond the scope of this
   specification and requires additional security analysis and review of
   its interoperability impact.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.%20%20Protocol%20Endpoints"></a></body></html><a class="selflink" href="#section-3" id="section-3">3</a>.  Protocol Endpoints</span>

   The authorization process utilizes two authorization server endpoints
   (HTTP resources):

   *  Authorization endpoint - used by the client to obtain
      authorization from the resource owner via user-agent redirection.

   *  Token endpoint - used by the client to exchange an authorization
      grant for an access token, typically with client authentication.

   As well as one client endpoint:

   *  Redirection endpoint - used by the authorization server to return
      responses containing authorization credentials to the client via
      the resource owner user-agent.

   Not every authorization grant type utilizes both endpoints.
   Extension grant types <em>MAY</em> define additional endpoints as needed.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.%20%20Authorization%20Endpoint"></a></body></html><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a>.  Authorization Endpoint</span>

   The authorization endpoint is used to interact with the resource
   owner and obtain an authorization grant.  The authorization server
   <em>MUST</em> first verify the identity of the resource owner.  The way in
   which the authorization server authenticates the resource owner
   (e.g., username and password login, session cookies) is beyond the
   scope of this specification.

   The means through which the client obtains the location of the
   authorization endpoint are beyond the scope of this specification,
   but the location is typically provided in the service documentation,
   or in the authorization server's metadata document ([<a href="/doc/html/rfc8414" title='"OAuth 2.0 Authorization Server Metadata"'>RFC8414</a>]).

   The endpoint URI <em>MAY</em> include an "application/x-www-form-urlencoded"
   formatted (per <a href="#appendix-B">Appendix B</a>) query component (<a href="/doc/html/rfc3986#section-3.4">[RFC3986] SectionÂ 3.4</a>),
   which <em>MUST</em> be retained when adding additional query parameters.  The
   endpoint URI <em>MUST NOT</em> include a fragment component.






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Since requests to the authorization endpoint result in user
   authentication and the transmission of clear-text credentials (in the
   HTTP response), the authorization server <em>MUST</em> require the use of TLS
   as described in <a href="#section-1.6">Section 1.6</a> when sending requests to the
   authorization endpoint.

   The authorization server <em>MUST</em> support the use of the HTTP "GET"
   method [<a href="/doc/html/rfc7231" title='"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"'>RFC7231</a>] for the authorization endpoint and <em>MAY</em> support the
   use of the "POST" method as well.

   Parameters sent without a value <em>MUST</em> be treated as if they were
   omitted from the request.  The authorization server <em>MUST</em> ignore
   unrecognized request parameters.  Request and response parameters
   defined by this specification <em>MUST NOT</em> be included more than once.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.1.%20%20Response%20Type"></a></body></html><a class="selflink" href="#section-3.1.1" id="section-3.1.1">3.1.1</a>.  Response Type</span>

   The authorization endpoint is used by the authorization code flow.
   The client informs the authorization server of the desired response
   type using the following parameter:

   "response_type":  <em>REQUIRED</em>.  The value <em>MUST</em> be "code" for requesting
      an authorization code as described by <a href="#section-4.1.1">Section 4.1.1</a>, or a
      registered extension value as described by <a href="#section-8.4">Section 8.4</a>.

   Extension response types <em>MAY</em> contain a space-delimited (%x20) list of
   values, where the order of values does not matter (e.g., response
   type "a b" is the same as "b a").  The meaning of such composite
   response types is defined by their respective specifications.

   If an authorization request is missing the "response_type" parameter,
   or if the response type is not understood, the authorization server
   <em>MUST</em> return an error response as described in <a href="#section-4.1.2.1">Section 4.1.2.1</a>.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.2.%20%20Redirection%20Endpoint"></a></body></html><a class="selflink" href="#section-3.1.2" id="section-3.1.2">3.1.2</a>.  Redirection Endpoint</span>

   After completing its interaction with the resource owner, the
   authorization server directs the resource owner's user-agent back to
   the client.  The authorization server redirects the user-agent to the
   client's redirection endpoint previously established with the
   authorization server during the client registration process.

   The authorization server <em>MUST</em> compare the two URIs using simple
   string comparison as defined in <a href="/doc/html/rfc3986#section-6.2.1">[RFC3986], SectionÂ 6.2.1</a>.

   The redirect URI <em>MUST</em> be an absolute URI as defined by <a href="/doc/html/rfc3986#section-4.3">[RFC3986]
   SectionÂ 4.3</a>.  The endpoint URI <em>MAY</em> include an "application/x-www-
   form-urlencoded" formatted (per <a href="#appendix-B">Appendix B</a>) query component



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   (<a href="/doc/html/rfc3986#section-3.4">[RFC3986] SectionÂ 3.4</a>), which <em>MUST</em> be retained when adding
   additional query parameters.  The endpoint URI <em>MUST NOT</em> include a
   fragment component.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.2.1.%20%20Endpoint%20Request%20Confidentiality"></a></body></html><a class="selflink" href="#section-3.1.2.1" id="section-3.1.2.1">3.1.2.1</a>.  Endpoint Request Confidentiality</span>

   The redirection endpoint <em>SHOULD</em> require the use of TLS as described
   in <a href="#section-1.6">Section 1.6</a> when the requested response type is "code", or when
   the redirection request will result in the transmission of sensitive
   credentials over an open network.  If TLS is not available, the
   authorization server <em>SHOULD</em> warn the resource owner about the
   insecure endpoint prior to redirection (e.g., display a message
   during the authorization request).

   Lack of transport-layer security can have a severe impact on the
   security of the client and the protected resources it is authorized
   to access.  The use of transport-layer security is particularly
   critical when the authorization process is used as a form of
   delegated end-user authentication by the client (e.g., third-party
   sign-in service).

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.2.2.%20%20Registration%20Requirements"></a></body></html><a class="selflink" href="#section-3.1.2.2" id="section-3.1.2.2">3.1.2.2</a>.  Registration Requirements</span>

   The authorization server <em>MUST</em> require all clients to register one or
   more complete redirect URIs prior to utilizing the authorization
   endpoint.  The client <em>MAY</em> use the "state" request parameter to
   achieve per-request customization if needed.

   The authorization server <em>MAY</em> allow the client to register multiple
   redirect URIs.

   Lack of requiring registration of redirect URIs enables an attacker
   to use the authorization endpoint as an open redirector as described
   in <a href="#section-9.18">Section 9.18</a>.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.2.3.%20%20Dynamic%20Configuration"></a></body></html><a class="selflink" href="#section-3.1.2.3" id="section-3.1.2.3">3.1.2.3</a>.  Dynamic Configuration</span>

   If multiple redirect URIs have been registered the client <em>MUST</em>
   include a redirect URI with the authorization request using the
   "redirect_uri" request parameter.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.2.4.%20%20Invalid%20Endpoint"></a></body></html><a class="selflink" href="#section-3.1.2.4" id="section-3.1.2.4">3.1.2.4</a>.  Invalid Endpoint</span>

   If an authorization request fails validation due to a missing,
   invalid, or mismatching redirect URI, the authorization server <em>SHOULD</em>
   inform the resource owner of the error and <em>MUST NOT</em> automatically
   redirect the user-agent to the invalid redirect URI.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.1.2.5.%20%20Endpoint%20Content"></a></body></html><a class="selflink" href="#section-3.1.2.5" id="section-3.1.2.5">3.1.2.5</a>.  Endpoint Content</span>

   The redirection request to the client's endpoint typically results in
   an HTML document response, processed by the user-agent.  If the HTML
   response is served directly as the result of the redirection request,
   any script included in the HTML document will execute with full
   access to the redirect URI and the credentials (e.g. authorization
   code) it contains.

   The client <em>SHOULD NOT</em> include any third-party scripts (e.g., third-
   party analytics, social plug-ins, ad networks) in the redirection
   endpoint response.  Instead, it <em>SHOULD</em> extract the credentials from
   the URI and redirect the user-agent again to another endpoint without
   exposing the credentials (in the URI or elsewhere).  If third-party
   scripts are included, the client <em>MUST</em> ensure that its own scripts
   (used to extract and remove the credentials from the URI) will
   execute first.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.2.%20%20Token%20Endpoint"></a></body></html><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a>.  Token Endpoint</span>

   The token endpoint is used by the client to obtain an access token by
   presenting its authorization grant or refresh token.

   The means through which the client obtains the location of the token
   endpoint are beyond the scope of this specification, but the location
   is typically provided in the service documentation, or in the
   authorization server's metadata document ([<a href="/doc/html/rfc8414" title='"OAuth 2.0 Authorization Server Metadata"'>RFC8414</a>]).

   The endpoint URI <em>MAY</em> include an "application/x-www-form-urlencoded"
   formatted (per <a href="#appendix-B">Appendix B</a>) query component (<a href="/doc/html/rfc3986#section-3.4">[RFC3986] SectionÂ 3.4</a>),
   which <em>MUST</em> be retained when adding additional query parameters.  The
   endpoint URI <em>MUST NOT</em> include a fragment component.

   Since requests to the token endpoint result in the transmission of
   clear-text credentials (in the HTTP request and response), the
   authorization server <em>MUST</em> require the use of TLS as described in
   <a href="#section-1.6">Section 1.6</a> when sending requests to the token endpoint.

   The client <em>MUST</em> use the HTTP "POST" method when making access token
   requests.

   Parameters sent without a value <em>MUST</em> be treated as if they were
   omitted from the request.  The authorization server <em>MUST</em> ignore
   unrecognized request parameters.  Request and response parameters
   defined by this specification <em>MUST NOT</em> be included more than once.






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.2.1.%20%20Client%20Authentication"></a></body></html><a class="selflink" href="#section-3.2.1" id="section-3.2.1">3.2.1</a>.  Client Authentication</span>

   Confidential or credentialed clients client <em>MUST</em> authenticate with
   the authorization server as described in <a href="#section-2.3">Section 2.3</a> when making
   requests to the token endpoint.  Client authentication is used for:

   *  Enforcing the binding of refresh tokens and authorization codes to
      the client they were issued to.  Client authentication is critical
      when an authorization code is transmitted to the redirection
      endpoint over an insecure channel.

   *  Recovering from a compromised client by disabling the client or
      changing its credentials, thus preventing an attacker from abusing
      stolen refresh tokens.  Changing a single set of client
      credentials is significantly faster than revoking an entire set of
      refresh tokens.

   *  Implementing authentication management best practices, which
      require periodic credential rotation.  Rotation of an entire set
      of refresh tokens can be challenging, while rotation of a single
      set of client credentials is significantly easier.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/3.3.%20%20Access%20Token%20Scope"></a></body></html><a class="selflink" href="#section-3.3" id="section-3.3">3.3</a>.  Access Token Scope</span>

   The authorization and token endpoints allow the client to specify the
   scope of the access request using the "scope" request parameter.  In
   turn, the authorization server uses the "scope" response parameter to
   inform the client of the scope of the access token issued.

   The value of the scope parameter is expressed as a list of space-
   delimited, case-sensitive strings.  The strings are defined by the
   authorization server.  If the value contains multiple space-delimited
   strings, their order does not matter, and each string adds an
   additional access range to the requested scope.

       scope       = scope-token *( SP scope-token )
       scope-token = 1*( %x21 / %x23-5B / %x5D-7E )

   The authorization server <em>MAY</em> fully or partially ignore the scope
   requested by the client, based on the authorization server policy or
   the resource owner's instructions.  If the issued access token scope
   is different from the one requested by the client, the authorization
   server <em>MUST</em> include the "scope" response parameter to inform the
   client of the actual scope granted.







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   If the client omits the scope parameter when requesting
   authorization, the authorization server <em>MUST</em> either process the
   request using a pre-defined default value or fail the request
   indicating an invalid scope.  The authorization server <em>SHOULD</em>
   document its scope requirements and default value (if defined).

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.%20%20Obtaining%20Authorization"></a></body></html><a class="selflink" href="#section-4" id="section-4">4</a>.  Obtaining Authorization</span>

   To request an access token, the client obtains authorization from the
   resource owner.  The authorization is expressed in the form of an
   authorization grant, which the client uses to request the access
   token.  OAuth defines two grant types: authorization code and client
   credentials.  It also provides an extension mechanism for defining
   additional grant types.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.%20%20Authorization%20Code%20Grant"></a></body></html><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  Authorization Code Grant</span>

   The authorization code grant type is used to obtain both access
   tokens and refresh tokens.

   Since this is a redirect-based flow, the client must be capable of
   interacting with the resource owner's user-agent (typically a web
   browser) and capable of receiving incoming requests (via redirection)
   from the authorization server.



























<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   +----------+
   | Resource |
   |   Owner  |
   |          |
   +----------+
        ^
        |
       (2)
   +----|-----+          Client Identifier      +---------------+
   |         -+----(1)-- &amp; Redirect URI    ----&gt;|               |
   |  User-   |                                 | Authorization |
   |  Agent  -+----(2)-- User authenticates ---&gt;|     Server    |
   |          |                                 |               |
   |         -+----(3)-- Authorization Code ---&lt;|               |
   +-|----|---+                                 +---------------+
     |    |                                         ^      v
    (1)  (3)                                        |      |
     |    |                                         |      |
     ^    v                                         |      |
   +---------+                                      |      |
   |         |&gt;---(4)-- Authorization Code ---------'      |
   |  Client |          &amp; Redirect URI                     |
   |         |                                             |
   |         |&lt;---(5)----- Access Token -------------------'
   +---------+       (w/ Optional Refresh Token)

   Note: The lines illustrating steps (1), (2), and (3) are broken into
   two parts as they pass through the user-agent.

                     Figure 3: Authorization Code Flow

   The flow illustrated in Figure 3 includes the following steps:

   (1) The client initiates the flow by directing the resource owner's
   user-agent to the authorization endpoint.  The client includes its
   client identifier, code challenge (derived from a generated code
   verifier), optional requested scope, optional local state, and a
   redirect URI to which the authorization server will send the user-
   agent back once access is granted (or denied).

   (2) The authorization server authenticates the resource owner (via
   the user-agent) and establishes whether the resource owner grants or
   denies the client's access request.








<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   (3) Assuming the resource owner grants access, the authorization
   server redirects the user-agent back to the client using the redirect
   URI provided earlier (in the request or during client registration).
   The redirect URI includes an authorization code and any local state
   provided by the client earlier.

   (4) The client requests an access token from the authorization
   server's token endpoint by including the authorization code received
   in the previous step, and including its code verifier.  When making
   the request, the client authenticates with the authorization server
   if it can.  The client includes the redirect URI used to obtain the
   authorization code for verification.

   (5) The authorization server authenticates the client when possible,
   validates the authorization code, validates the code verifier, and
   ensures that the redirect URI received matches the URI used to
   redirect the client in step (3).  If valid, the authorization server
   responds back with an access token and, optionally, a refresh token.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.1.%20%20Authorization%20Request"></a></body></html><a class="selflink" href="#section-4.1.1" id="section-4.1.1">4.1.1</a>.  Authorization Request</span>

   To begin the authorization request, the client builds the
   authorization request URI by adding parameters to the authorization
   server's authorization endpoint URI.

   Clients use a unique secret per authorization request to protect
   against code injection and CSRF attacks.  The client first generates
   this secret, which it can later use along with the authorization code
   to prove that the application using the authorization code is the
   same application that requested it.  The properties "code_challenge"
   and "code_verifier" are adopted from the OAuth 2.0 extension known as
   "Proof-Key for Code Exchange", or PKCE ([<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>]) where this
   technique was originally developed.

   Clients <em>MUST</em> use "code_challenge" and "code_verifier" and
   authorization servers <em>MUST</em> enforce their use except under the
   conditions described in <a href="#section-9.8">Section 9.8</a>.  In this case, using and
   enforcing "code_challenge" and "code_verifier" as described in the
   following is still <em>RECOMMENDED</em>.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.1.1.%20%20Client%20Creates%20a%20Code%20Verifier"></a></body></html><a class="selflink" href="#section-4.1.1.1" id="section-4.1.1.1">4.1.1.1</a>.  Client Creates a Code Verifier</span>

   The client first creates a code verifier, "code_verifier", for each
   Authorization Request, in the following manner:







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


 code_verifier = high-entropy cryptographic random STRING using the
 unreserved characters `[A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~"`
 from <a href="#section-2.3">Section 2.3</a> of {{<a href="/doc/html/rfc3986">RFC3986</a>}}, with a minimum length of 43 characters
 and a maximum length of 128 characters.

   ABNF for "code_verifier" is as follows.

   code-verifier = 43*128unreserved
   unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
   ALPHA = %x41-5A / %x61-7A
   DIGIT = %x30-39

   NOTE: The code verifier <em>SHOULD</em> have enough entropy to make it
   impractical to guess the value.  It is <em>RECOMMENDED</em> that the output of
   a suitable random number generator be used to create a 32-octet
   sequence.  The octet sequence is then base64url-encoded to produce a
   43-octet URL-safe string to use as the code verifier.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.1.2.%20%20Client%20Creates%20the%20Code%20Challenge"></a></body></html><a class="selflink" href="#section-4.1.1.2" id="section-4.1.1.2">4.1.1.2</a>.  Client Creates the Code Challenge</span>

   The client then creates a code challenge derived from the code
   verifier by using one of the following transformations on the code
   verifier:

   plain
     code_challenge = code_verifier

   S256
     code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))

   If the client is capable of using "S256", it <em>MUST</em> use "S256", as
   "S256" is Mandatory To Implement (MTI) on the server.  Clients are
   permitted to use "plain" only if they cannot support "S256" for some
   technical reason and know via out-of-band configuration or via
   Authorization Server Metadata ([<a href="/doc/html/rfc8414" title='"OAuth 2.0 Authorization Server Metadata"'>RFC8414</a>]) that the server supports
   "plain".

   The plain transformation is for compatibility with existing
   deployments and for constrained environments that can't use the
   "S256" transformation.

   ABNF for "code_challenge" is as follows.

   code-challenge = 43*128unreserved
   unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
   ALPHA = %x41-5A / %x61-7A
   DIGIT = %x30-39




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.1.3.%20%20Client%20Initiates%20the%20Authorization%20Request"></a></body></html><a class="selflink" href="#section-4.1.1.3" id="section-4.1.1.3">4.1.1.3</a>.  Client Initiates the Authorization Request</span>

   The client constructs the request URI by adding the following
   parameters to the query component of the authorization endpoint URI
   using the "application/x-www-form-urlencoded" format, per <a href="#appendix-B">Appendix B</a>:

   "response_type":  <em>REQUIRED</em>.  Value <em>MUST</em> be set to "code".

   "client_id":  <em>REQUIRED</em>.  The client identifier as described in
      <a href="#section-2.2">Section 2.2</a>.

   "code_challenge":  <em>REQUIRED</em> or <em>RECOMMENDED</em> (see <a href="#section-9.8">Section 9.8</a>).  Code
      challenge.

   "code_challenge_method":  <em>OPTIONAL</em>, defaults to "plain" if not
      present in the request.  Code verifier transformation method is
      "S256" or "plain".

   "redirect_uri":  <em>OPTIONAL</em>.  As described in <a href="#section-3.1.2">Section 3.1.2</a>.

   "scope":  <em>OPTIONAL</em>.  The scope of the access request as described by
      <a href="#section-3.3">Section 3.3</a>.

   "state":  <em>OPTIONAL</em>.  An opaque value used by the client to maintain
      state between the request and callback.  The authorization server
      includes this value when redirecting the user-agent back to the
      client.

   The client directs the resource owner to the constructed URI using an
   HTTP redirection response, or by other means available to it via the
   user-agent.

   For example, the client directs the user-agent to make the following
   HTTP request using TLS (with extra line breaks for display purposes
   only):

   GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
       &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
       &amp;code_challenge=6fdkQaPm51l13DSukcAH3Mdx7_ntecHYd1vi3n0hMZY
       &amp;code_challenge_method=S256 HTTP/1.1
   Host: server.example.com

   The authorization server validates the request to ensure that all
   required parameters are present and valid.  If the request is valid,
   the authorization server authenticates the resource owner and obtains
   an authorization decision (by asking the resource owner or by
   establishing approval via other means).




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   When a decision is established, the authorization server directs the
   user-agent to the provided client redirect URI using an HTTP
   redirection response, or by other means available to it via the user-
   agent.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.2.%20%20Authorization%20Response"></a></body></html><a class="selflink" href="#section-4.1.2" id="section-4.1.2">4.1.2</a>.  Authorization Response</span>

   If the resource owner grants the access request, the authorization
   server issues an authorization code and delivers it to the client by
   adding the following parameters to the query component of the
   redirect URI using the "application/x-www-form-urlencoded" format,
   per <a href="#appendix-B">Appendix B</a>:

   "code":  <em>REQUIRED</em>.  The authorization code generated by the
      authorization server.  The authorization code <em>MUST</em> expire shortly
      after it is issued to mitigate the risk of leaks.  A maximum
      authorization code lifetime of 10 minutes is <em>RECOMMENDED</em>.  The
      client <em>MUST NOT</em> use the authorization code more than once.  If an
      authorization code is used more than once, the authorization
      server <em>MUST</em> deny the request and <em>SHOULD</em> revoke (when possible) all
      tokens previously issued based on that authorization code.  The
      authorization code is bound to the client identifier and redirect
      URI.

   "state":  <em>REQUIRED</em> if the "state" parameter was present in the client
      authorization request.  The exact value received from the client.

   For example, the authorization server redirects the user-agent by
   sending the following HTTP response:

   HTTP/1.1 302 Found
   Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
             &amp;state=xyz

   The client <em>MUST</em> ignore unrecognized response parameters.  The
   authorization code string size is left undefined by this
   specification.  The client should avoid making assumptions about code
   value sizes.  The authorization server <em>SHOULD</em> document the size of
   any value it issues.

   When the server issues the authorization code in the authorization
   response, it <em>MUST</em> associate the "code_challenge" and
   "code_challenge_method" values with the authorization code so it can
   be verified later.







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   The "code_challenge" and "code_challenge_method" values may be stored
   in encrypted form in the "code" itself, but could alternatively be
   stored on the server associated with the code.  The server <em>MUST NOT</em>
   include the "code_challenge" value in client requests in a form that
   other entities can extract.

   The exact method that the server uses to associate the
   "code_challenge" with the issued "code" is out of scope for this
   specification.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.2.1.%20%20Error%20Response"></a></body></html><a class="selflink" href="#section-4.1.2.1" id="section-4.1.2.1">4.1.2.1</a>.  Error Response</span>

   If the request fails due to a missing, invalid, or mismatching
   redirect URI, or if the client identifier is missing or invalid, the
   authorization server <em>SHOULD</em> inform the resource owner of the error
   and <em>MUST NOT</em> automatically redirect the user-agent to the invalid
   redirect URI.

   An AS <em>MUST</em> reject requests without a "code_challenge" from public
   clients, and <em>MUST</em> reject such requests from other clients unless
   there is reasonable assurance that the client mitigates authorization
   code injection in other ways.  See <a href="#section-9.8">Section 9.8</a> for details.

   If the server does not support the requested "code_challenge_method"
   transformation, the authorization endpoint <em>MUST</em> return the
   authorization error response with "error" value set to
   "invalid_request".  The "error_description" or the response of
   "error_uri" <em>SHOULD</em> explain the nature of error, e.g., transform
   algorithm not supported.

   If the resource owner denies the access request or if the request
   fails for reasons other than a missing or invalid redirect URI, the
   authorization server informs the client by adding the following
   parameters to the query component of the redirect URI using the
   "application/x-www-form-urlencoded" format, per <a href="#appendix-B">Appendix B</a>:

   "error":  <em>REQUIRED</em>.  A single ASCII [<a href="#ref-USASCII" title='"Coded Character Set -- 7-bit American Standard Code for Information Interchange, ANSI X3.4"'>USASCII</a>] error code from the
      following:

      "invalid_request":  The request is missing a required parameter,
         includes an invalid parameter value, includes a parameter more
         than once, or is otherwise malformed.

      "unauthorized_client":  The client is not authorized to request an
         authorization code using this method.

      "access_denied":  The resource owner or authorization server
         denied the request.



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


      "unsupported_response_type":  The authorization server does not
         support obtaining an authorization code using this method.

      "invalid_scope":  The requested scope is invalid, unknown, or
         malformed.

      "server_error":  The authorization server encountered an
         unexpected condition that prevented it from fulfilling the
         request.  (This error code is needed because a 500 Internal
         Server Error HTTP status code cannot be returned to the client
         via an HTTP redirect.)

      "temporarily_unavailable":  The authorization server is currently
         unable to handle the request due to a temporary overloading or
         maintenance of the server.  (This error code is needed because
         a 503 Service Unavailable HTTP status code cannot be returned
         to the client via an HTTP redirect.)

      Values for the "error" parameter <em>MUST NOT</em> include characters
      outside the set %x20-21 / %x23-5B / %x5D-7E.

   "error_description":  <em>OPTIONAL</em>.  Human-readable ASCII [<a href="#ref-USASCII" title='"Coded Character Set -- 7-bit American Standard Code for Information Interchange, ANSI X3.4"'>USASCII</a>] text
      providing additional information, used to assist the client
      developer in understanding the error that occurred.  Values for
      the "error_description" parameter <em>MUST NOT</em> include characters
      outside the set %x20-21 / %x23-5B / %x5D-7E.

   "error_uri":  <em>OPTIONAL</em>.  A URI identifying a human-readable web page
      with information about the error, used to provide the client
      developer with additional information about the error.  Values for
      the "error_uri" parameter <em>MUST</em> conform to the URI-reference syntax
      and thus <em>MUST NOT</em> include characters outside the set %x21 /
      %x23-5B / %x5D-7E.

   "state":  <em>REQUIRED</em> if a "state" parameter was present in the client
      authorization request.  The exact value received from the client.

   For example, the authorization server redirects the user-agent by
   sending the following HTTP response:

   HTTP/1.1 302 Found
   Location: https://client.example.com/cb?error=access_denied&amp;state=xyz









<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.3.%20%20Access%20Token%20Request"></a></body></html><a class="selflink" href="#section-4.1.3" id="section-4.1.3">4.1.3</a>.  Access Token Request</span>

   The client makes a request to the token endpoint by sending the
   following parameters using the "application/x-www-form-urlencoded"
   format per <a href="#appendix-B">Appendix B</a> with a character encoding of UTF-8 in the HTTP
   request entity-body:

   "grant_type":  <em>REQUIRED</em>.  Value <em>MUST</em> be set to "authorization_code".

   "code":  <em>REQUIRED</em>.  The authorization code received from the
      authorization server.

   "redirect_uri":  <em>REQUIRED</em>, if the "redirect_uri" parameter was
      included in the authorization request as described in
      <a href="#section-4.1.1">Section 4.1.1</a>, and their values <em>MUST</em> be identical.

   "client_id":  <em>REQUIRED</em>, if the client is not authenticating with the
      authorization server as described in <a href="#section-3.2.1">Section 3.2.1</a>.

   "code_verifier":  <em>REQUIRED</em>, if the "code_challenge" parameter was
      included in the authorization request.  <em>MUST NOT</em> be used
      otherwise.  The original code verifier string.

   Confidential or credentialed clients <em>MUST</em> authenticate with the
   authorization server as described in <a href="#section-3.2.1">Section 3.2.1</a>.

   For example, the client makes the following HTTP request using TLS
   (with extra line breaks for display purposes only):

 POST /token HTTP/1.1
 Host: server.example.com
 Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
 Content-Type: application/x-www-form-urlencoded

 grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
 &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
 &amp;code_verifier=3641a2d12d66101249cdf7a79c000c1f8c05d2aafcf14bf146497bed

   The authorization server <em>MUST</em>:

   *  require client authentication for confidential and credentialed
      clients (or clients with other authentication requirements),

   *  authenticate the client if client authentication is included,

   *  ensure that the authorization code was issued to the authenticated
      confidential or credentialed client, or if the client is public,
      ensure that the code was issued to "client_id" in the request,



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   *  verify that the authorization code is valid,

   *  verify that the "code_verifier" parameter is present if and only
      if a "code_challenge" parameter was present in the authorization
      request,

   *  if a "code_verifier" is present, verify the "code_verifier" by
      calculating the code challenge from the received "code_verifier"
      and comparing it with the previously associated "code_challenge",
      after first transforming it according to the
      "code_challenge_method" method specified by the client, and

   *  ensure that the "redirect_uri" parameter is present if the
      "redirect_uri" parameter was included in the initial authorization
      request as described in <a href="#section-4.1.1.3">Section 4.1.1.3</a>, and if included ensure
      that their values are identical.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.1.4.%20%20Access%20Token%20Response"></a></body></html><a class="selflink" href="#section-4.1.4" id="section-4.1.4">4.1.4</a>.  Access Token Response</span>

   If the access token request is valid and authorized, the
   authorization server issues an access token and optional refresh
   token as described in <a href="#section-5.1">Section 5.1</a>.  If the request client
   authentication failed or is invalid, the authorization server returns
   an error response as described in <a href="#section-5.2">Section 5.2</a>.

   An example successful response:

   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store
   Pragma: no-cache

   {
     "access_token": "2YotnFZFEjr1zCsicMWpAA",
     "token_type": "Bearer",
     "expires_in": 3600,
     "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA",
     "example_parameter": "example_value"
   }

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.2.%20%20Client%20Credentials%20Grant"></a></body></html><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  Client Credentials Grant</span>

   The client can request an access token using only its client
   credentials (or other supported means of authentication) when the
   client is requesting access to the protected resources under its
   control, or those of another resource owner that have been previously
   arranged with the authorization server (the method of which is beyond
   the scope of this specification).



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 31]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   The client credentials grant type <em>MUST</em> only be used by confidential
   or credentialed clients.

        +---------+                                  +---------------+
        |         |                                  |               |
        |         |&gt;--(1)- Client Authentication ---&gt;| Authorization |
        | Client  |                                  |     Server    |
        |         |&lt;--(2)---- Access Token ---------&lt;|               |
        |         |                                  |               |
        +---------+                                  +---------------+

                     Figure 4: Client Credentials Flow

   The flow illustrated in Figure 4 includes the following steps:

   (1) The client authenticates with the authorization server and
   requests an access token from the token endpoint.

   (2) The authorization server authenticates the client, and if valid,
   issues an access token.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.2.1.%20%20Authorization%20Request%20and%20Response"></a></body></html><a class="selflink" href="#section-4.2.1" id="section-4.2.1">4.2.1</a>.  Authorization Request and Response</span>

   Since the client authentication is used as the authorization grant,
   no additional authorization request is needed.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.2.2.%20%20Access%20Token%20Request"></a></body></html><a class="selflink" href="#section-4.2.2" id="section-4.2.2">4.2.2</a>.  Access Token Request</span>

   The client makes a request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format per <a href="#appendix-B">Appendix B</a> with a character encoding of UTF-8 in the HTTP
   request entity-body:

   "grant_type":  <em>REQUIRED</em>.  Value <em>MUST</em> be set to "client_credentials".

   "scope":  <em>OPTIONAL</em>.  The scope of the access request as described by
      <a href="#section-3.3">Section 3.3</a>.

   The client <em>MUST</em> authenticate with the authorization server as
   described in <a href="#section-3.2.1">Section 3.2.1</a>.

   For example, the client makes the following HTTP request using
   transport-layer security (with extra line breaks for display purposes
   only):







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 32]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   POST /token HTTP/1.1
   Host: server.example.com
   Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
   Content-Type: application/x-www-form-urlencoded

   grant_type=client_credentials

   The authorization server <em>MUST</em> authenticate the client.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.2.3.%20%20Access%20Token%20Response"></a></body></html><a class="selflink" href="#section-4.2.3" id="section-4.2.3">4.2.3</a>.  Access Token Response</span>

   If the access token request is valid and authorized, the
   authorization server issues an access token as described in
   <a href="#section-5.1">Section 5.1</a>.  A refresh token <em>SHOULD NOT</em> be included.  If the request
   failed client authentication or is invalid, the authorization server
   returns an error response as described in <a href="#section-5.2">Section 5.2</a>.

   An example successful response:

   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store
   Pragma: no-cache

   {
     "access_token": "2YotnFZFEjr1zCsicMWpAA",
     "token_type": "Bearer",
     "expires_in": 3600,
     "example_parameter": "example_value"
   }

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/4.3.%20%20Extension%20Grants"></a></body></html><a class="selflink" href="#section-4.3" id="section-4.3">4.3</a>.  Extension Grants</span>

   The client uses an extension grant type by specifying the grant type
   using an absolute URI (defined by the authorization server) as the
   value of the "grant_type" parameter of the token endpoint, and by
   adding any additional parameters necessary.

   For example, to request an access token using the Device
   Authorization Grant as defined by [<a href="/doc/html/rfc8628" title='"OAuth 2.0 Device Authorization Grant"'>RFC8628</a>] after the user has
   authorized the client on a separate device, the client makes the
   following HTTP request using TLS (with extra line breaks for display
   purposes only):








<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 33]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code
     &amp;device_code=GmRhmhcxhwEzkoEqiMEg_DnyEysNkuNhszIySk9eS
     &amp;client_id=C409020731

   If the access token request is valid and authorized, the
   authorization server issues an access token and optional refresh
   token as described in <a href="#section-5.1">Section 5.1</a>.  If the request failed client
   authentication or is invalid, the authorization server returns an
   error response as described in <a href="#section-5.2">Section 5.2</a>.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/5.%20%20Issuing%20an%20Access%20Token"></a></body></html><a class="selflink" href="#section-5" id="section-5">5</a>.  Issuing an Access Token</span>

   If the access token request is valid and authorized, the
   authorization server issues an access token and optional refresh
   token as described in <a href="#section-5.1">Section 5.1</a>.  If the request failed client
   authentication or is invalid, the authorization server returns an
   error response as described in <a href="#section-5.2">Section 5.2</a>.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/5.1.%20%20Successful%20Response"></a></body></html><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  Successful Response</span>

   The authorization server issues an access token and optional refresh
   token, and constructs the response by adding the following parameters
   to the entity-body of the HTTP response with a 200 (OK) status code:

   "access_token":  <em>REQUIRED</em>.  The access token issued by the
      authorization server.

   "token_type":  <em>REQUIRED</em>.  The type of the token issued as described
      in <a href="#section-7.1">Section 7.1</a>.  Value is case insensitive.

   "expires_in":  <em>RECOMMENDED</em>.  The lifetime in seconds of the access
      token.  For example, the value "3600" denotes that the access
      token will expire in one hour from the time the response was
      generated.  If omitted, the authorization server <em>SHOULD</em> provide
      the expiration time via other means or document the default value.

   "refresh_token":  <em>OPTIONAL</em>.  The refresh token, which can be used to
      obtain new access tokens using the same authorization grant as
      described in <a href="#section-6">Section 6</a>.

   "scope":  <em>OPTIONAL</em>, if identical to the scope requested by the
      client; otherwise, <em>REQUIRED</em>.  The scope of the access token as
      described by <a href="#section-3.3">Section 3.3</a>.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 34]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   The parameters are included in the entity-body of the HTTP response
   using the "application/json" media type as defined by [<a href="/doc/html/rfc7159" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC7159</a>].  The
   parameters are serialized into a JavaScript Object Notation (JSON)
   structure by adding each parameter at the highest structure level.
   Parameter names and string values are included as JSON strings.
   Numerical values are included as JSON numbers.  The order of
   parameters does not matter and can vary.

   The authorization server <em>MUST</em> include the HTTP "Cache-Control"
   response header field [<a href="/doc/html/rfc7234" title='"Hypertext Transfer Protocol (HTTP/1.1): Caching"'>RFC7234</a>] with a value of "no-store" in any
   response containing tokens, credentials, or other sensitive
   information, as well as the "Pragma" response header field [<a href="/doc/html/rfc7234" title='"Hypertext Transfer Protocol (HTTP/1.1): Caching"'>RFC7234</a>]
   with a value of "no-cache".

   For example:

   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store
   Pragma: no-cache

   {
     "access_token":"2YotnFZFEjr1zCsicMWpAA",
     "token_type":"Bearer",
     "expires_in":3600,
     "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
     "example_parameter":"example_value"
   }

   The client <em>MUST</em> ignore unrecognized value names in the response.  The
   sizes of tokens and other values received from the authorization
   server are left undefined.  The client should avoid making
   assumptions about value sizes.  The authorization server <em>SHOULD</em>
   document the size of any value it issues.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/5.2.%20%20Error%20Response"></a></body></html><a class="selflink" href="#section-5.2" id="section-5.2">5.2</a>.  Error Response</span>

   The authorization server responds with an HTTP 400 (Bad Request)
   status code (unless specified otherwise) and includes the following
   parameters with the response:

   "error":  <em>REQUIRED</em>.  A single ASCII [<a href="#ref-USASCII" title='"Coded Character Set -- 7-bit American Standard Code for Information Interchange, ANSI X3.4"'>USASCII</a>] error code from the
      following:

      "invalid_request":  The request is missing a required parameter,






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 35]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


         includes an unsupported parameter value (other than grant
         type), repeats a parameter, includes multiple credentials,
         utilizes more than one mechanism for authenticating the client,
         contains a "code_verifier" although no "code_challenge" was
         sent in the authorization request, or is otherwise malformed.

      "invalid_client":  Client authentication failed (e.g., unknown
         client, no client authentication included, or unsupported
         authentication method).  The authorization server <em>MAY</em> return an
         HTTP 401 (Unauthorized) status code to indicate which HTTP
         authentication schemes are supported.  If the client attempted
         to authenticate via the "Authorization" request header field,
         the authorization server <em>MUST</em> respond with an HTTP 401
         (Unauthorized) status code and include the "WWW-Authenticate"
         response header field matching the authentication scheme used
         by the client.

      "invalid_grant":  The provided authorization grant (e.g.,
         authorization code, resource owner credentials) or refresh
         token is invalid, expired, revoked, does not match the redirect
         URI used in the authorization request, or was issued to another
         client.

      "unauthorized_client":  The authenticated client is not authorized
         to use this authorization grant type.

      "unsupported_grant_type":  The authorization grant type is not
         supported by the authorization server.

      "invalid_scope":  The requested scope is invalid, unknown,
         malformed, or exceeds the scope granted by the resource owner.

      Values for the "error" parameter <em>MUST NOT</em> include characters
      outside the set %x20-21 / %x23-5B / %x5D-7E.

   "error_description":  <em>OPTIONAL</em>.  Human-readable ASCII [<a href="#ref-USASCII" title='"Coded Character Set -- 7-bit American Standard Code for Information Interchange, ANSI X3.4"'>USASCII</a>] text
      providing additional information, used to assist the client
      developer in understanding the error that occurred.  Values for
      the "error_description" parameter <em>MUST NOT</em> include characters
      outside the set %x20-21 / %x23-5B / %x5D-7E.

   "error_uri":  <em>OPTIONAL</em>.  A URI identifying a human-readable web page
      with information about the error, used to provide the client
      developer with additional information about the error.  Values for
      the "error_uri" parameter <em>MUST</em> conform to the URI-reference syntax
      and thus <em>MUST NOT</em> include characters outside the set %x21 /
      %x23-5B / %x5D-7E.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 36]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   The parameters are included in the entity-body of the HTTP response
   using the "application/json" media type as defined by [<a href="/doc/html/rfc7159" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC7159</a>].  The
   parameters are serialized into a JSON structure by adding each
   parameter at the highest structure level.  Parameter names and string
   values are included as JSON strings.  Numerical values are included
   as JSON numbers.  The order of parameters does not matter and can
   vary.

   For example:

   HTTP/1.1 400 Bad Request
   Content-Type: application/json
   Cache-Control: no-store
   Pragma: no-cache

   {
    "error":"invalid_request"
   }

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/6.%20%20Refreshing%20an%20Access%20Token"></a></body></html><a class="selflink" href="#section-6" id="section-6">6</a>.  Refreshing an Access Token</span>

   Authorization servers <em>SHOULD</em> determine, based on a risk assessment,
   whether to issue refresh tokens to a certain client.  If the
   authorization server decides not to issue refresh tokens, the client
   <em>MAY</em> refresh access tokens by utilizing other grant types, such as the
   authorization code grant type.  In such a case, the authorization
   server may utilize cookies and persistent grants to optimize the user
   experience.

   If refresh tokens are issued, those refresh tokens <em>MUST</em> be bound to
   the scope and resource servers as consented by the resource owner.
   This is to prevent privilege escalation by the legitimate client and
   reduce the impact of refresh token leakage.

   If the authorization server issued a refresh token to the client, the
   client makes a refresh request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format per <a href="#appendix-B">Appendix B</a> with a character encoding of UTF-8 in the HTTP
   request entity-body:

   "grant_type":  <em>REQUIRED</em>.  Value <em>MUST</em> be set to "refresh_token".

   "refresh_token":  <em>REQUIRED</em>.  The refresh token issued to the client.

   "scope":  <em>OPTIONAL</em>.  The scope of the access request as described by






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 37]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


      <a href="#section-3.3">Section 3.3</a>.  The requested scope <em>MUST NOT</em> include any scope not
      originally granted by the resource owner, and if omitted is
      treated as equal to the scope originally granted by the resource
      owner.

   Because refresh tokens are typically long-lasting credentials used to
   request additional access tokens, the refresh token is bound to the
   client to which it was issued.  Confidential or credentialed clients
   <em>MUST</em> authenticate with the authorization server as described in
   <a href="#section-3.2.1">Section 3.2.1</a>.

   For example, the client makes the following HTTP request using
   transport-layer security (with extra line breaks for display purposes
   only):

   POST /token HTTP/1.1
   Host: server.example.com
   Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
   Content-Type: application/x-www-form-urlencoded

   grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA

   The authorization server <em>MUST</em>:

   *  require client authentication for confidential or credentialed
      clients

   *  authenticate the client if client authentication is included and
      ensure that the refresh token was issued to the authenticated
      client, and

   *  validate the refresh token.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/6.1.%20%20Refresh%20Token%20Protection"></a></body></html><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Refresh Token Protection</span>

   Authorization servers <em>SHOULD</em> utilize one of these methods to detect
   refresh token replay by malicious actors for public clients:

   *  _Sender-constrained refresh tokens:_ the authorization server
      cryptographically binds the refresh token to a certain client
      instance by utilizing [<a href="#ref-I-D.ietf-oauth-token-binding">I-D.ietf-oauth-token-binding</a>], [<a href="/doc/html/rfc8705" title='"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"'>RFC8705</a>],
      [<a href="#ref-I-D.ietf-oauth-dpop">I-D.ietf-oauth-dpop</a>], or another suitable method.

   *  _Refresh token rotation:_ the authorization server issues a new
      refresh token with every access token refresh response.  The
      previous refresh token is invalidated but information about the
      relationship is retained by the authorization server.  If a
      refresh token is compromised and subsequently used by both the



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 38]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


      attacker and the legitimate client, one of them will present an
      invalidated refresh token, which will inform the authorization
      server of the breach.  The authorization server cannot determine
      which party submitted the invalid refresh token, but it will
      revoke the active refresh token.  This stops the attack at the
      cost of forcing the legitimate client to obtain a fresh
      authorization grant.

   Implementation note: the grant to which a refresh token belongs may
   be encoded into the refresh token itself.  This can enable an
   authorization server to efficiently determine the grant to which a
   refresh token belongs, and by extension, all refresh tokens that need
   to be revoked.  Authorization servers <em>MUST</em> ensure the integrity of
   the refresh token value in this case, for example, using signatures.

   If valid and authorized, the authorization server issues an access
   token as described in <a href="#section-5.1">Section 5.1</a>.  If the request failed
   verification or is invalid, the authorization server returns an error
   response as described in <a href="#section-5.2">Section 5.2</a>.

   The authorization server <em>MAY</em> issue a new refresh token, in which case
   the client <em>MUST</em> discard the old refresh token and replace it with the
   new refresh token.  The authorization server <em>MAY</em> revoke the old
   refresh token after issuing a new refresh token to the client.  If a
   new refresh token is issued, the refresh token scope <em>MUST</em> be
   identical to that of the refresh token included by the client in the
   request.

   Authorization servers <em>MAY</em> revoke refresh tokens automatically in case
   of a security event, such as:

   *  password change

   *  logout at the authorization server

   Refresh tokens <em>SHOULD</em> expire if the client has been inactive for some
   time, i.e., the refresh token has not been used to obtain fresh
   access tokens for some time.  The expiration time is at the
   discretion of the authorization server.  It might be a global value
   or determined based on the client policy or the grant associated with
   the refresh token (and its sensitivity).










<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 39]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.%20%20Accessing%20Protected%20Resources"></a></body></html><a class="selflink" href="#section-7" id="section-7">7</a>.  Accessing Protected Resources</span>

   The client accesses protected resources by presenting the access
   token to the resource server.  The resource server <em>MUST</em> validate the
   access token and ensure that it has not expired and that its scope
   covers the requested resource.  The methods used by the resource
   server to validate the access token (as well as any error responses)
   are beyond the scope of this specification, but generally involve an
   interaction or coordination between the resource server and the
   authorization server, such as using Token Introspection [<a href="/doc/html/rfc7662" title='"OAuth 2.0 Token Introspection"'>RFC7662</a>] or
   a structured access token format such as a JWT
   [<a href="#ref-I-D.ietf-oauth-access-token-jwt">I-D.ietf-oauth-access-token-jwt</a>].

   The method in which the client utilizes the access token to
   authenticate with the resource server depends on the type of access
   token issued by the authorization server.  Typically, it involves
   using the HTTP "Authorization" request header field [<a href="/doc/html/rfc2617" title='"HTTP Authentication: Basic and Digest Access Authentication"'>RFC2617</a>] with an
   authentication scheme defined by the specification of the access
   token type used, such as "Bearer", defined below.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.1.%20%20Access%20Token%20Types"></a></body></html><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a>.  Access Token Types</span>

   The access token type provides the client with the information
   required to successfully utilize the access token to make a protected
   resource request (along with type-specific attributes).  The client
   <em>MUST NOT</em> use an access token if it does not understand the token
   type.

   For example, the "Bearer" token type defined in this specification is
   utilized by simply including the access token string in the request:

   GET /resource/1 HTTP/1.1
   Host: example.com
   Authorization: Bearer mF_9.B5f-4.1JqM

   The above example is provided for illustration purposes only.

   Each access token type definition specifies the additional attributes
   (if any) sent to the client together with the "access_token" response
   parameter.  It also defines the HTTP authentication method used to
   include the access token when making a protected resource request.










<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 40]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-41"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.%20%20Bearer%20Tokens"></a></body></html><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a>.  Bearer Tokens</span>

   A Bearer Token is a security token with the property that any party
   in possession of the token (a "bearer") can use the token in any way
   that any other party in possession of it can.  Using a bearer token
   does not require a bearer to prove possession of cryptographic key
   material (proof-of-possession).

   Bearer tokens may be extended to include proof-of-possession
   techniques by other specifications.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.1.%20%20Authenticated%20Requests"></a></body></html><a class="selflink" href="#section-7.2.1" id="section-7.2.1">7.2.1</a>.  Authenticated Requests</span>

   This section defines two methods of sending Bearer tokens in resource
   requests to resource servers.  Clients <em>MUST NOT</em> use more than one
   method to transmit the token in each request.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.1.1.%20%20Authorization%20Request%20Header%20Field"></a></body></html><a class="selflink" href="#section-7.2.1.1" id="section-7.2.1.1">7.2.1.1</a>.  Authorization Request Header Field</span>

   When sending the access token in the "Authorization" request header
   field defined by HTTP/1.1 [<a href="/doc/html/rfc2617" title='"HTTP Authentication: Basic and Digest Access Authentication"'>RFC2617</a>], the client uses the "Bearer"
   authentication scheme to transmit the access token.

   For example:

    GET /resource HTTP/1.1
    Host: server.example.com
    Authorization: Bearer mF_9.B5f-4.1JqM

   The syntax of the "Authorization" header field for this scheme
   follows the usage of the Basic scheme defined in <a href="/doc/html/rfc2617#section-2">SectionÂ 2 of
   [RFC2617]</a>.  Note that, as with Basic, it does not conform to the
   generic syntax defined in <a href="/doc/html/rfc2617#section-1.2">SectionÂ 1.2 of [RFC2617]</a> but is compatible
   with the general authentication framework in HTTP 1.1 Authentication
   [<a href="/doc/html/rfc7235" title='"Hypertext Transfer Protocol (HTTP/1.1): Authentication"'>RFC7235</a>], although it does not follow the preferred practice
   outlined therein in order to reflect existing deployments.  The
   syntax for Bearer credentials is as follows:

   b64token    = 1*( ALPHA / DIGIT /
                    "-" / "." / "_" / "~" / "+" / "/" ) *"="
   credentials = "Bearer" 1*SP b64token

   Clients <em>SHOULD</em> make authenticated requests with a bearer token using
   the "Authorization" request header field with the "Bearer" HTTP
   authorization scheme.  Resource servers <em>MUST</em> support this method.






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 41]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-42"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.1.2.%20%20Form-Encoded%20Body%20Parameter"></a></body></html><a class="selflink" href="#section-7.2.1.2" id="section-7.2.1.2">7.2.1.2</a>.  Form-Encoded Body Parameter</span>

   When sending the access token in the HTTP request entity-body, the
   client adds the access token to the request-body using the
   "access_token" parameter.  The client <em>MUST NOT</em> use this method unless
   all of the following conditions are met:

   *  The HTTP request entity-header includes the "Content-Type" header
      field set to "application/x-www-form-urlencoded".

   *  The entity-body follows the encoding requirements of the
      "application/x-www-form-urlencoded" content-type as defined by
      HTML 4.01 [<a href="#ref-W3C.REC-html401-19991224">W3C.REC-html401-19991224</a>].

   *  The HTTP request entity-body is single-part.

   *  The content to be encoded in the entity-body <em>MUST</em> consist entirely
      of ASCII [<a href="#ref-USASCII" title='"Coded Character Set -- 7-bit American Standard Code for Information Interchange, ANSI X3.4"'>USASCII</a>] characters.

   *  The HTTP request method is one for which the request-body has
      defined semantics.  In particular, this means that the "GET"
      method <em>MUST NOT</em> be used.

   The entity-body <em>MAY</em> include other request-specific parameters, in
   which case the "access_token" parameter <em>MUST</em> be properly separated
   from the request-specific parameters using "&amp;" character(s) (ASCII
   code 38).

   For example, the client makes the following HTTP request using
   transport-layer security:

   POST /resource HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   access_token=mF_9.B5f-4.1JqM

   The "application/x-www-form-urlencoded" method <em>SHOULD NOT</em> be used
   except in application contexts where participating clients do not
   have access to the "Authorization" request header field.  Resource
   servers <em>MAY</em> support this method.










<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 42]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-43"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.2.%20%20The%20WWW-Authenticate%20Response%20Header%20Field"></a></body></html><a class="selflink" href="#section-7.2.2" id="section-7.2.2">7.2.2</a>.  The WWW-Authenticate Response Header Field</span>

   If the protected resource request does not include authentication
   credentials or does not contain an access token that enables access
   to the protected resource, the resource server <em>MUST</em> include the HTTP
   "WWW-Authenticate" response header field; it <em>MAY</em> include it in
   response to other conditions as well.  The "WWW-Authenticate" header
   field uses the framework defined by HTTP/1.1 [<a href="/doc/html/rfc2617" title='"HTTP Authentication: Basic and Digest Access Authentication"'>RFC2617</a>].

   All challenges defined by this specification <em>MUST</em> use the auth-scheme
   value "Bearer".  This scheme <em>MUST</em> be followed by one or more auth-
   param values.  The auth-param attributes used or defined by this
   specification are as follows.  Other auth-param attributes <em>MAY</em> be
   used as well.

   A "realm" attribute <em>MAY</em> be included to indicate the scope of
   protection in the manner described in HTTP/1.1 [<a href="/doc/html/rfc2617" title='"HTTP Authentication: Basic and Digest Access Authentication"'>RFC2617</a>].  The
   "realm" attribute <em>MUST NOT</em> appear more than once.

   The "scope" attribute is defined in <a href="#section-3.3">Section 3.3</a>.  The "scope"
   attribute is a space-delimited list of case-sensitive scope values
   indicating the required scope of the access token for accessing the
   requested resource. "scope" values are implementation defined; there
   is no centralized registry for them; allowed values are defined by
   the authorization server.  The order of "scope" values is not
   significant.  In some cases, the "scope" value will be used when
   requesting a new access token with sufficient scope of access to
   utilize the protected resource.  Use of the "scope" attribute is
   <em>OPTIONAL</em>.  The "scope" attribute <em>MUST NOT</em> appear more than once.  The
   "scope" value is intended for programmatic use and is not meant to be
   displayed to end-users.

   Two example scope values follow; these are taken from the OpenID
   Connect [<a href="#ref-OpenID.Messages">OpenID.Messages</a>] and the Open Authentication Technology
   Committee (OATC) Online Multimedia Authorization Protocol [<a href="#ref-OMAP" title='"Online Multimedia Authorization Protocol: An Industry Standard for Authorized Access to Internet Multimedia Resources"'>OMAP</a>]
   OAuth 2.0 use cases, respectively:

   scope="openid profile email"
   scope="urn:example:channel=HBO&amp;urn:example:rating=G,PG-13"

   If the protected resource request included an access token and failed
   authentication, the resource server <em>SHOULD</em> include the "error"
   attribute to provide the client with the reason why the access
   request was declined.  The parameter value is described in
   <a href="#section-7.2.3">Section 7.2.3</a>.  In addition, the resource server <em>MAY</em> include the
   "error_description" attribute to provide developers a human-readable
   explanation that is not meant to be displayed to end-users.  It also
   <em>MAY</em> include the "error_uri" attribute with an absolute URI



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 43]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-44"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   identifying a human-readable web page explaining the error.  The
   "error", "error_description", and "error_uri" attributes <em>MUST NOT</em>
   appear more than once.

   Values for the "scope" attribute (specified in <a href="#appendix-A.4">Appendix A.4</a>) <em>MUST NOT</em>
   include characters outside the set %x21 / %x23-5B / %x5D-7E for
   representing scope values and %x20 for delimiters between scope
   values.  Values for the "error" and "error_description" attributes
   (specified in Appendixes A.7 and A.8) <em>MUST NOT</em> include characters
   outside the set %x20-21 / %x23-5B / %x5D-7E.  Values for the
   "error_uri" attribute (specified in <a href="#appendix-A.9">Appendix A.9</a> of) <em>MUST</em> conform to
   the URI-reference syntax and thus <em>MUST NOT</em> include characters outside
   the set %x21 / %x23-5B / %x5D-7E.

   For example, in response to a protected resource request without
   authentication:

   HTTP/1.1 401 Unauthorized
   WWW-Authenticate: Bearer realm="example"

   And in response to a protected resource request with an
   authentication attempt using an expired access token:

   HTTP/1.1 401 Unauthorized
   WWW-Authenticate: Bearer realm="example",
                     error="invalid_token",
                     error_description="The access token expired"

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.2.3.%20%20Error%20Codes"></a></body></html><a class="selflink" href="#section-7.2.3" id="section-7.2.3">7.2.3</a>.  Error Codes</span>

   When a request fails, the resource server responds using the
   appropriate HTTP status code (typically, 400, 401, 403, or 405) and
   includes one of the following error codes in the response:

   "invalid_request":  The request is missing a required parameter,
      includes an unsupported parameter or parameter value, repeats the
      same parameter, uses more than one method for including an access
      token, or is otherwise malformed.  The resource server <em>SHOULD</em>
      respond with the HTTP 400 (Bad Request) status code.

   "invalid_token":  The access token provided is expired, revoked,
      malformed, or invalid for other reasons.  The resource <em>SHOULD</em>
      respond with the HTTP 401 (Unauthorized) status code.  The client
      <em>MAY</em> request a new access token and retry the protected resource
      request.

   "insufficient_scope":  The request requires higher privileges than




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 44]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-45"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


      provided by the access token.  The resource server <em>SHOULD</em> respond
      with the HTTP 403 (Forbidden) status code and <em>MAY</em> include the
      "scope" attribute with the scope necessary to access the protected
      resource.

   If the request lacks any authentication information (e.g., the client
   was unaware that authentication is necessary or attempted using an
   unsupported authentication method), the resource server <em>SHOULD NOT</em>
   include an error code or other error information.

   For example:

   HTTP/1.1 401 Unauthorized
   WWW-Authenticate: Bearer realm="example"

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.3.%20%20Error%20Response"></a></body></html><a class="selflink" href="#section-7.3" id="section-7.3">7.3</a>.  Error Response</span>

   If a resource access request fails, the resource server <em>SHOULD</em> inform
   the client of the error.  The method by which the resource server
   does this is determined by the particular token type, such as the
   description of Bearer tokens in <a href="#section-7.2.3">Section 7.2.3</a>.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.3.1.%20%20Extension%20Token%20Types"></a></body></html><a class="selflink" href="#section-7.3.1" id="section-7.3.1">7.3.1</a>.  Extension Token Types</span>

   [<a id="ref-RFC6750">RFC6750</a>] establishes a common registry in <a href="#section-11.4">Section 11.4</a>
   (<a href="https://tools.ietf.org/html/rfc6749#section-11.4">https://tools.ietf.org/html/rfc6749#section-11.4</a>) for error values
   to be shared among OAuth token authentication schemes.

   New authentication schemes designed primarily for OAuth token
   authentication <em>SHOULD</em> define a mechanism for providing an error
   status code to the client, in which the error values allowed are
   registered in the error registry established by this specification.

   Such schemes <em>MAY</em> limit the set of valid error codes to a subset of
   the registered values.  If the error code is returned using a named
   parameter, the parameter name <em>SHOULD</em> be "error".

   Other schemes capable of being used for OAuth token authentication,
   but not primarily designed for that purpose, <em>MAY</em> bind their error
   values to the registry in the same manner.

   New authentication schemes <em>MAY</em> choose to also specify the use of the
   "error_description" and "error_uri" parameters to return error
   information in a manner parallel to their usage in this
   specification.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.%20%20Access%20Token%20Security%20Considerations"></a></body></html><a class="selflink" href="#section-7.4" id="section-7.4">7.4</a>.  Access Token Security Considerations</span>




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 45]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-46"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.1.%20%20Security%20Threats"></a></body></html><a class="selflink" href="#section-7.4.1" id="section-7.4.1">7.4.1</a>.  Security Threats</span>

   The following list presents several common threats against protocols
   utilizing some form of tokens.  This list of threats is based on NIST
   Special Publication 800-63 [<a href="#ref-NIST800-63">NIST800-63</a>].

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.1.1.%20%20Token%20manufacture/modification"></a></body></html><a class="selflink" href="#section-7.4.1.1" id="section-7.4.1.1">7.4.1.1</a>.  Token manufacture/modification</span>

   An attacker may generate a bogus token or modify the token contents
   (such as the authentication or attribute statements) of an existing
   token, causing the resource server to grant inappropriate access to
   the client.  For example, an attacker may modify the token to extend
   the validity period; a malicious client may modify the assertion to
   gain access to information that they should not be able to view.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.1.2.%20%20Token%20disclosure"></a></body></html><a class="selflink" href="#section-7.4.1.2" id="section-7.4.1.2">7.4.1.2</a>.  Token disclosure</span>

   Tokens may contain authentication and attribute statements that
   include sensitive information.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.1.3.%20%20Token%20redirect"></a></body></html><a class="selflink" href="#section-7.4.1.3" id="section-7.4.1.3">7.4.1.3</a>.  Token redirect</span>

   An attacker uses a token generated for consumption by one resource
   server to gain access to a different resource server that mistakenly
   believes the token to be for it.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.1.4.%20%20Token%20replay"></a></body></html><a class="selflink" href="#section-7.4.1.4" id="section-7.4.1.4">7.4.1.4</a>.  Token replay</span>

   An attacker attempts to use a token that has already been used with
   that resource server in the past.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.2.%20%20Threat%20Mitigation"></a></body></html><a class="selflink" href="#section-7.4.2" id="section-7.4.2">7.4.2</a>.  Threat Mitigation</span>

   A large range of threats can be mitigated by protecting the contents
   of the token by using a digital signature.  Alternatively, a bearer
   token can contain a reference to authorization information, rather
   than encoding the information directly.  Such references <em>MUST</em> be
   infeasible for an attacker to guess; using a reference may require an
   extra interaction between a server and the token issuer to resolve
   the reference to the authorization information.  The mechanics of
   such an interaction are not defined by this specification.

   This document does not specify the encoding or the contents of the
   token; hence, detailed recommendations about the means of
   guaranteeing token integrity protection are outside the scope of this
   document.  The token integrity protection <em>MUST</em> be sufficient to
   prevent the token from being modified.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 46]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-47"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   To deal with token redirect, it is important for the authorization
   server to include the identity of the intended recipients (the
   audience), typically a single resource server (or a list of resource
   servers), in the token.  Restricting the use of the token to a
   specific scope is also <em>RECOMMENDED</em>.

   The authorization server <em>MUST</em> implement TLS.  Which version(s) ought
   to be implemented will vary over time and will depend on the
   widespread deployment and known security vulnerabilities at the time
   of implementation.

   To protect against token disclosure, confidentiality protection <em>MUST</em>
   be applied using TLS with a ciphersuite that provides confidentiality
   and integrity protection.  This requires that the communication
   interaction between the client and the authorization server, as well
   as the interaction between the client and the resource server,
   utilize confidentiality and integrity protection.  Since TLS is
   mandatory to implement and to use with this specification, it is the
   preferred approach for preventing token disclosure via the
   communication channel.  For those cases where the client is prevented
   from observing the contents of the token, token encryption <em>MUST</em> be
   applied in addition to the usage of TLS protection.  As a further
   defense against token disclosure, the client <em>MUST</em> validate the TLS
   certificate chain when making requests to protected resources,
   including checking the Certificate Revocation List (CRL) [<a href="/doc/html/rfc5280" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>].

   Cookies are typically transmitted in the clear.  Thus, any
   information contained in them is at risk of disclosure.  Therefore,
   Bearer tokens <em>MUST NOT</em> be stored in cookies that can be sent in the
   clear, as any information in them is at risk of disclosure.  See
   "HTTP State Management Mechanism" [<a href="/doc/html/rfc6265" title='"HTTP State Management Mechanism"'>RFC6265</a>] for security
   considerations about cookies.

   In some deployments, including those utilizing load balancers, the
   TLS connection to the resource server terminates prior to the actual
   server that provides the resource.  This could leave the token
   unprotected between the front-end server where the TLS connection
   terminates and the back-end server that provides the resource.  In
   such deployments, sufficient measures <em>MUST</em> be employed to ensure
   confidentiality of the token between the front-end and back-end
   servers; encryption of the token is one such possible measure.

   To deal with token capture and replay, the following recommendations
   are made: First, the lifetime of the token <em>MUST</em> be limited; one means
   of achieving this is by putting a validity time field inside the
   protected part of the token.  Note that using short-lived (one hour
   or less) tokens reduces the impact of them being leaked.  Second,
   confidentiality protection of the exchanges between the client and



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 47]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-48"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   the authorization server and between the client and the resource
   server <em>MUST</em> be applied.  As a consequence, no eavesdropper along the
   communication path is able to observe the token exchange.
   Consequently, such an on-path adversary cannot replay the token.
   Furthermore, when presenting the token to a resource server, the
   client <em>MUST</em> verify the identity of that resource server, as per
   <a href="#section-3.1">Section 3.1</a> of "HTTP Over TLS" [<a href="/doc/html/rfc2818" title='"HTTP Over TLS"'>RFC2818</a>].  Note that the client <em>MUST</em>
   validate the TLS certificate chain when making these requests to
   protected resources.  Presenting the token to an unauthenticated and
   unauthorized resource server or failing to validate the certificate
   chain will allow adversaries to steal the token and gain unauthorized
   access to protected resources.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.%20%20Summary%20of%20Recommendations"></a></body></html><a class="selflink" href="#section-7.4.3" id="section-7.4.3">7.4.3</a>.  Summary of Recommendations</span>

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.1.%20%20Safeguard%20bearer%20tokens"></a></body></html><a class="selflink" href="#section-7.4.3.1" id="section-7.4.3.1">7.4.3.1</a>.  Safeguard bearer tokens</span>

   Client implementations <em>MUST</em> ensure that bearer tokens are not leaked
   to unintended parties, as they will be able to use them to gain
   access to protected resources.  This is the primary security
   consideration when using bearer tokens and underlies all the more
   specific recommendations that follow.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.2.%20%20Validate%20TLS%20certificate%20chains"></a></body></html><a class="selflink" href="#section-7.4.3.2" id="section-7.4.3.2">7.4.3.2</a>.  Validate TLS certificate chains</span>

   The client <em>MUST</em> validate the TLS certificate chain when making
   requests to protected resources.  Failing to do so may enable DNS
   hijacking attacks to steal the token and gain unintended access.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.3.%20%20Always%20use%20TLS%20%28https%29"></a></body></html><a class="selflink" href="#section-7.4.3.3" id="section-7.4.3.3">7.4.3.3</a>.  Always use TLS (https)</span>

   Clients <em>MUST</em> always use TLS (https) or equivalent transport security
   when making requests with bearer tokens.  Failing to do so exposes
   the token to numerous attacks that could give attackers unintended
   access.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.4.%20%20Don%27t%20store%20bearer%20tokens%20in%20HTTP%20cookies"></a></body></html><a class="selflink" href="#section-7.4.3.4" id="section-7.4.3.4">7.4.3.4</a>.  Don't store bearer tokens in HTTP cookies</span>

   Implementations <em>MUST NOT</em> store bearer tokens within cookies that can
   be sent in the clear (which is the default transmission mode for
   cookies).  Implementations that do store bearer tokens in cookies
   <em>MUST</em> take precautions against cross-site request forgery.









<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 48]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-49"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.5.%20%20Issue%20short-lived%20bearer%20tokens"></a></body></html><a class="selflink" href="#section-7.4.3.5" id="section-7.4.3.5">7.4.3.5</a>.  Issue short-lived bearer tokens</span>

   Token servers <em>SHOULD</em> issue short-lived (one hour or less) bearer
   tokens, particularly when issuing tokens to clients that run within a
   web browser or other environments where information leakage may
   occur.  Using short-lived bearer tokens can reduce the impact of them
   being leaked.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.6.%20%20Issue%20scoped%20bearer%20tokens"></a></body></html><a class="selflink" href="#section-7.4.3.6" id="section-7.4.3.6">7.4.3.6</a>.  Issue scoped bearer tokens</span>

   Token servers <em>SHOULD</em> issue bearer tokens that contain an audience
   restriction, scoping their use to the intended relying party or set
   of relying parties.

<span class="h5"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.3.7.%20%20Don%27t%20pass%20bearer%20tokens%20in%20page%20URLs"></a></body></html><a class="selflink" href="#section-7.4.3.7" id="section-7.4.3.7">7.4.3.7</a>.  Don't pass bearer tokens in page URLs</span>

   Bearer tokens <em>MUST NOT</em> be passed in page URLs (for example, as query
   string parameters).  Instead, bearer tokens <em>SHOULD</em> be passed in HTTP
   message headers or message bodies for which confidentiality measures
   are taken.  Browsers, web servers, and other software may not
   adequately secure URLs in the browser history, web server logs, and
   other data structures.  If bearer tokens are passed in page URLs,
   attackers might be able to steal them from the history data, logs, or
   other unsecured locations.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.4.%20%20Token%20Replay%20Prevention"></a></body></html><a class="selflink" href="#section-7.4.4" id="section-7.4.4">7.4.4</a>.  Token Replay Prevention</span>

   A sender-constrained access token scopes the applicability of an
   access token to a certain sender.  This sender is obliged to
   demonstrate knowledge of a certain secret as prerequisite for the
   acceptance of that token at the recipient (e.g., a resource server).

   Authorization and resource servers <em>SHOULD</em> use mechanisms for sender-
   constrained access tokens to prevent token replay as described in
   Section 4.8.1.1.2 of [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>].  The use of
   Mutual TLS for OAuth 2.0 [<a href="/doc/html/rfc8705" title='"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"'>RFC8705</a>] is <em>RECOMMENDED</em>.

   It is <em>RECOMMENDED</em> to use end-to-end TLS.  If TLS traffic needs to be
   terminated at an intermediary, refer to Section 4.11 of
   [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>] for further security advice.











<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 49]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-50"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/7.4.5.%20%20Access%20Token%20Privilege%20Restriction"></a></body></html><a class="selflink" href="#section-7.4.5" id="section-7.4.5">7.4.5</a>.  Access Token Privilege Restriction</span>

   The privileges associated with an access token <em>SHOULD</em> be restricted
   to the minimum required for the particular application or use case.
   This prevents clients from exceeding the privileges authorized by the
   resource owner.  It also prevents users from exceeding their
   privileges authorized by the respective security policy.  Privilege
   restrictions also help to reduce the impact of access token leakage.

   In particular, access tokens <em>SHOULD</em> be restricted to certain resource
   servers (audience restriction), preferably to a single resource
   server.  To put this into effect, the authorization server associates
   the access token with certain resource servers and every resource
   server is obliged to verify, for every request, whether the access
   token sent with that request was meant to be used for that particular
   resource server.  If not, the resource server <em>MUST</em> refuse to serve
   the respective request.  Clients and authorization servers <em>MAY</em>
   utilize the parameters "scope" or "resource" as specified in this
   document and [<a href="/doc/html/rfc8707" title='"Resource Indicators for OAuth 2.0"'>RFC8707</a>], respectively, to determine the resource
   server they want to access.

   Additionally, access tokens <em>SHOULD</em> be restricted to certain resources
   and actions on resource servers or resources.  To put this into
   effect, the authorization server associates the access token with the
   respective resource and actions and every resource server is obliged
   to verify, for every request, whether the access token sent with that
   request was meant to be used for that particular action on the
   particular resource.  If not, the resource server must refuse to
   serve the respective request.  Clients and authorization servers <em>MAY</em>
   utilize the parameter "scope" and "authorization_details" as
   specified in [<a href="#ref-I-D.ietf-oauth-rar">I-D.ietf-oauth-rar</a>] to determine those resources and/or
   actions.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.%20%20Extensibility"></a></body></html><a class="selflink" href="#section-8" id="section-8">8</a>.  Extensibility</span>

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.1.%20%20Defining%20Access%20Token%20Types"></a></body></html><a class="selflink" href="#section-8.1" id="section-8.1">8.1</a>.  Defining Access Token Types</span>

   Access token types can be defined in one of two ways: registered in
   the Access Token Types registry (following the procedures in
   <a href="/doc/html/rfc6749#section-11.1">SectionÂ 11.1 of [RFC6749]</a>), or by using a unique absolute URI as its
   name.

   Types utilizing a URI name <em>SHOULD</em> be limited to vendor-specific
   implementations that are not commonly applicable, and are specific to
   the implementation details of the resource server where they are
   used.





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 50]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-51"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   All other types <em>MUST</em> be registered.  Type names <em>MUST</em> conform to the
   type-name ABNF.  If the type definition includes a new HTTP
   authentication scheme, the type name <em>SHOULD</em> be identical to the HTTP
   authentication scheme name (as defined by [<a href="/doc/html/rfc2617" title='"HTTP Authentication: Basic and Digest Access Authentication"'>RFC2617</a>]).  The token type
   "example" is reserved for use in examples.

   type-name  = 1*name-char
   name-char  = "-" / "." / "_" / DIGIT / ALPHA

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.2.%20%20Defining%20New%20Endpoint%20Parameters"></a></body></html><a class="selflink" href="#section-8.2" id="section-8.2">8.2</a>.  Defining New Endpoint Parameters</span>

   New request or response parameters for use with the authorization
   endpoint or the token endpoint are defined and registered in the
   OAuth Parameters registry following the procedure in <a href="/doc/html/rfc6749#section-11.2">SectionÂ 11.2 of
   [RFC6749]</a>.

   Parameter names <em>MUST</em> conform to the param-name ABNF, and parameter
   values syntax <em>MUST</em> be well-defined (e.g., using ABNF, or a reference
   to the syntax of an existing parameter).

   param-name  = 1*name-char
   name-char   = "-" / "." / "_" / DIGIT / ALPHA

   Unregistered vendor-specific parameter extensions that are not
   commonly applicable and that are specific to the implementation
   details of the authorization server where they are used <em>SHOULD</em>
   utilize a vendor-specific prefix that is not likely to conflict with
   other registered values (e.g., begin with 'companyname_').

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.3.%20%20Defining%20New%20Authorization%20Grant%20Types"></a></body></html><a class="selflink" href="#section-8.3" id="section-8.3">8.3</a>.  Defining New Authorization Grant Types</span>

   New authorization grant types can be defined by assigning them a
   unique absolute URI for use with the "grant_type" parameter.  If the
   extension grant type requires additional token endpoint parameters,
   they <em>MUST</em> be registered in the OAuth Parameters registry as described
   by <a href="/doc/html/rfc6749#section-11.2">SectionÂ 11.2 of [RFC6749]</a>.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.4.%20%20Defining%20New%20Authorization%20Endpoint%20Response%20Types"></a></body></html><a class="selflink" href="#section-8.4" id="section-8.4">8.4</a>.  Defining New Authorization Endpoint Response Types</span>

   New response types for use with the authorization endpoint are
   defined and registered in the Authorization Endpoint Response Types
   registry following the procedure in <a href="/doc/html/rfc6749#section-11.3">SectionÂ 11.3 of [RFC6749]</a>.
   Response type names <em>MUST</em> conform to the response-type ABNF.

   response-type  = response-name *( SP response-name )
   response-name  = 1*response-char
   response-char  = "_" / DIGIT / ALPHA




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 51]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-52"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   If a response type contains one or more space characters (%x20), it
   is compared as a space-delimited list of values in which the order of
   values does not matter.  Only one order of values can be registered,
   which covers all other arrangements of the same set of values.

   For example, an extension can define and register the "code
   other_token" response type.  Once registered, the same combination
   cannot be registered as "other_token code", but both values can be
   used to denote the same response type.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/8.5.%20%20Defining%20Additional%20Error%20Codes"></a></body></html><a class="selflink" href="#section-8.5" id="section-8.5">8.5</a>.  Defining Additional Error Codes</span>

   In cases where protocol extensions (i.e., access token types,
   extension parameters, or extension grant types) require additional
   error codes to be used with the authorization code grant error
   response (<a href="#section-4.1.2.1">Section 4.1.2.1</a>), the token error response (<a href="#section-5.2">Section 5.2</a>),
   or the resource access error response (<a href="#section-7.3">Section 7.3</a>), such error codes
   <em>MAY</em> be defined.

   Extension error codes <em>MUST</em> be registered (following the procedures in
   <a href="/doc/html/rfc6749#section-11.4">SectionÂ 11.4 of [RFC6749]</a>) if the extension they are used in
   conjunction with is a registered access token type, a registered
   endpoint parameter, or an extension grant type.  Error codes used
   with unregistered extensions <em>MAY</em> be registered.

   Error codes <em>MUST</em> conform to the error ABNF and <em>SHOULD</em> be prefixed by
   an identifying name when possible.  For example, an error identifying
   an invalid value set to the extension parameter "example" <em>SHOULD</em> be
   named "example_invalid".

   error      = 1*error-char
   error-char = %x20-21 / %x23-5B / %x5D-7E

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.%20%20Security%20Considerations"></a></body></html><a class="selflink" href="#section-9" id="section-9">9</a>.  Security Considerations</span>

   As a flexible and extensible framework, OAuth's security
   considerations depend on many factors.  The following sections
   provide implementers with security guidelines focused on the three
   client profiles described in <a href="#section-2.1">Section 2.1</a>: web application, browser-
   based application, and native application.

   A comprehensive OAuth security model and analysis, as well as
   background for the protocol design, is provided by [<a href="/doc/html/rfc6819" title='"OAuth 2.0 Threat Model and Security Considerations"'>RFC6819</a>] and
   [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>].







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 52]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-53"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.1.%20%20Client%20Authentication"></a></body></html><a class="selflink" href="#section-9.1" id="section-9.1">9.1</a>.  Client Authentication</span>

   Authorization servers <em>SHOULD</em> use client authentication if possible.

   It is <em>RECOMMENDED</em> to use asymmetric (public-key based) methods for
   client authentication such as mTLS [<a href="/doc/html/rfc8705" title='"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"'>RFC8705</a>] or "private_key_jwt"
   [<a href="#ref-OpenID" title='"OpenID Connect Core 1.0"'>OpenID</a>].  When asymmetric methods for client authentication are
   used, authorization servers do not need to store sensitive symmetric
   keys, making these methods more robust against a number of attacks.

   Authorization server <em>MUST</em> only rely on client authentication if the
   process of issuance/registration and distribution of the underlying
   credentials ensures their confidentiality.

   When client authentication is not possible, the authorization server
   <em>SHOULD</em> employ other means to validate the client's identity - for
   example, by requiring the registration of the client redirect URI or
   enlisting the resource owner to confirm identity.  A valid redirect
   URI is not sufficient to verify the client's identity when asking for
   resource owner authorization but can be used to prevent delivering
   credentials to a counterfeit client after obtaining resource owner
   authorization.

   The authorization server must consider the security implications of
   interacting with unauthenticated clients and take measures to limit
   the potential exposure of other credentials (e.g., refresh tokens)
   issued to such clients.

   The privileges an authorization server associates with a certain
   client identity <em>MUST</em> depend on the assessment of the overall process
   for client identification and client credential lifecycle management.
   For example, authentication of a dynamically registered client just
   ensures the authorization server it is talking to the same client
   again.  In contrast, if there is a web application whose developer's
   identity was verified, who signed a contract and is issued a client
   secret that is only used in a secure backend service, the
   authorization server might allow this client to access more sensible
   services or to use the client credential grant type.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.1.1.%20%20Client%20Authentication%20of%20Native%20Apps"></a></body></html><a class="selflink" href="#section-9.1.1" id="section-9.1.1">9.1.1</a>.  Client Authentication of Native Apps</span>

   Secrets that are statically included as part of an app distributed to
   multiple users should not be treated as confidential secrets, as one
   user may inspect their copy and learn the shared secret.  For this
   reason, it is NOT <em>RECOMMENDED</em> for authorization servers to require
   client authentication of public native apps clients using a shared
   secret, as this serves little value beyond client identification
   which is already provided by the "client_id" request parameter.



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 53]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-54"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Authorization servers that still require a statically included shared
   secret for native app clients <em>MUST</em> treat the client as a public
   client (as defined in <a href="#section-2.1">Section 2.1</a>), and not accept the secret as
   proof of the client's identity.  Without additional measures, such
   clients are subject to client impersonation (see <a href="#section-9.3.1">Section 9.3.1</a>).

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.2.%20%20Registration%20of%20Native%20App%20Clients"></a></body></html><a class="selflink" href="#section-9.2" id="section-9.2">9.2</a>.  Registration of Native App Clients</span>

   Except when using a mechanism like Dynamic Client Registration
   [<a href="/doc/html/rfc7591" title='"OAuth 2.0 Dynamic Client Registration Protocol"'>RFC7591</a>] to provision per-instance secrets, native apps are
   classified as public clients, as defined in <a href="#section-2.1">Section 2.1</a>; they <em>MUST</em> be
   registered with the authorization server as such.  Authorization
   servers <em>MUST</em> record the client type in the client registration
   details in order to identify and process requests accordingly.

   Authorization servers <em>MUST</em> require clients to register their complete
   redirect URI (including the path component) and reject authorization
   requests that specify a redirect URI that doesn't exactly match the
   one that was registered; the exception is loopback redirects, where
   an exact match is required except for the port URI component.

   For private-use URI scheme-based redirects, authorization servers
   <em>SHOULD</em> enforce the requirement in <a href="#section-10.3.1">Section 10.3.1</a> that clients use
   schemes that are reverse domain name based.  At a minimum, any
   private-use URI scheme that doesn't contain a period character (".")
   <em>SHOULD</em> be rejected.

   In addition to the collision-resistant properties, requiring a URI
   scheme based on a domain name that is under the control of the app
   can help to prove ownership in the event of a dispute where two apps
   claim the same private-use URI scheme (where one app is acting
   maliciously).  For example, if two apps claimed "com.example.app",
   the owner of "example.com" could petition the app store operator to
   remove the counterfeit app.  Such a petition is harder to prove if a
   generic URI scheme was used.

   Authorization servers <em>MAY</em> request the inclusion of other platform-
   specific information, such as the app package or bundle name, or
   other information that may be useful for verifying the calling app's
   identity on operating systems that support such functions.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.3.%20%20Client%20Impersonation"></a></body></html><a class="selflink" href="#section-9.3" id="section-9.3">9.3</a>.  Client Impersonation</span>

   A malicious client can impersonate another client and obtain access
   to protected resources if the impersonated client fails to, or is
   unable to, keep its client credentials confidential.





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 54]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-55"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   The authorization server <em>MUST</em> authenticate the client whenever
   possible.  If the authorization server cannot authenticate the client
   due to the client's nature, the authorization server <em>MUST</em> require the
   registration of any redirect URI used for receiving authorization
   responses and <em>SHOULD</em> utilize other means to protect resource owners
   from such potentially malicious clients.  For example, the
   authorization server can engage the resource owner to assist in
   identifying the client and its origin.

   The authorization server <em>SHOULD</em> enforce explicit resource owner
   authentication and provide the resource owner with information about
   the client and the requested authorization scope and lifetime.  It is
   up to the resource owner to review the information in the context of
   the current client and to authorize or deny the request.

   The authorization server <em>SHOULD NOT</em> process repeated authorization
   requests automatically (without active resource owner interaction)
   without authenticating the client or relying on other measures to
   ensure that the repeated request comes from the original client and
   not an impersonator.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.3.1.%20%20Impersonation%20of%20Native%20Apps"></a></body></html><a class="selflink" href="#section-9.3.1" id="section-9.3.1">9.3.1</a>.  Impersonation of Native Apps</span>

   As stated above, the authorization server <em>SHOULD NOT</em> process
   authorization requests automatically without user consent or
   interaction, except when the identity of the client can be assured.
   This includes the case where the user has previously approved an
   authorization request for a given client id - unless the identity of
   the client can be proven, the request <em>SHOULD</em> be processed as if no
   previous request had been approved.

   Measures such as claimed "https" scheme redirects <em>MAY</em> be accepted by
   authorization servers as identity proof.  Some operating systems may
   offer alternative platform-specific identity features that <em>MAY</em> be
   accepted, as appropriate.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.4.%20%20Access%20Tokens"></a></body></html><a class="selflink" href="#section-9.4" id="section-9.4">9.4</a>.  Access Tokens</span>

   Access token credentials (as well as any confidential access token
   attributes) <em>MUST</em> be kept confidential in transit and storage, and
   only shared among the authorization server, the resource servers the
   access token is valid for, and the client to whom the access token is
   issued.  Access token credentials <em>MUST</em> only be transmitted using TLS
   as described in <a href="#section-1.6">Section 1.6</a> with server authentication as defined by
   [<a href="/doc/html/rfc2818" title='"HTTP Over TLS"'>RFC2818</a>].






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 55]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-56"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   The authorization server <em>MUST</em> ensure that access tokens cannot be
   generated, modified, or guessed to produce valid access tokens by
   unauthorized parties.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.4.1.%20%20Access%20Token%20Privilege%20Restriction"></a></body></html><a class="selflink" href="#section-9.4.1" id="section-9.4.1">9.4.1</a>.  Access Token Privilege Restriction</span>

   The client <em>SHOULD</em> request access tokens with the minimal scope
   necessary.  The authorization server <em>SHOULD</em> take the client identity
   into account when choosing how to honor the requested scope and <em>MAY</em>
   issue an access token with less rights than requested.

   The privileges associated with an access token <em>SHOULD</em> be restricted
   to the minimum required for the particular application or use case.
   This prevents clients from exceeding the privileges authorized by the
   resource owner.  It also prevents users from exceeding their
   privileges authorized by the respective security policy.  Privilege
   restrictions also help to reduce the impact of access token leakage.

   In particular, access tokens <em>SHOULD</em> be restricted to certain resource
   servers (audience restriction), preferably to a single resource
   server.  To put this into effect, the authorization server associates
   the access token with certain resource servers and every resource
   server is obliged to verify, for every request, whether the access
   token sent with that request was meant to be used for that particular
   resource server.  If not, the resource server <em>MUST</em> refuse to serve
   the respective request.  Clients and authorization servers <em>MAY</em>
   utilize the parameters "scope" or "resource" as specified in
   [<a href="/doc/html/rfc8707" title='"Resource Indicators for OAuth 2.0"'>RFC8707</a>], respectively, to determine the resource server they want
   to access.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.4.2.%20%20Access%20Token%20Replay%20Prevention"></a></body></html><a class="selflink" href="#section-9.4.2" id="section-9.4.2">9.4.2</a>.  Access Token Replay Prevention</span>

   Additionally, access tokens <em>SHOULD</em> be restricted to certain resources
   and actions on resource servers or resources.  To put this into
   effect, the authorization server associates the access token with the
   respective resource and actions and every resource server is obliged
   to verify, for every request, whether the access token sent with that
   request was meant to be used for that particular action on the
   particular resource.  If not, the resource server must refuse to
   serve the respective request.  Clients and authorization servers <em>MAY</em>
   utilize the parameter "scope" and "authorization_details" as
   specified in [<a href="#ref-I-D.ietf-oauth-rar">I-D.ietf-oauth-rar</a>] to determine those resources and/or
   actions.

   Authorization and resource servers <em>SHOULD</em> use mechanisms for sender-
   constrained access tokens to prevent token replay as described in
   (#pop_tokens).  A sender-constrained access token scopes the
   applicability of an access token to a certain sender.  This sender is



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 56]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-57"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   obliged to demonstrate knowledge of a certain secret as prerequisite
   for the acceptance of that token at the recipient (e.g., a resource
   server).  The use of Mutual TLS for OAuth 2.0 [<a href="/doc/html/rfc8705" title='"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"'>RFC8705</a>] is
   <em>RECOMMENDED</em>.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.5.%20%20Refresh%20Tokens"></a></body></html><a class="selflink" href="#section-9.5" id="section-9.5">9.5</a>.  Refresh Tokens</span>

   Authorization servers <em>MAY</em> issue refresh tokens to clients.

   Refresh tokens <em>MUST</em> be kept confidential in transit and storage, and
   shared only among the authorization server and the client to whom the
   refresh tokens were issued.  The authorization server <em>MUST</em> maintain
   the binding between a refresh token and the client to whom it was
   issued.  Refresh tokens <em>MUST</em> only be transmitted using TLS as
   described in <a href="#section-1.6">Section 1.6</a> with server authentication as defined by
   [<a href="/doc/html/rfc2818" title='"HTTP Over TLS"'>RFC2818</a>].

   The authorization server <em>MUST</em> verify the binding between the refresh
   token and client identity whenever the client identity can be
   authenticated.  When client authentication is not possible, the
   authorization server <em>SHOULD</em> issue sender-constrained refresh tokens
   or use refresh token rotation as described in
   (#refresh_token_protection).

   The authorization server <em>MUST</em> ensure that refresh tokens cannot be
   generated, modified, or guessed to produce valid refresh tokens by
   unauthorized parties.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.6.%20%20Client%20Impersonating%20Resource%20Owner"></a></body></html><a class="selflink" href="#section-9.6" id="section-9.6">9.6</a>.  Client Impersonating Resource Owner</span>

   Resource servers may make access control decisions based on the
   identity of the resource owner as communicated in the "sub" claim
   returned by the authorization server in a token introspection
   response [<a href="/doc/html/rfc7662" title='"OAuth 2.0 Token Introspection"'>RFC7662</a>] or other mechanisms.  If a client is able to
   choose its own "client_id" during registration with the authorization
   server, then there is a risk that it can register with the same "sub"
   value as a privileged user.  A subsequent access token obtained under
   the client credentials grant may be mistaken for an access token
   authorized by the privileged user if the resource server does not
   perform additional checks.

   Authorization servers <em>SHOULD NOT</em> allow clients to influence their
   "client_id" or "sub" value or any other claim if that can cause
   confusion with a genuine resource owner.  Where this cannot be
   avoided, authorization servers <em>MUST</em> provide other means for the
   resource server to distinguish between access tokens authorized by a
   resource owner from access tokens authorized by the client itself.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 57]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-58"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.7.%20%20Protecting%20Redirect-Based%20Flows"></a></body></html><a class="selflink" href="#section-9.7" id="section-9.7">9.7</a>.  Protecting Redirect-Based Flows</span>

   When comparing client redirect URIs against pre-registered URIs,
   authorization servers <em>MUST</em> utilize exact string matching.  This
   measure contributes to the prevention of leakage of authorization
   codes and access tokens (see (#insufficient_uri_validation)).  It can
   also help to detect mix-up attacks (see (#mix_up)).

   Clients <em>MUST NOT</em> expose URLs that forward the user's browser to
   arbitrary URIs obtained from a query parameter ("open redirector").
   Open redirectors can enable exfiltration of authorization codes and
   access tokens, see (#open_redirector_on_client).

   Clients <em>MUST</em> prevent Cross-Site Request Forgery (CSRF).  In this
   context, CSRF refers to requests to the redirection endpoint that do
   not originate at the authorization server, but a malicious third
   party (see <a href="/doc/html/rfc6819#section-4.4.1.8">SectionÂ 4.4.1.8. of [RFC6819]</a> for details).  Clients that
   have ensured that the authorization server supports the
   "code_challenge" parameter <em>MAY</em> rely the CSRF protection provided by
   that mechanism.  In OpenID Connect flows, the "nonce" parameter
   provides CSRF protection.  Otherwise, one-time use CSRF tokens
   carried in the "state" parameter that are securely bound to the user
   agent <em>MUST</em> be used for CSRF protection (see (#csrf_countermeasures)).

   In order to prevent mix-up attacks (see (#mix_up)), clients <em>MUST</em> only
   process redirect responses of the authorization server they sent the
   respective request to and from the same user agent this authorization
   request was initiated with.  Clients <em>MUST</em> store the authorization
   server they sent an authorization request to and bind this
   information to the user agent and check that the authorization
   request was received from the correct authorization server.  Clients
   <em>MUST</em> ensure that the subsequent token request, if applicable, is sent
   to the same authorization server.  Clients <em>SHOULD</em> use distinct
   redirect URIs for each authorization server as a means to identify
   the authorization server a particular response came from.

   An AS that redirects a request potentially containing user
   credentials <em>MUST</em> avoid forwarding these user credentials accidentally
   (see <a href="#section-9.7.2">Section 9.7.2</a> for details).

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.7.1.%20%20Loopback%20Redirect%20Considerations%20in%20Native%20Apps"></a></body></html><a class="selflink" href="#section-9.7.1" id="section-9.7.1">9.7.1</a>.  Loopback Redirect Considerations in Native Apps</span>

   Loopback interface redirect URIs use the "http" scheme (i.e., without
   Transport Layer Security (TLS)).  This is acceptable for loopback
   interface redirect URIs as the HTTP request never leaves the device.

   Clients should open the network port only when starting the
   authorization request and close it once the response is returned.



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 58]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-59"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Clients should listen on the loopback network interface only, in
   order to avoid interference by other network actors.

   While redirect URIs using localhost (i.e.,
   "http://localhost:{port}/{path}") function similarly to loopback IP
   redirects described in <a href="#section-10.3.3">Section 10.3.3</a>, the use of "localhost" is NOT
   <em>RECOMMENDED</em>.  Specifying a redirect URI with the loopback IP literal
   rather than "localhost" avoids inadvertently listening on network
   interfaces other than the loopback interface.  It is also less
   susceptible to client-side firewalls and misconfigured host name
   resolution on the user's device.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.7.2.%20%20HTTP%20307%20Redirect"></a></body></html><a class="selflink" href="#section-9.7.2" id="section-9.7.2">9.7.2</a>.  HTTP 307 Redirect</span>

   An AS which redirects a request that potentially contains user
   credentials <em>MUST NOT</em> use the HTTP 307 status code for redirection.
   If an HTTP redirection (and not, for example, JavaScript) is used for
   such a request, AS <em>SHOULD</em> use HTTP status code 303 "See Other".

   At the authorization endpoint, a typical protocol flow is that the AS
   prompts the user to enter her credentials in a form that is then
   submitted (using the HTTP POST method) back to the authorization
   server.  The AS checks the credentials and, if successful, redirects
   the user agent to the client's redirect URI.

   If the status code 307 were used for redirection, the user agent
   would send the user credentials via HTTP POST to the client.

   This discloses the sensitive credentials to the client.  If the
   relying party is malicious, it can use the credentials to impersonate
   the user at the AS.

   The behavior might be unexpected for developers, but is defined in
   <a href="/doc/html/rfc7231#section-6.4.7">[RFC7231], SectionÂ 6.4.7</a>.  This status code does not require the user
   agent to rewrite the POST request to a GET request and thereby drop
   the form data in the POST request body.

   In the HTTP standard [<a href="/doc/html/rfc7231" title='"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"'>RFC7231</a>], only the status code 303
   unambigiously enforces rewriting the HTTP POST request to an HTTP GET
   request.  For all other status codes, including the popular 302, user
   agents can opt not to rewrite POST to GET requests and therefore to
   reveal the user credentials to the client.  (In practice, however,
   most user agents will only show this behaviour for 307 redirects.)

   Therefore, the <em>RECOMMENDED</em> status code for HTTP redirects is 303.






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 59]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-60"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.8.%20%20Authorization%20Codes"></a></body></html><a class="selflink" href="#section-9.8" id="section-9.8">9.8</a>.  Authorization Codes</span>

   The transmission of authorization codes <em>MUST</em> be made over a secure
   channel, and the client <em>MUST</em> require the use of TLS with its redirect
   URI if the URI identifies a network resource.  Since authorization
   codes are transmitted via user-agent redirections, they could
   potentially be disclosed through user-agent history and HTTP referrer
   headers.

   Authorization codes <em>MUST</em> be short lived and single-use.  If the
   authorization server observes multiple attempts to exchange an
   authorization code for an access token, the authorization server
   <em>SHOULD</em> attempt to revoke all refresh and access tokens already
   granted based on the compromised authorization code.

   If the client can be authenticated, the authorization servers <em>MUST</em>
   authenticate the client and ensure that the authorization code was
   issued to the same client.

   Clients <em>MUST</em> prevent injection (replay) of authorization codes into
   the authorization response by attackers.  To this end, using
   "code_challenge" and "code_verifier" is <em>REQUIRED</em> for clients and
   authorization servers <em>MUST</em> enforce their use, unless both of the
   following criteria are met:

   *  The client is a confidential or credentialed client.

   *  In the specific deployment and the specific request, there is
      reasonable assurance for authorization server that the client
      implements the OpenID Connect "nonce" mechanism properly.

   In this case, using and enforcing "code_challenge" and
   "code_verifier" is still <em>RECOMMENDED</em>.

   The "code_challenge" or OpenID Connect "nonce" value <em>MUST</em> be
   transaction-specific and securely bound to the client and the user
   agent in which the transaction was started.  If a transaction leads
   to an error, fresh values for "code_challenge" or "nonce" <em>MUST</em> be
   chosen.

   Historic note: Although PKCE [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>] was originally designed as a
   mechanism to protect native apps, this advice applies to all kinds of
   OAuth clients, including web applications and other confidential
   clients.







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 60]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-61"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Clients <em>SHOULD</em> use code challenge methods that do not expose the
   "code_verifier" in the authorization request.  Otherwise, attackers
   that can read the authorization request (cf.  Attacker A4 in
   (#secmodel)) can break the security provided by this mechanism.
   Currently, "S256" is the only such method.

   When an authorization code arrives at the token endpoint, the
   authorization server <em>MUST</em> do the following check:

   1.  If there was a "code_challenge" in the authorization request for
       which this code was issued, there must be a "code_verifier" in
       the token request, and it <em>MUST</em> be verified according to the steps
       in <a href="#section-4.1.3">Section 4.1.3</a>.  (This is no change from the current behavior
       in [<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>].)

   2.  If there was no "code_challenge" in the authorization request,
       any request to the token endpoint containing a "code_verifier"
       <em>MUST</em> be rejected.

   Authorization servers <em>MUST</em> support the "code_challenge" and
   "code_verifier" parameters.

   Authorization servers <em>MUST</em> provide a way to detect their support for
   the "code_challenge" mechanism.  To this end, they <em>MUST</em> either (a)
   publish the element "code_challenge_methods_supported" in their AS
   metadata ([<a href="/doc/html/rfc8414" title='"OAuth 2.0 Authorization Server Metadata"'>RFC8414</a>]) containing the supported
   "code_challenge_method"s (which can be used by the client to detect
   support) or (b) provide a deployment-specific way to ensure or
   determine support by the AS.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.9.%20%20Request%20Confidentiality"></a></body></html><a class="selflink" href="#section-9.9" id="section-9.9">9.9</a>.  Request Confidentiality</span>

   Access tokens, refresh tokens, authorization codes, and client
   credentials <em>MUST NOT</em> be transmitted in the clear.

   The "state" and "scope" parameters <em>SHOULD NOT</em> include sensitive
   client or resource owner information in plain text, as they can be
   transmitted over insecure channels or stored insecurely.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.10.%20%20Ensuring%20Endpoint%20Authenticity"></a></body></html><a class="selflink" href="#section-9.10" id="section-9.10">9.10</a>.  Ensuring Endpoint Authenticity</span>

   In order to prevent man-in-the-middle attacks, the authorization
   server <em>MUST</em> require the use of TLS with server authentication as
   defined by [<a href="/doc/html/rfc2818" title='"HTTP Over TLS"'>RFC2818</a>] for any request sent to the authorization and
   token endpoints.  The client <em>MUST</em> validate the authorization server's
   TLS certificate as defined by [<a href="/doc/html/rfc6125" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>] and in accordance with its
   requirements for server identity authentication.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 61]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-62"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.11.%20%20Credentials-Guessing%20Attacks"></a></body></html><a class="selflink" href="#section-9.11" id="section-9.11">9.11</a>.  Credentials-Guessing Attacks</span>

   The authorization server <em>MUST</em> prevent attackers from guessing access
   tokens, authorization codes, refresh tokens, resource owner
   passwords, and client credentials.

   The probability of an attacker guessing generated tokens (and other
   credentials not intended for handling by end-users) <em>MUST</em> be less than
   or equal to 2^(-128) and <em>SHOULD</em> be less than or equal to 2^(-160).

   The authorization server <em>MUST</em> utilize other means to protect
   credentials intended for end-user usage.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.12.%20%20Phishing%20Attacks"></a></body></html><a class="selflink" href="#section-9.12" id="section-9.12">9.12</a>.  Phishing Attacks</span>

   Wide deployment of this and similar protocols may cause end-users to
   become inured to the practice of being redirected to websites where
   they are asked to enter their passwords.  If end-users are not
   careful to verify the authenticity of these websites before entering
   their credentials, it will be possible for attackers to exploit this
   practice to steal resource owners' passwords.

   Service providers should attempt to educate end-users about the risks
   phishing attacks pose and should provide mechanisms that make it easy
   for end-users to confirm the authenticity of their sites.  Client
   developers should consider the security implications of how they
   interact with the user-agent (e.g., external, embedded), and the
   ability of the end-user to verify the authenticity of the
   authorization server.

   To reduce the risk of phishing attacks, the authorization servers
   <em>MUST</em> require the use of TLS on every endpoint used for end-user
   interaction.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.13.%20%20Fake%20External%20User-Agents%20in%20Native%20Apps"></a></body></html><a class="selflink" href="#section-9.13" id="section-9.13">9.13</a>.  Fake External User-Agents in Native Apps</span>

   The native app that is initiating the authorization request has a
   large degree of control over the user interface and can potentially
   present a fake external user-agent, that is, an embedded user-agent
   made to appear as an external user-agent.

   When all good actors are using external user-agents, the advantage is
   that it is possible for security experts to detect bad actors, as
   anyone faking an external user-agent is provably bad.  On the other
   hand, if good and bad actors alike are using embedded user-agents,
   bad actors don't need to fake anything, making them harder to detect.
   Once a malicious app is detected, it may be possible to use this
   knowledge to blacklist the app's signature in malware scanning



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 62]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-63"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   software, take removal action (in the case of apps distributed by app
   stores) and other steps to reduce the impact and spread of the
   malicious app.

   Authorization servers can also directly protect against fake external
   user-agents by requiring an authentication factor only available to
   true external user-agents.

   Users who are particularly concerned about their security when using
   in-app browser tabs may also take the additional step of opening the
   request in the full browser from the in-app browser tab and complete
   the authorization there, as most implementations of the in-app
   browser tab pattern offer such functionality.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.14.%20%20Malicious%20External%20User-Agents%20in%20Native%20Apps"></a></body></html><a class="selflink" href="#section-9.14" id="section-9.14">9.14</a>.  Malicious External User-Agents in Native Apps</span>

   If a malicious app is able to configure itself as the default handler
   for "https" scheme URIs in the operating system, it will be able to
   intercept authorization requests that use the default browser and
   abuse this position of trust for malicious ends such as phishing the
   user.

   This attack is not confined to OAuth; a malicious app configured in
   this way would present a general and ongoing risk to the user beyond
   OAuth usage by native apps.  Many operating systems mitigate this
   issue by requiring an explicit user action to change the default
   handler for "http" and "https" scheme URIs.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.15.%20%20Cross-Site%20Request%20Forgery"></a></body></html><a class="selflink" href="#section-9.15" id="section-9.15">9.15</a>.  Cross-Site Request Forgery</span>

   An attacker might attempt to inject a request to the redirect URI of
   the legitimate client on the victim's device, e.g., to cause the
   client to access resources under the attacker's control.  This is a
   variant of an attack known as Cross-Site Request Forgery (CSRF).

   The traditional countermeasure are CSRF tokens that are bound to the
   user agent and passed in the "state" parameter to the authorization
   server as described in [<a href="/doc/html/rfc6819" title='"OAuth 2.0 Threat Model and Security Considerations"'>RFC6819</a>].  The same protection is provided by
   the "code_verifier" parameter or the OpenID Connect "nonce" value.

   When using "code_verifier" instead of "state" or "nonce" for CSRF
   protection, it is important to note that:

   *  Clients <em>MUST</em> ensure that the AS supports the
      "code_challenge_method" intended to be used by the client.  If an
      authorization server does not support the requested method,
      "state" or "nonce" <em>MUST</em> be used for CSRF protection instead.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 63]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-64"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   *  If "state" is used for carrying application state, and integrity
      of its contents is a concern, clients <em>MUST</em> protect "state" against
      tampering and swapping.  This can be achieved by binding the
      contents of state to the browser session and/or signed/encrypted
      state values [<a href="#ref-I-D.bradley-oauth-jwt-encoded-state">I-D.bradley-oauth-jwt-encoded-state</a>].

   AS therefore <em>MUST</em> provide a way to detect their supported code
   challenge methods either via AS metadata according to [<a href="/doc/html/rfc8414" title='"OAuth 2.0 Authorization Server Metadata"'>RFC8414</a>] or
   provide a deployment-specific way to ensure or determine support.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.16.%20%20Clickjacking"></a></body></html><a class="selflink" href="#section-9.16" id="section-9.16">9.16</a>.  Clickjacking</span>

   As described in <a href="/doc/html/rfc6819#section-4.4.1.9">SectionÂ 4.4.1.9 of [RFC6819]</a>, the authorization
   request is susceptible to clickjacking.  An attacker can use this
   vector to obtain the user's authentication credentials, change the
   scope of access granted to the client, and potentially access the
   user's resources.

   Authorization servers <em>MUST</em> prevent clickjacking attacks.  Multiple
   countermeasures are described in [<a href="/doc/html/rfc6819" title='"OAuth 2.0 Threat Model and Security Considerations"'>RFC6819</a>], including the use of the
   X-Frame-Options HTTP response header field and frame-busting
   JavaScript.  In addition to those, authorization servers <em>SHOULD</em> also
   use Content Security Policy (CSP) level 2 [<a href="#ref-CSP-2" title='"Content Security Policy Level 2"'>CSP-2</a>] or greater.

   To be effective, CSP must be used on the authorization endpoint and,
   if applicable, other endpoints used to authenticate the user and
   authorize the client (e.g., the device authorization endpoint, login
   pages, error pages, etc.).  This prevents framing by unauthorized
   origins in user agents that support CSP.  The client <em>MAY</em> permit being
   framed by some other origin than the one used in its redirection
   endpoint.  For this reason, authorization servers <em>SHOULD</em> allow
   administrators to configure allowed origins for particular clients
   and/or for clients to register these dynamically.

   Using CSP allows authorization servers to specify multiple origins in
   a single response header field and to constrain these using flexible
   patterns (see [<a href="#ref-CSP-2" title='"Content Security Policy Level 2"'>CSP-2</a>] for details).  Level 2 of this standard
   provides a robust mechanism for protecting against clickjacking by
   using policies that restrict the origin of frames (using "frame-
   ancestors") together with those that restrict the sources of scripts
   allowed to execute on an HTML page (by using "script-src").  A non-
   normative example of such a policy is shown in the following listing:

   "HTTP/1.1 200 OK Content-Security-Policy: frame-ancestors
   <a href="https://ext.example.org:8000">https://ext.example.org:8000</a> Content-Security-Policy: script-src
   'self' X-Frame-Options: ALLOW-FROM <a href="https://ext.example.org:8000">https://ext.example.org:8000</a> ..."





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 64]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-65"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Because some user agents do not support [<a href="#ref-CSP-2" title='"Content Security Policy Level 2"'>CSP-2</a>], this technique
   <em>SHOULD</em> be combined with others, including those described in
   [<a href="/doc/html/rfc6819" title='"OAuth 2.0 Threat Model and Security Considerations"'>RFC6819</a>], unless such legacy user agents are explicitly unsupported
   by the authorization server.  Even in such cases, additional
   countermeasures <em>SHOULD</em> still be employed.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.17.%20%20Code%20Injection%20and%20Input%20Validation"></a></body></html><a class="selflink" href="#section-9.17" id="section-9.17">9.17</a>.  Code Injection and Input Validation</span>

   A code injection attack occurs when an input or otherwise external
   variable is used by an application unsanitized and causes
   modification to the application logic.  This may allow an attacker to
   gain access to the application device or its data, cause denial of
   service, or introduce a wide range of malicious side-effects.

   The authorization server and client <em>MUST</em> sanitize (and validate when
   possible) any value received - in particular, the value of the
   "state" and "redirect_uri" parameters.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.18.%20%20Open%20Redirectors"></a></body></html><a class="selflink" href="#section-9.18" id="section-9.18">9.18</a>.  Open Redirectors</span>

   The following attacks can occur when an AS or client has an open
   redirector.  An open redirector is an endpoint that forwards a user's
   browser to an arbitrary URI obtained from a query parameter.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.18.1.%20%20Client%20as%20Open%20Redirector"></a></body></html><a class="selflink" href="#section-9.18.1" id="section-9.18.1">9.18.1</a>.  Client as Open Redirector</span>

   Clients <em>MUST NOT</em> expose open redirectors.  Attackers may use open
   redirectors to produce URLs pointing to the client and utilize them
   to exfiltrate authorization codes and access tokens, as described in
   (#redir_uri_open_redir).  Another abuse case is to produce URLs that
   appear to point to the client.  This might trick users into trusting
   the URL and follow it in their browser.  This can be abused for
   phishing.

   In order to prevent open redirection, clients should only redirect if
   the target URLs are whitelisted or if the origin and integrity of a
   request can be authenticated.  Countermeasures against open
   redirection are described by OWASP [<a href="#ref-owasp_redir">owasp_redir</a>].

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.18.2.%20%20Authorization%20Server%20as%20Open%20Redirector"></a></body></html><a class="selflink" href="#section-9.18.2" id="section-9.18.2">9.18.2</a>.  Authorization Server as Open Redirector</span>

   Just as with clients, attackers could try to utilize a user's trust
   in the authorization server (and its URL in particular) for
   performing phishing attacks.  OAuth authorization servers regularly
   redirect users to other web sites (the clients), but must do so in a
   safe way.





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 65]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-66"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   <a href="#section-4.1.2.1">Section 4.1.2.1</a> already prevents open redirects by stating that the
   AS <em>MUST NOT</em> automatically redirect the user agent in case of an
   invalid combination of "client_id" and "redirect_uri".

   However, an attacker could also utilize a correctly registered
   redirect URI to perform phishing attacks.  The attacker could, for
   example, register a client via dynamic client registration [<a href="/doc/html/rfc7591" title='"OAuth 2.0 Dynamic Client Registration Protocol"'>RFC7591</a>]
   and intentionally send an erroneous authorization request, e.g., by
   using an invalid scope value, thus instructing the AS to redirect the
   user agent to its phishing site.

   The AS <em>MUST</em> take precautions to prevent this threat.  Based on its
   risk assessment, the AS needs to decide whether it can trust the
   redirect URI and <em>SHOULD</em> only automatically redirect the user agent if
   it trusts the redirect URI.  If the URI is not trusted, the AS <em>MAY</em>
   inform the user and rely on the user to make the correct decision.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.19.%20%20Authorization%20Server%20Mix-Up%20Mitigation%20in%20Native%20Apps"></a></body></html><a class="selflink" href="#section-9.19" id="section-9.19">9.19</a>.  Authorization Server Mix-Up Mitigation in Native Apps</span>

   (TODO: merge this with the regular mix-up section when it is brought
   in)

   To protect against a compromised or malicious authorization server
   attacking another authorization server used by the same app, it is
   <em>REQUIRED</em> that a unique redirect URI is used for each authorization
   server used by the app (for example, by varying the path component),
   and that authorization responses are rejected if the redirect URI
   they were received on doesn't match the redirect URI in an outgoing
   authorization request.

   The native app <em>MUST</em> store the redirect URI used in the authorization
   request with the authorization session data (i.e., along with "state"
   and other related data) and <em>MUST</em> verify that the URI on which the
   authorization response was received exactly matches it.

   The requirement of <a href="#section-9.2">Section 9.2</a>, specifically that authorization
   servers reject requests with URIs that don't match what was
   registered, is also required to prevent such attacks.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.20.%20%20Embedded%20User%20Agents%20in%20Native%20Apps"></a></body></html><a class="selflink" href="#section-9.20" id="section-9.20">9.20</a>.  Embedded User Agents in Native Apps</span>

   Embedded user-agents are a technically possible method for
   authorizing native apps.  These embedded user-agents are unsafe for
   use by third parties to the authorization server by definition, as
   the app that hosts the embedded user-agent can access the user's full
   authentication credential, not just the OAuth authorization grant
   that was intended for the app.




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 66]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-67"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   In typical web-view-based implementations of embedded user-agents,
   the host application can record every keystroke entered in the login
   form to capture usernames and passwords, automatically submit forms
   to bypass user consent, and copy session cookies and use them to
   perform authenticated actions as the user.

   Even when used by trusted apps belonging to the same party as the
   authorization server, embedded user-agents violate the principle of
   least privilege by having access to more powerful credentials than
   they need, potentially increasing the attack surface.

   Encouraging users to enter credentials in an embedded user-agent
   without the usual address bar and visible certificate validation
   features that browsers have makes it impossible for the user to know
   if they are signing in to the legitimate site; even when they are, it
   trains them that it's OK to enter credentials without validating the
   site first.

   Aside from the security concerns, embedded user-agents do not share
   the authentication state with other apps or the browser, requiring
   the user to log in for every authorization request, which is often
   considered an inferior user experience.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/9.21.%20%20Other%20Recommendations"></a></body></html><a class="selflink" href="#section-9.21" id="section-9.21">9.21</a>.  Other Recommendations</span>

   Authorization servers <em>SHOULD NOT</em> allow clients to influence their
   "client_id" or "sub" value or any other claim if that can cause
   confusion with a genuine resource owner (see
   (#client_impersonating)).

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.%20%20Native%20Applications"></a></body></html><a class="selflink" href="#section-10" id="section-10">10</a>.  Native Applications</span>

   Native applications are clients installed and executed on the device
   used by the resource owner (i.e., desktop application, native mobile
   application).  Native applications require special consideration
   related to security, platform capabilities, and overall end-user
   experience.

   The authorization endpoint requires interaction between the client
   and the resource owner's user-agent.  The best current practice is to
   perform the OAuth authorization request in an external user-agent
   (typically the browser) rather than an embedded user-agent (such as
   one implemented with web-views).

   The native application can capture the response from the
   authorization server using a redirect URI with a scheme registered
   with the operating system to invoke the client as the handler, manual
   copy-and-paste of the credentials, running a local web server,



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 67]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-68"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   installing a user-agent extension, or by providing a redirect URI
   identifying a server-hosted resource under the client's control,
   which in turn makes the response available to the native application.

   Previously, it was common for native apps to use embedded user-agents
   (commonly implemented with web-views) for OAuth authorization
   requests.  That approach has many drawbacks, including the host app
   being able to copy user credentials and cookies as well as the user
   needing to authenticate from scratch in each app.  See <a href="#section-9.20">Section 9.20</a>
   for a deeper analysis of the drawbacks of using embedded user-agents
   for OAuth.

   Native app authorization requests that use the browser are more
   secure and can take advantage of the user's authentication state.
   Being able to use the existing authentication session in the browser
   enables single sign-on, as users don't need to authenticate to the
   authorization server each time they use a new app (unless required by
   the authorization server policy).

   Supporting authorization flows between a native app and the browser
   is possible without changing the OAuth protocol itself, as the OAuth
   authorization request and response are already defined in terms of
   URIs.  This encompasses URIs that can be used for inter-app
   communication.  Some OAuth server implementations that assume all
   clients are confidential web clients will need to add an
   understanding of public native app clients and the types of redirect
   URIs they use to support this best practice.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.1.%20%20Using%20Inter-App%20URI%20Communication%20for%20OAuth%20in%20Native%20Apps"></a></body></html><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Using Inter-App URI Communication for OAuth in Native Apps</span>

   Just as URIs are used for OAuth on the web to initiate the
   authorization request and return the authorization response to the
   requesting website, URIs can be used by native apps to initiate the
   authorization request in the device's browser and return the response
   to the requesting native app.

   By adopting the same methods used on the web for OAuth, benefits seen
   in the web context like the usability of a single sign-on session and
   the security of a separate authentication context are likewise gained
   in the native app context.  Reusing the same approach also reduces
   the implementation complexity and increases interoperability by
   relying on standards-based web flows that are not specific to a
   particular platform.








<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 68]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-69"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Native apps <em>MUST</em> use an external user-agent to perform OAuth
   authorization requests.  This is achieved by opening the
   authorization request in the browser (detailed in <a href="#section-10.2">Section 10.2</a>) and
   using a redirect URI that will return the authorization response back
   to the native app (defined in <a href="#section-10.3">Section 10.3</a>).

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.2.%20%20Initiating%20the%20Authorization%20Request%20from%20a%20Native%20App"></a></body></html><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Initiating the Authorization Request from a Native App</span>

   Native apps needing user authorization create an authorization
   request URI with the authorization code grant type per <a href="#section-4.1">Section 4.1</a>
   using a redirect URI capable of being received by the native app.

   The function of the redirect URI for a native app authorization
   request is similar to that of a web-based authorization request.
   Rather than returning the authorization response to the OAuth
   client's server, the redirect URI used by a native app returns the
   response to the app.  Several options for a redirect URI that will
   return the authorization response to the native app in different
   platforms are documented in <a href="#section-10.3">Section 10.3</a>.  Any redirect URI that
   allows the app to receive the URI and inspect its parameters is
   viable.

   After constructing the authorization request URI, the app uses
   platform-specific APIs to open the URI in an external user-agent.
   Typically, the external user-agent used is the default browser, that
   is, the application configured for handling "http" and "https" scheme
   URIs on the system; however, different browser selection criteria and
   other categories of external user-agents <em>MAY</em> be used.

   This best practice focuses on the browser as the <em>RECOMMENDED</em> external
   user-agent for native apps.  An external user-agent designed
   specifically for user authorization and capable of processing
   authorization requests and responses like a browser <em>MAY</em> also be used.
   Other external user-agents, such as a native app provided by the
   authorization server may meet the criteria set out in this best
   practice, including using the same redirect URI properties, but their
   use is out of scope for this specification.

   Some platforms support a browser feature known as "in-app browser
   tabs", where an app can present a tab of the browser within the app
   context without switching apps, but still retain key benefits of the
   browser such as a shared authentication state and security context.
   On platforms where they are supported, it is <em>RECOMMENDED</em>, for
   usability reasons, that apps use in-app browser tabs for the
   authorization request.






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 69]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-70"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.3.%20%20Receiving%20the%20Authorization%20Response%20in%20a%20Native%20App"></a></body></html><a class="selflink" href="#section-10.3" id="section-10.3">10.3</a>.  Receiving the Authorization Response in a Native App</span>

   There are several redirect URI options available to native apps for
   receiving the authorization response from the browser, the
   availability and user experience of which varies by platform.

   To fully support native apps, authorization servers <em>MUST</em> offer at
   least the three redirect URI options described in the following
   subsections to native apps.  Native apps <em>MAY</em> use whichever redirect
   option suits their needs best, taking into account platform-specific
   implementation details.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.3.1.%20%20Private-Use%20URI%20Scheme%20Redirection"></a></body></html><a class="selflink" href="#section-10.3.1" id="section-10.3.1">10.3.1</a>.  Private-Use URI Scheme Redirection</span>

   Many mobile and desktop computing platforms support inter-app
   communication via URIs by allowing apps to register private-use URI
   schemes (sometimes colloquially referred to as "custom URL schemes")
   like "com.example.app".  When the browser or another app attempts to
   load a URI with a private-use URI scheme, the app that registered it
   is launched to handle the request.

   To perform an authorization request with a private-use URI scheme
   redirect, the native app launches the browser with a standard
   authorization request, but one where the redirect URI utilizes a
   private-use URI scheme it registered with the operating system.

   When choosing a URI scheme to associate with the app, apps <em>MUST</em> use a
   URI scheme based on a domain name under their control, expressed in
   reverse order, as recommended by <a href="/doc/html/rfc7595#section-3.8">SectionÂ 3.8 of [RFC7595]</a> for
   private-use URI schemes.

   For example, an app that controls the domain name "app.example.com"
   can use "com.example.app" as their scheme.  Some authorization
   servers assign client identifiers based on domain names, for example,
   "client1234.usercontent.example.net", which can also be used as the
   domain name for the scheme when reversed in the same manner.  A
   scheme such as "myapp", however, would not meet this requirement, as
   it is not based on a domain name.

   When there are multiple apps by the same publisher, care must be
   taken so that each scheme is unique within that group.  On platforms
   that use app identifiers based on reverse-order domain names, those
   identifiers can be reused as the private-use URI scheme for the OAuth
   redirect to help avoid this problem.







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 70]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-71"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Following the requirements of <a href="/doc/html/rfc3986#section-3.2">SectionÂ 3.2 of [RFC3986]</a>, as there is
   no naming authority for private-use URI scheme redirects, only a
   single slash ("/") appears after the scheme component.  A complete
   example of a redirect URI utilizing a private-use URI scheme is:

   com.example.app:/oauth2redirect/example-provider

   When the authorization server completes the request, it redirects to
   the client's redirect URI as it would normally.  As the redirect URI
   uses a private-use URI scheme, it results in the operating system
   launching the native app, passing in the URI as a launch parameter.
   Then, the native app uses normal processing for the authorization
   response.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.3.2.%20%20Claimed%20%22https%22%20Scheme%20URI%20Redirection"></a></body></html><a class="selflink" href="#section-10.3.2" id="section-10.3.2">10.3.2</a>.  Claimed "https" Scheme URI Redirection</span>

   Some operating systems allow apps to claim "https" scheme [<a href="/doc/html/rfc7230" title='"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing"'>RFC7230</a>]
   URIs in the domains they control.  When the browser encounters a
   claimed URI, instead of the page being loaded in the browser, the
   native app is launched with the URI supplied as a launch parameter.

   Such URIs can be used as redirect URIs by native apps.  They are
   indistinguishable to the authorization server from a regular web-
   based client redirect URI.  An example is:

   https://app.example.com/oauth2redirect/example-provider

   As the redirect URI alone is not enough to distinguish public native
   app clients from confidential web clients, it is <em>REQUIRED</em> in
   <a href="#section-9.2">Section 9.2</a> that the client type be recorded during client
   registration to enable the server to determine the client type and
   act accordingly.

   App-claimed "https" scheme redirect URIs have some advantages
   compared to other native app redirect options in that the identity of
   the destination app is guaranteed to the authorization server by the
   operating system.  For this reason, native apps <em>SHOULD</em> use them over
   the other options where possible.

<span class="h4"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/10.3.3.%20%20Loopback%20Interface%20Redirection"></a></body></html><a class="selflink" href="#section-10.3.3" id="section-10.3.3">10.3.3</a>.  Loopback Interface Redirection</span>

   Native apps that are able to open a port on the loopback network
   interface without needing special permissions (typically, those on
   desktop operating systems) can use the loopback interface to receive
   the OAuth redirect.

   Loopback redirect URIs use the "http" scheme and are constructed with
   the loopback IP literal and whatever port the client is listening on.



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 71]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-72"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   That is, "http://127.0.0.1:{port}/{path}" for IPv4, and
   "http://[::1]:{port}/{path}" for IPv6.  An example redirect using the
   IPv4 loopback interface with a randomly assigned port:

   <a href="http://127.0.0.1:51004/oauth2redirect/example-provider">http://127.0.0.1:51004/oauth2redirect/example-provider</a>

   An example redirect using the IPv6 loopback interface with a randomly
   assigned port:

   http://[::1]:61023/oauth2redirect/example-provider

   The authorization server <em>MUST</em> allow any port to be specified at the
   time of the request for loopback IP redirect URIs, to accommodate
   clients that obtain an available ephemeral port from the operating
   system at the time of the request.

   Clients <em>SHOULD NOT</em> assume that the device supports a particular
   version of the Internet Protocol.  It is <em>RECOMMENDED</em> that clients
   attempt to bind to the loopback interface using both IPv4 and IPv6
   and use whichever is available.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/11.%20%20Browser-Based%20Apps"></a></body></html><a class="selflink" href="#section-11" id="section-11">11</a>.  Browser-Based Apps</span>

   Browser-based apps are are clients that run in a web browser,
   typically written in JavaScript, also known as "single-page apps".
   These types of apps have particular security considerations similar
   to native apps.

   TODO: Bring in the normative text of the browser-based apps BCP when
   it is finalized.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/12.%20%20Differences%20from%20OAuth%202.0"></a></body></html><a class="selflink" href="#section-12" id="section-12">12</a>.  Differences from OAuth 2.0</span>

   This draft consolidates the functionality in OAuth 2.0 [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>],
   OAuth 2.0 for Native Apps ([<a href="/doc/html/rfc8252" title='"OAuth 2.0 for Native Apps"'>RFC8252</a>]), Proof Key for Code Exchange
   ([<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>]), OAuth 2.0 for Browser-Based Apps
   ([<a href="#ref-I-D.ietf-oauth-browser-based-apps">I-D.ietf-oauth-browser-based-apps</a>]), OAuth Security Best Current
   Practice ([<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]), and Bearer Token Usage
   ([<a href="/doc/html/rfc6750" title='"The OAuth 2.0 Authorization Framework: Bearer Token Usage"'>RFC6750</a>]).

   Where a later draft updates or obsoletes functionality found in the
   original [<a href="/doc/html/rfc6749" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>], that functionality in this draft is updated with
   the normative changes described in a later draft, or removed
   entirely.

   A non-normative list of changes from OAuth 2.0 is listed below:





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 72]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-73"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   *  The authorization code grant is extended with the functionality
      from PKCE ([<a href="/doc/html/rfc7636" title='"Proof Key for Code Exchange by OAuth Public Clients"'>RFC7636</a>]) such that the default method of using the
      authorization code grant according to this specification requires
      the addition of the PKCE parameters

   *  Redirect URIs must be compared using exact string matching as per
      Section 4.1.3 of [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]

   *  The Implicit grant ("response_type=token") is omitted from this
      specification as per Section 2.1.2 of
      [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]

   *  The Resource Owner Password Credentials grant is omitted from this
      specification as per Section 2.4 of
      [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]

   *  Bearer token usage omits the use of bearer tokens in the query
      string of URIs as per Section 4.3.2 of
      [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]

   *  Refresh tokens should either be sender-constrained or one-time use
      as per Section 4.12.2 of [<a href="#ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/13.%20%20IANA%20Considerations"></a></body></html><a class="selflink" href="#section-13" id="section-13">13</a>.  IANA Considerations</span>

   This document does not require any IANA actions.

   All referenced registries are defined by <a href="/doc/html/rfc6749">RFC6749</a> and related
   documents that this work is based upon.  No changes to those
   registries are required by this specification.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/14.%20%20References"></a></body></html><a class="selflink" href="#section-14" id="section-14">14</a>.  References</span>

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/14.1.%20%20Normative%20References"></a></body></html><a class="selflink" href="#section-14.1" id="section-14.1">14.1</a>.  Normative References</span>

   [<a id="ref-I-D.ietf-oauth-security-topics">I-D.ietf-oauth-security-topics</a>]
              Lodderstedt, T., Bradley, J., Labunets, A., and D. Fett,
              "OAuth 2.0 Security Best Current Practice", Work in
              Progress, Internet-Draft, <a href="/doc/html/draft-ietf-oauth-security-topics-15">draft-ietf-oauth-security-</a>
              <a href="/doc/html/draft-ietf-oauth-security-topics-15">topics-15</a>, 5 April 2020, &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-security-topics-15.txt">http://www.ietf.org/internet-</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-security-topics-15.txt">drafts/draft-ietf-oauth-security-topics-15.txt</a>&gt;.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 73]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-74"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   [<a id="ref-RFC2617">RFC2617</a>]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              <a href="/doc/html/rfc2617">RFC 2617</a>, DOI 10.17487/RFC2617, June 1999,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2617">https://www.rfc-editor.org/info/rfc2617</a>&gt;.

   [<a id="ref-RFC2818">RFC2818</a>]  Rescorla, E., "HTTP Over TLS", <a href="/doc/html/rfc2818">RFC 2818</a>,
              DOI 10.17487/RFC2818, May 2000,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2818">https://www.rfc-editor.org/info/rfc2818</a>&gt;.

   [<a id="ref-RFC3629">RFC3629</a>]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, <a href="/doc/html/rfc3629">RFC 3629</a>, DOI 10.17487/RFC3629, November
              2003, &lt;<a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>&gt;.

   [<a id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="/doc/html/rfc3986">RFC 3986</a>, DOI 10.17487/RFC3986, January 2005,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a id="ref-RFC4949">RFC4949</a>]  Shirey, R., "Internet Security Glossary, Version 2",
              FYI 36, <a href="/doc/html/rfc4949">RFC 4949</a>, DOI 10.17487/RFC4949, August 2007,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4949">https://www.rfc-editor.org/info/rfc4949</a>&gt;.

   [<a id="ref-RFC5234">RFC5234</a>]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, <a href="/doc/html/rfc5234">RFC 5234</a>,
              DOI 10.17487/RFC5234, January 2008,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.

   [<a id="ref-RFC5280">RFC5280</a>]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", <a href="/doc/html/rfc5280">RFC 5280</a>, DOI 10.17487/RFC5280, May 2008,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5280">https://www.rfc-editor.org/info/rfc5280</a>&gt;.

   [<a id="ref-RFC6125">RFC6125</a>]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", <a href="/doc/html/rfc6125">RFC 6125</a>, DOI 10.17487/RFC6125, March
              2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6125">https://www.rfc-editor.org/info/rfc6125</a>&gt;.

   [<a id="ref-RFC6749">RFC6749</a>]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              <a href="/doc/html/rfc6749">RFC 6749</a>, DOI 10.17487/RFC6749, October 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6749">https://www.rfc-editor.org/info/rfc6749</a>&gt;.







<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 74]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-75"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   [<a id="ref-RFC6750">RFC6750</a>]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", <a href="/doc/html/rfc6750">RFC 6750</a>,
              DOI 10.17487/RFC6750, October 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6750">https://www.rfc-editor.org/info/rfc6750</a>&gt;.

   [<a id="ref-RFC7159">RFC7159</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", <a href="/doc/html/rfc7159">RFC 7159</a>, DOI 10.17487/RFC7159, March
              2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7159">https://www.rfc-editor.org/info/rfc7159</a>&gt;.

   [<a id="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", <a href="/doc/html/rfc7231">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a id="ref-RFC7234">RFC7234</a>]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              <a href="/doc/html/rfc7234">RFC 7234</a>, DOI 10.17487/RFC7234, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7234">https://www.rfc-editor.org/info/rfc7234</a>&gt;.

   [<a id="ref-RFC7595">RFC7595</a>]  Thaler, D., Ed., Hansen, T., and T. Hardie, "Guidelines
              and Registration Procedures for URI Schemes", <a href="/doc/html/bcp35">BCP 35</a>,
              <a href="/doc/html/rfc7595">RFC 7595</a>, DOI 10.17487/RFC7595, June 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7595">https://www.rfc-editor.org/info/rfc7595</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="/doc/html/rfc2119">RFC</a>
              <a href="/doc/html/rfc2119">2119</a> Key Words", <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-RFC8252">RFC8252</a>]  Denniss, W. and J. Bradley, "OAuth 2.0 for Native Apps",
              <a href="/doc/html/bcp212">BCP 212</a>, <a href="/doc/html/rfc8252">RFC 8252</a>, DOI 10.17487/RFC8252, October 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8252">https://www.rfc-editor.org/info/rfc8252</a>&gt;.

   [<a id="ref-RFC8446">RFC8446</a>]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", <a href="/doc/html/rfc8446">RFC 8446</a>, DOI 10.17487/RFC8446, August 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;.

   [<a id="ref-USASCII">USASCII</a>]  Institute, A.N.S., "Coded Character Set -- 7-bit American
              Standard Code for Information Interchange, ANSI X3.4",
              1986.

   [<a id="ref-W3C.REC-html401-19991224">W3C.REC-html401-19991224</a>]
              Raggett, D., Hors, A., and I. Jacobs, "HTML 4.01
              Specification", World Wide Web Consortium Recommendation
              REC-html401-19991224, 24 December 1999,
              &lt;<a href="http://www.w3.org/TR/1999/REC-html401-19991224">http://www.w3.org/TR/1999/REC-html401-19991224</a>&gt;.






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 75]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-76"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   [<a id="ref-W3C.REC-xml-20081126">W3C.REC-xml-20081126</a>]
              Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and
              F. Yergeau, "Extensible Markup Language (XML) 1.0 (Fifth
              Edition)", World Wide Web Consortium Recommendation REC-
              xml-20081126, 26 November 2008,
              &lt;<a href="http://www.w3.org/TR/2008/REC-xml-20081126">http://www.w3.org/TR/2008/REC-xml-20081126</a>&gt;.

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/14.2.%20%20Informative%20References"></a></body></html><a class="selflink" href="#section-14.2" id="section-14.2">14.2</a>.  Informative References</span>

   [<a id="ref-CSP-2">CSP-2</a>]    "Content Security Policy Level 2", December 2016,
              &lt;<a href="https://www.w3.org/TR/CSP2">https://www.w3.org/TR/CSP2</a>&gt;.

   [<a id="ref-I-D.bradley-oauth-jwt-encoded-state">I-D.bradley-oauth-jwt-encoded-state</a>]
              Bradley, J., Lodderstedt, T., and H. Zandbelt, "Encoding
              claims in the OAuth 2 state parameter using a JWT", Work
              in Progress, Internet-Draft, <a href="/doc/html/draft-bradley-oauth-jwt-encoded-state-09">draft-bradley-oauth-jwt-</a>
              <a href="/doc/html/draft-bradley-oauth-jwt-encoded-state-09">encoded-state-09</a>, 4 November 2018, &lt;<a href="http://www.ietf.org/internet-drafts/draft-bradley-oauth-jwt-encoded-state-09.txt">http://www.ietf.org/</a>
              <a href="http://www.ietf.org/internet-drafts/draft-bradley-oauth-jwt-encoded-state-09.txt">internet-drafts/draft-bradley-oauth-jwt-encoded-state-</a>
              <a href="http://www.ietf.org/internet-drafts/draft-bradley-oauth-jwt-encoded-state-09.txt">09.txt</a>&gt;.

   [<a id="ref-I-D.ietf-oauth-access-token-jwt">I-D.ietf-oauth-access-token-jwt</a>]
              Bertocci, V., "JSON Web Token (JWT) Profile for OAuth 2.0
              Access Tokens", Work in Progress, Internet-Draft, <a href="/doc/html/draft-ietf-oauth-access-token-jwt-07">draft-</a>
              <a href="/doc/html/draft-ietf-oauth-access-token-jwt-07">ietf-oauth-access-token-jwt-07</a>, 27 April 2020,
              &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-access-token-jwt-07.txt">http://www.ietf.org/internet-drafts/draft-ietf-oauth-</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-access-token-jwt-07.txt">access-token-jwt-07.txt</a>&gt;.

   [<a id="ref-I-D.ietf-oauth-browser-based-apps">I-D.ietf-oauth-browser-based-apps</a>]
              Parecki, A. and D. Waite, "OAuth 2.0 for Browser-Based
              Apps", Work in Progress, Internet-Draft, <a href="/doc/html/draft-ietf-oauth-browser-based-apps-06">draft-ietf-oauth-</a>
              <a href="/doc/html/draft-ietf-oauth-browser-based-apps-06">browser-based-apps-06</a>, 5 April 2020, &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-browser-based-apps-06.txt">http://www.ietf.org/</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-browser-based-apps-06.txt">internet-drafts/draft-ietf-oauth-browser-based-apps-</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-browser-based-apps-06.txt">06.txt</a>&gt;.

   [<a id="ref-I-D.ietf-oauth-dpop">I-D.ietf-oauth-dpop</a>]
              Fett, D., Campbell, B., Bradley, J., Lodderstedt, T.,
              Jones, M., and D. Waite, "OAuth 2.0 Demonstration of
              Proof-of-Possession at the Application Layer (DPoP)", Work
              in Progress, Internet-Draft, <a href="/doc/html/draft-ietf-oauth-dpop-01">draft-ietf-oauth-dpop-01</a>, 1
              May 2020, &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-dpop-01.txt">http://www.ietf.org/internet-drafts/draft-ietf-</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-dpop-01.txt">oauth-dpop-01.txt</a>&gt;.

   [<a id="ref-I-D.ietf-oauth-par">I-D.ietf-oauth-par</a>]
              Lodderstedt, T., Campbell, B., Sakimura, N., Tonge, D.,
              and F. Skokan, "OAuth 2.0 Pushed Authorization Requests",
              Work in Progress, Internet-Draft, <a href="/doc/html/draft-ietf-oauth-par-01">draft-ietf-oauth-par-01</a>,
              18 February 2020, &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-par-01.txt">http://www.ietf.org/internet-drafts/</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-par-01.txt">draft-ietf-oauth-par-01.txt</a>&gt;.



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 76]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-77"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   [<a id="ref-I-D.ietf-oauth-rar">I-D.ietf-oauth-rar</a>]
              Lodderstedt, T., Richer, J., and B. Campbell, "OAuth 2.0
              Rich Authorization Requests", Work in Progress, Internet-
              Draft, <a href="/doc/html/draft-ietf-oauth-rar-01">draft-ietf-oauth-rar-01</a>, 19 February 2020,
              &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-rar-01.txt">http://www.ietf.org/internet-drafts/draft-ietf-oauth-rar-</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-rar-01.txt">01.txt</a>&gt;.

   [<a id="ref-I-D.ietf-oauth-token-binding">I-D.ietf-oauth-token-binding</a>]
              Jones, M., Campbell, B., Bradley, J., and W. Denniss,
              "OAuth 2.0 Token Binding", Work in Progress, Internet-
              Draft, <a href="/doc/html/draft-ietf-oauth-token-binding-08">draft-ietf-oauth-token-binding-08</a>, 19 October 2018,
              &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-token-binding-08.txt">http://www.ietf.org/internet-drafts/draft-ietf-oauth-</a>
              <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-token-binding-08.txt">token-binding-08.txt</a>&gt;.

   [<a id="ref-NIST800-63">NIST800-63</a>]
              Burr, W., Dodson, D., Newton, E., Perlner, R., Polk, T.,
              Gupta, S., and E. Nabbus, "NIST Special Publication
              800-63-1, INFORMATION SECURITY", December 2011,
              &lt;<a href="http://csrc.nist.gov/publications/">http://csrc.nist.gov/publications/</a>&gt;.

   [<a id="ref-OMAP">OMAP</a>]     Huff, J., Schlacht, D., Nadalin, A., Simmons, J.,
              Rosenberg, P., Madsen, P., Ace, T., Rickelton-Abdi, C.,
              and B. Boyer, "Online Multimedia Authorization Protocol:
              An Industry Standard for Authorized Access to Internet
              Multimedia Resources", April 2012,
              &lt;<a href="https://www.oatc.us/Standards/Download-Standards">https://www.oatc.us/Standards/Download-Standards</a>&gt;.

   [<a id="ref-OpenID">OpenID</a>]   Sakimora, N., Bradley, J., Jones, M., de Medeiros, B., and
              C. Mortimore, "OpenID Connect Core 1.0", November 2014,
              &lt;<a href="https://openiD.net/specs/openiD-connect-core-1_0.html">https://openiD.net/specs/openiD-connect-core-1_0.html</a>&gt;.

   [<a id="ref-OpenID.Messages">OpenID.Messages</a>]
              Sakimura, N., Bradley, J., Jones, M., de Medeiros, B.,
              Mortimore, C., and E. Jay, "OpenID Connect Messages 1.0",
              June 2012, &lt;<a href="http://openid.net/specs/openid-connect-messages-1_0.html">http://openid.net/specs/openid-connect-</a>
              <a href="http://openid.net/specs/openid-connect-messages-1_0.html">messages-1_0.html</a>&gt;.

   [<a id="ref-owasp_redir">owasp_redir</a>]
              "OWASP Cheat Sheet Series - Unvalidated Redirects and
              Forwards", 2020,
              &lt;<a href="https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/</a>
              <a href="https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html">Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html</a>&gt;.

   [<a id="ref-RFC6265">RFC6265</a>]  Barth, A., "HTTP State Management Mechanism", <a href="/doc/html/rfc6265">RFC 6265</a>,
              DOI 10.17487/RFC6265, April 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 77]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-78"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   [<a id="ref-RFC6819">RFC6819</a>]  Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0
              Threat Model and Security Considerations", <a href="/doc/html/rfc6819">RFC 6819</a>,
              DOI 10.17487/RFC6819, January 2013,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6819">https://www.rfc-editor.org/info/rfc6819</a>&gt;.

   [<a id="ref-RFC7009">RFC7009</a>]  Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, "OAuth
              2.0 Token Revocation", <a href="/doc/html/rfc7009">RFC 7009</a>, DOI 10.17487/RFC7009,
              August 2013, &lt;<a href="https://www.rfc-editor.org/info/rfc7009">https://www.rfc-editor.org/info/rfc7009</a>&gt;.

   [<a id="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              <a href="/doc/html/rfc7230">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.

   [<a id="ref-RFC7235">RFC7235</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", <a href="/doc/html/rfc7235">RFC 7235</a>,
              DOI 10.17487/RFC7235, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7235">https://www.rfc-editor.org/info/rfc7235</a>&gt;.

   [<a id="ref-RFC7519">RFC7519</a>]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", <a href="/doc/html/rfc7519">RFC 7519</a>, DOI 10.17487/RFC7519, May 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7519">https://www.rfc-editor.org/info/rfc7519</a>&gt;.

   [<a id="ref-RFC7591">RFC7591</a>]  Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and
              P. Hunt, "OAuth 2.0 Dynamic Client Registration Protocol",
              <a href="/doc/html/rfc7591">RFC 7591</a>, DOI 10.17487/RFC7591, July 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7591">https://www.rfc-editor.org/info/rfc7591</a>&gt;.

   [<a id="ref-RFC7592">RFC7592</a>]  Richer, J., Ed., Jones, M., Bradley, J., and M. Machulak,
              "OAuth 2.0 Dynamic Client Registration Management
              Protocol", <a href="/doc/html/rfc7592">RFC 7592</a>, DOI 10.17487/RFC7592, July 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7592">https://www.rfc-editor.org/info/rfc7592</a>&gt;.

   [<a id="ref-RFC7636">RFC7636</a>]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key
              for Code Exchange by OAuth Public Clients", <a href="/doc/html/rfc7636">RFC 7636</a>,
              DOI 10.17487/RFC7636, September 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7636">https://www.rfc-editor.org/info/rfc7636</a>&gt;.

   [<a id="ref-RFC7662">RFC7662</a>]  Richer, J., Ed., "OAuth 2.0 Token Introspection",
              <a href="/doc/html/rfc7662">RFC 7662</a>, DOI 10.17487/RFC7662, October 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7662">https://www.rfc-editor.org/info/rfc7662</a>&gt;.

   [<a id="ref-RFC8414">RFC8414</a>]  Jones, M., Sakimura, N., and J. Bradley, "OAuth 2.0
              Authorization Server Metadata", <a href="/doc/html/rfc8414">RFC 8414</a>,
              DOI 10.17487/RFC8414, June 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8414">https://www.rfc-editor.org/info/rfc8414</a>&gt;.





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 78]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-79"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   [<a id="ref-RFC8628">RFC8628</a>]  Denniss, W., Bradley, J., Jones, M., and H. Tschofenig,
              "OAuth 2.0 Device Authorization Grant", <a href="/doc/html/rfc8628">RFC 8628</a>,
              DOI 10.17487/RFC8628, August 2019,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8628">https://www.rfc-editor.org/info/rfc8628</a>&gt;.

   [<a id="ref-RFC8705">RFC8705</a>]  Campbell, B., Bradley, J., Sakimura, N., and T.
              Lodderstedt, "OAuth 2.0 Mutual-TLS Client Authentication
              and Certificate-Bound Access Tokens", <a href="/doc/html/rfc8705">RFC 8705</a>,
              DOI 10.17487/RFC8705, February 2020,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8705">https://www.rfc-editor.org/info/rfc8705</a>&gt;.

   [<a id="ref-RFC8707">RFC8707</a>]  Campbell, B., Bradley, J., and H. Tschofenig, "Resource
              Indicators for OAuth 2.0", <a href="/doc/html/rfc8707">RFC 8707</a>, DOI 10.17487/RFC8707,
              February 2020, &lt;<a href="https://www.rfc-editor.org/info/rfc8707">https://www.rfc-editor.org/info/rfc8707</a>&gt;.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20A.%20%20Augmented%20Backus-Naur%20Form%20%28ABNF%29%20Syntax"></a></body></html><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Augmented Backus-Naur Form (ABNF) Syntax</span>

   This section provides Augmented Backus-Naur Form (ABNF) syntax
   descriptions for the elements defined in this specification using the
   notation of [<a href="/doc/html/rfc5234" title='"Augmented BNF for Syntax Specifications: ABNF"'>RFC5234</a>].  The ABNF below is defined in terms of Unicode
   code points [<a href="#ref-W3C.REC-xml-20081126">W3C.REC-xml-20081126</a>]; these characters are typically
   encoded in UTF-8.  Elements are presented in the order first defined.

   Some of the definitions that follow use the "URI-reference"
   definition from [<a href="/doc/html/rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>].

   Some of the definitions that follow use these common definitions:

   VSCHAR     = %x20-7E
   NQCHAR     = %x21 / %x23-5B / %x5D-7E
   NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
   UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /
                       %xE000-FFFD / %x10000-10FFFF

   (The UNICODECHARNOCRLF definition is based upon the Char definition
   in Section 2.2 of [<a href="#ref-W3C.REC-xml-20081126">W3C.REC-xml-20081126</a>], but omitting the Carriage
   Return and Linefeed characters.)

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.1.%20%20%22client_id%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.1" id="appendix-A.1">A.1</a>.  "client_id" Syntax</span>

   The "client_id" element is defined in <a href="#section-2.3.1">Section 2.3.1</a>:

   client-id     = *VSCHAR

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.2.%20%20%22client_secret%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.2" id="appendix-A.2">A.2</a>.  "client_secret" Syntax</span>

   The "client_secret" element is defined in <a href="#section-2.3.1">Section 2.3.1</a>:




<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 79]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-80"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   client-secret = *VSCHAR

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.3.%20%20%22response_type%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.3" id="appendix-A.3">A.3</a>.  "response_type" Syntax</span>

   The "response_type" element is defined in <a href="#section-3.1.1">Section 3.1.1</a> and
   <a href="#section-8.4">Section 8.4</a>:

   response-type = response-name *( SP response-name )
   response-name = 1*response-char
   response-char = "_" / DIGIT / ALPHA

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.4.%20%20%22scope%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.4" id="appendix-A.4">A.4</a>.  "scope" Syntax</span>

   The "scope" element is defined in <a href="#section-3.3">Section 3.3</a>:

    scope       = scope-token *( SP scope-token )
    scope-token = 1*NQCHAR

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.5.%20%20%22state%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.5" id="appendix-A.5">A.5</a>.  "state" Syntax</span>

   The "state" element is defined in <a href="#section-4.1.1">Section 4.1.1</a>, <a href="#section-4.1.2">Section 4.1.2</a>, and
   <a href="#section-4.1.2.1">Section 4.1.2.1</a>:

    state      = 1*VSCHAR

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.6.%20%20%22redirect_uri%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.6" id="appendix-A.6">A.6</a>.  "redirect_uri" Syntax</span>

   The "redirect_uri" element is defined in <a href="#section-4.1.1">Section 4.1.1</a>, and
   <a href="#section-4.1.3">Section 4.1.3</a>:

    redirect-uri      = URI-reference

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.7.%20%20%22error%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.7" id="appendix-A.7">A.7</a>.  "error" Syntax</span>

   The "error" element is defined in Sections <a href="#section-4.1.2.1">Section 4.1.2.1</a>,
   <a href="#section-5.2">Section 5.2</a>, 7.2, and 8.5:

    error             = 1*NQSCHAR

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.8.%20%20%22error_description%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.8" id="appendix-A.8">A.8</a>.  "error_description" Syntax</span>

   The "error_description" element is defined in Sections
   <a href="#section-4.1.2.1">Section 4.1.2.1</a>, <a href="#section-5.2">Section 5.2</a>, and <a href="#section-7.3">Section 7.3</a>:

    error-description = 1*NQSCHAR






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 80]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-81"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.9.%20%20%22error_uri%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.9" id="appendix-A.9">A.9</a>.  "error_uri" Syntax</span>

   The "error_uri" element is defined in Sections <a href="#section-4.1.2.1">Section 4.1.2.1</a>,
   <a href="#section-5.2">Section 5.2</a>, and 7.2:

    error-uri         = URI-reference

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.10.%20%20%22grant_type%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.10" id="appendix-A.10">A.10</a>.  "grant_type" Syntax</span>

   The "grant_type" element is defined in Sections <a href="#section-4.1.3">Section 4.1.3</a>,
   <a href="#section-4.2.3">Section 4.2.3</a>, <a href="#section-4.2.2">Section 4.2.2</a>, <a href="#section-4.3">Section 4.3</a>, and <a href="#section-6">Section 6</a>:

    grant-type = grant-name / URI-reference
    grant-name = 1*name-char
    name-char  = "-" / "." / "_" / DIGIT / ALPHA

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.11.%20%20%22code%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.11" id="appendix-A.11">A.11</a>.  "code" Syntax</span>

   The "code" element is defined in <a href="#section-4.1.3">Section 4.1.3</a>:

    code       = 1*VSCHAR

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.12.%20%20%22access_token%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.12" id="appendix-A.12">A.12</a>.  "access_token" Syntax</span>

   The "access_token" element is defined in <a href="#section-4.2.3">Section 4.2.3</a> and
   <a href="#section-5.1">Section 5.1</a>:

    access-token = 1*VSCHAR

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.13.%20%20%22token_type%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.13" id="appendix-A.13">A.13</a>.  "token_type" Syntax</span>

   The "token_type" element is defined in <a href="#section-5.1">Section 5.1</a>, and <a href="#section-8.1">Section 8.1</a>:

    token-type = type-name / URI-reference
    type-name  = 1*name-char
    name-char  = "-" / "." / "_" / DIGIT / ALPHA

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.14.%20%20%22expires_in%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.14" id="appendix-A.14">A.14</a>.  "expires_in" Syntax</span>

   The "expires_in" element is defined in <a href="#section-5.1">Section 5.1</a>:

    expires-in = 1*DIGIT

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.15.%20%20%22refresh_token%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.15" id="appendix-A.15">A.15</a>.  "refresh_token" Syntax</span>

   The "refresh_token" element is defined in <a href="#section-5.1">Section 5.1</a> and <a href="#section-6">Section 6</a>:

    refresh-token = 1*VSCHAR



<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 81]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-82"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.16.%20%20Endpoint%20Parameter%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.16" id="appendix-A.16">A.16</a>.  Endpoint Parameter Syntax</span>

   The syntax for new endpoint parameters is defined in <a href="#section-8.2">Section 8.2</a>:

    param-name = 1*name-char
    name-char  = "-" / "." / "_" / DIGIT / ALPHA

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.17.%20%20%22code_verifier%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.17" id="appendix-A.17">A.17</a>.  "code_verifier" Syntax</span>

   ABNF for "code_verifier" is as follows.

   code-verifier = 43*128unreserved
   unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
   ALPHA = %x41-5A / %x61-7A
   DIGIT = %x30-39

<span class="h3"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/A.18.%20%20%22code_challenge%22%20Syntax"></a></body></html><a class="selflink" href="#appendix-A.18" id="appendix-A.18">A.18</a>.  "code_challenge" Syntax</span>

   ABNF for "code_challenge" is as follows.

   code-challenge = 43*128unreserved
   unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
   ALPHA = %x41-5A / %x61-7A
   DIGIT = %x30-39

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20B.%20%20Use%20of%20application/x-www-form-urlencoded%20Media%20Type"></a></body></html><a class="selflink" href="#appendix-B" id="appendix-B">Appendix B</a>.  Use of application/x-www-form-urlencoded Media Type</span>

   At the time of publication of this specification, the "application/x-
   www-form-urlencoded" media type was defined in Section 17.13.4 of
   [<a href="#ref-W3C.REC-html401-19991224">W3C.REC-html401-19991224</a>] but not registered in the IANA MIME Media
   Types registry (<a href="http://www.iana.org/assignments/media-types">http://www.iana.org/assignments/media-types</a>
   (<a href="http://www.iana.org/assignments/media-types">http://www.iana.org/assignments/media-types</a>)).  Furthermore, that
   definition is incomplete, as it does not consider non-US-ASCII
   characters.

   To address this shortcoming when generating payloads using this media
   type, names and values <em>MUST</em> be encoded using the UTF-8 character
   encoding scheme [<a href="/doc/html/rfc3629" title='"UTF-8, a transformation format of ISO 10646"'>RFC3629</a>] first; the resulting octet sequence then
   needs to be further encoded using the escaping rules defined in
   [<a href="#ref-W3C.REC-html401-19991224">W3C.REC-html401-19991224</a>].

   When parsing data from a payload using this media type, the names and
   values resulting from reversing the name/value encoding consequently
   need to be treated as octet sequences, to be decoded using the UTF-8
   character encoding scheme.






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 82]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-83"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   For example, the value consisting of the six Unicode code points (1)
   U+0020 (SPACE), (2) U+0025 (PERCENT SIGN), (3) U+0026 (AMPERSAND),
   (4) U+002B (PLUS SIGN), (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO
   SIGN) would be encoded into the octet sequence below (using
   hexadecimal notation):

   20 25 26 2B C2 A3 E2 82 AC

   and then represented in the payload as:

   +%25%26%2B%C2%A3%E2%82%AC

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20C.%20%20Extensions"></a></body></html><a class="selflink" href="#appendix-C" id="appendix-C">Appendix C</a>.  Extensions</span>

   Below is a list of well-established extensions at the time of
   publication:

   *  [<a href="/doc/html/rfc8628" title='"OAuth 2.0 Device Authorization Grant"'>RFC8628</a>]: OAuth 2.0 Device Authorization Grant

      -  The Device Authorization Grant (formerly known as the Device
         Flow) is an extension that enables devices with no browser or
         limited input capability to obtain an access token.  This is
         commonly used by smart TV apps, or devices like hardware video
         encoders that can stream video to a streaming video service.

   *  [<a href="/doc/html/rfc8414" title='"OAuth 2.0 Authorization Server Metadata"'>RFC8414</a>]: Authorization Server Metadata

      -  Authorization Server Metadata (also known as OAuth Discovery)
         defines an endpoint clients can use to look up the information
         needed to interact with a particular OAuth server, such as the
         location of the authorization and token endpoints and the
         supported grant types.

   *  [<a href="/doc/html/rfc8707" title='"Resource Indicators for OAuth 2.0"'>RFC8707</a>]: Resource Indicators

      -  Provides a way for the client to explicitly signal to the
         authorization server where it intends to use the access token
         it is requesting.

   *  [<a href="/doc/html/rfc7591" title='"OAuth 2.0 Dynamic Client Registration Protocol"'>RFC7591</a>]: Dynamic Client Registration

      -  Dynamic Client Registration provides a mechanism for
         programmatically registering clients with an authorization
         server.

   *  [<a href="/doc/html/rfc7592" title='"OAuth 2.0 Dynamic Client Registration Management Protocol"'>RFC7592</a>]: Dynamic Client Management





<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 83]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-84"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


      -  Dynamic Client Management provides a mechanism for updating
         dynamically registered client information.

   *  [<a href="#ref-I-D.ietf-oauth-access-token-jwt">I-D.ietf-oauth-access-token-jwt</a>]: JSON Web Token (JWT) Profile
      for OAuth 2.0 Access Tokens

      -  This specification defines a profile for issuing OAuth access
         tokens in JSON web token (JWT) format.

   *  [<a href="/doc/html/rfc8705" title='"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"'>RFC8705</a>]: Mutual TLS

      -  Mutual TLS describes a mechanism of binding access tokens and
         refresh tokens to the clients they were issued to, as well as a
         client authentication mechanism, via TLS certificate
         authentication.

   *  [<a href="/doc/html/rfc7662" title='"OAuth 2.0 Token Introspection"'>RFC7662</a>]: Token Introspection

      -  The Token Introspection extension defines a mechanism for
         resource servers to obtain information about access tokens.

   *  [<a href="/doc/html/rfc7009" title='"OAuth 2.0 Token Revocation"'>RFC7009</a>]: Token Revocation

      -  The Token Revocation extension defines a mechanism for clients
         to indicate to the authorization server that an access token is
         no longer needed.

   *  [<a href="#ref-I-D.ietf-oauth-par">I-D.ietf-oauth-par</a>]: Pushed Authorization Requests

      -  The Pushed Authorization Requsts extension describes a
         technique of initiating an OAuth flow from the back channel,
         providing better security and more flexibility for building
         complex authorization requests.

   *  [<a href="#ref-I-D.ietf-oauth-rar">I-D.ietf-oauth-rar</a>]: Rich Authorization Requests

      -  Rich Authorization Requests specifies a new parameter
         "authorization_details" that is used to carry fine-grained
         authorization data in the OAuth authorization request.

<span class="h2"><html><body><a class="dashAnchor" name="//apple_ref/cpp/Shortcut/Appendix%20D.%20%20Acknowledgements"></a></body></html><a class="selflink" href="#appendix-D" id="appendix-D">Appendix D</a>.  Acknowledgements</span>

   TBD

Authors' Addresses






<span class="grey">Hardt, et al.            Expires 6 January 2021                [Page 84]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-85"></span>
<span class="grey">Internet-Draft    The OAuth 2.1 Authorization Framework        July 2020</span>


   Dick Hardt
   SignIn.Org

   Email: dick.hardt@gmail.com


   Aaron Parecki
   Okta

   Email: aaron@parecki.com
   URI:   <a href="https://aaronparecki.com">https://aaronparecki.com</a>


   Torsten Lodderstedt
   yes.com

   Email: torsten@lodderstedt.net


































Hardt, et al.            Expires 6 January 2021                [Page 85]
</pre>
</div>
</div>
</div>
<script>$(".visible-nojs").removeClass("visible-nojs");</script>
<script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
<script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>
</body>
</html>
