<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    draft-ietf-oauth-v2-http-mac-05
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.38.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.38.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-oauth-v2-http-mac/">
  <meta name="description" content="OAuth 2.0 Message Authentication Code (MAC) Tokens (Internet-Draft, 2014)">
  <script src="https://www.ietf.org/lib/dt/7.38.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.38.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.38.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgred"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.ietf.org/archive/id/draft-ietf-oauth-v2-http-mac-05.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.ietf.org/archive/id/draft-ietf-oauth-v2-http-mac-05.xml" title="XML source for this document">xml</a>|<a href="https://tools.ietf.org/pdf/draft-ietf-oauth-v2-http-mac-05.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/draft-ietf-oauth-v2-http-mac/05/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/draft-ietf-oauth-v2-http-mac/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/oauth/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-oauth-v2-http-mac@ietf.org?subject=draft-ietf-oauth-v2-http-mac" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-oauth-v2-http-mac-05.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-oauth-v2-http-mac-05.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-oauth-v2-http-mac-05.txt" title="Run an idnits check of this document">Nits</a>]

Versions: <a href="/doc/html/draft-ietf-oauth-v2-http-mac-00">00</a> <a href="/doc/html/draft-ietf-oauth-v2-http-mac-01">01</a> <a href="/doc/html/draft-ietf-oauth-v2-http-mac-02">02</a> <a href="/doc/html/draft-ietf-oauth-v2-http-mac-03">03</a> <a href="/doc/html/draft-ietf-oauth-v2-http-mac-04">04</a> <a href="/doc/html/draft-ietf-oauth-v2-http-mac-05"><b>05</b></a>                                             </pre>
      </div>
    

    <div class="draftcontent">
    <pre>OAuth                                                          J. Richer
Internet-Draft                                     The MITRE Corporation
Intended status: Standards Track                                W. Mills
Expires: July 19, 2014                                       Yahoo! Inc.
                                                      H. Tschofenig, Ed.

                                                                 P. Hunt
                                                      Oracle Corporation
                                                        January 15, 2014


           <span class="h1">OAuth 2.0 Message Authentication Code (MAC) Tokens</span>
                  <span class="h1">draft-ietf-oauth-v2-http-mac-05.txt</span>

Abstract

   This specification describes how to use MAC Tokens in HTTP requests
   to access OAuth 2.0 protected resources.  An OAuth client willing to
   access a protected resource needs to demonstrate possession of a
   cryptographic key by using it with a keyed message digest function to
   the request.

   The document also defines a key distribution protocol for obtaining a
   fresh session key.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="/doc/html/bcp78">BCP 78</a> and <a href="/doc/html/bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as &quot;work in progress.&quot;

   This Internet-Draft will expire on July 19, 2014.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.





<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Architecture  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-4">4</a>.  Key Distribution  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-4.1">4.1</a>.  Session Key Transport to Client . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-4.2">4.2</a>.  Session Key Transport to Resource Server  . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-5">5</a>.  The Authenticator . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-5.1">5.1</a>.  The Authenticator . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-5.2">5.2</a>.  MAC Input String  . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-5.3">5.3</a>.  Keyed Message Digest Algorithms . . . . . . . . . . . . .  <a href="#page-13">13</a>
       <a href="#section-5.3.1">5.3.1</a>.  hmac-sha-1  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
       <a href="#section-5.3.2">5.3.2</a>.  hmac-sha-256  . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-6">6</a>.  Verifying the Authenticator . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-6.1">6.1</a>.  Timestamp Verification  . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-6.2">6.2</a>.  Error Handling  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-7">7</a>.  Example . . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-8">8</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-8.1">8.1</a>.  Key Distribution  . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     8.2.  Offering Confidentiality Protection for Access to
           Protected Resources . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-8.3">8.3</a>.  Authentication of Resource Servers  . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-8.4">8.4</a>.  Plaintext Storage of Credentials  . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-8.5">8.5</a>.  Entropy of Session Keys . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-8.6">8.6</a>.  Denial of Service / Resource Exhaustion Attacks . . . . .  <a href="#page-18">18</a>
     <a href="#section-8.7">8.7</a>.  Timing Attacks  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-8.8">8.8</a>.  CSRF Attacks  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-8.9">8.9</a>.  Protecting HTTP Header Fields . . . . . . . . . . . . . .  <a href="#page-19">19</a>
   <a href="#section-9">9</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-9.1">9.1</a>.  JSON Web Token Claims . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-9.2">9.2</a>.  MAC Token Algorithm Registry  . . . . . . . . . . . . . .  <a href="#page-20">20</a>
       <a href="#section-9.2.1">9.2.1</a>.  Registration Template . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
       <a href="#section-9.2.2">9.2.2</a>.  Initial Registry Contents . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-9.3">9.3</a>.  OAuth Access Token Type Registration  . . . . . . . . . .  <a href="#page-21">21</a>
       <a href="#section-9.3.1">9.3.1</a>.  The &quot;mac&quot; OAuth Access Token Type . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-9.4">9.4</a>.  OAuth Parameters Registration . . . . . . . . . . . . . .  <a href="#page-22">22</a>
       <a href="#section-9.4.1">9.4.1</a>.  The &quot;mac_key&quot; OAuth Parameter . . . . . . . . . . . .  <a href="#page-22">22</a>



<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


       <a href="#section-9.4.2">9.4.2</a>.  The &quot;mac_algorithm&quot; OAuth Parameter . . . . . . . . .  <a href="#page-22">22</a>
       <a href="#section-9.4.3">9.4.3</a>.  The &quot;kid&quot; OAuth Parameter . . . . . . . . . . . . . .  <a href="#page-22">22</a>
   <a href="#section-10">10</a>. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-23">23</a>
   <a href="#section-11">11</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-23">23</a>
     <a href="#section-11.1">11.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-23">23</a>
     <a href="#section-11.2">11.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>
   <a href="#appendix-A">Appendix A</a>.  Background Information . . . . . . . . . . . . . . .  <a href="#page-26">26</a>
     <a href="#appendix-A.1">A.1</a>.  Security and Privacy Threats  . . . . . . . . . . . . . .  <a href="#page-26">26</a>
     <a href="#appendix-A.2">A.2</a>.  Threat Mitigation . . . . . . . . . . . . . . . . . . . .  <a href="#page-27">27</a>
       <a href="#appendix-A.2.1">A.2.1</a>.  Confidentiality Protection  . . . . . . . . . . . . .  <a href="#page-28">28</a>
       <a href="#appendix-A.2.2">A.2.2</a>.  Sender Constraint . . . . . . . . . . . . . . . . . .  <a href="#page-28">28</a>
       <a href="#appendix-A.2.3">A.2.3</a>.  Key Confirmation  . . . . . . . . . . . . . . . . . .  <a href="#page-29">29</a>
       <a href="#appendix-A.2.4">A.2.4</a>.  Summary . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-30">30</a>
     <a href="#appendix-A.3">A.3</a>.  Requirements  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
     <a href="#appendix-A.4">A.4</a>.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-35">35</a>
       <a href="#appendix-A.4.1">A.4.1</a>.  Access to an &#x27;Unprotected&#x27; Resource . . . . . . . . .  <a href="#page-35">35</a>
       <a href="#appendix-A.4.2">A.4.2</a>.  Offering Application Layer End-to-End Security  . . .  <a href="#page-36">36</a>
       A.4.3.  Preventing Access Token Re-Use by the Resource Server  36
       <a href="#appendix-A.4.4">A.4.4</a>.  TLS Channel Binding Support . . . . . . . . . . . . .  <a href="#page-36">36</a>
   Authors&#x27; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-37">37</a>

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   This specification describes how to use MAC Tokens in HTTP requests
   and responses to access protected resources via the OAuth 2.0
   protocol [<a href="/doc/html/rfc6749" title="&quot;The OAuth 2.0 Authorization Framework&quot;">RFC6749</a>].  An OAuth client willing to access a protected
   resource needs to demonstrate possession of a symmetric key by using
   it with a keyed message digest function to the request.  The keyed
   message digest function is computed over a flexible set of parameters
   from the HTTP message.

   The MAC Token mechanism requires the establishment of a shared
   symmetric key between the client and the resource server.  This
   specification defines a three party key distribution protocol to
   dynamically distribute this session key from the authorization server
   to the client and the resource server.

   The design goal for this mechanism is to support the requirements
   outlined in <a href="#appendix-A">Appendix A</a>. In particular, when a server uses this
   mechanism, a passive attacker will be unable to use an eavesdropped
   access token exchanged between the client and the resource server.
   In addition, this mechanism helps secure the access token against
   leakage when sent over a secure channel to the wrong resource server
   if the client provided information about the resource server it wants
   to interact with in the request to the authorization server.

   Since a keyed message digest only provides integrity protection and
   data-origin authentication confidentiality protection can only be



<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   added by the usage of Transport Layer Security (TLS).  This
   specification provides a mechanism for channel binding is included to
   ensure that a TLS channel is not terminated prematurely and indeed
   covers the entire end-to-end communication.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Terminology</span>

   The key words &#x27;MUST&#x27;, &#x27;MUST NOT&#x27;, &#x27;REQUIRED&#x27;, &#x27;SHALL&#x27;, &#x27;SHALL NOT&#x27;,
   &#x27;SHOULD&#x27;, &#x27;SHOULD NOT&#x27;, &#x27;RECOMMENDED&#x27;, &#x27;MAY&#x27;, and &#x27;OPTIONAL&#x27; in this
   specification are to be interpreted as described in [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

   This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [<a href="#ref-I-D.ietf-httpbis-p1-messaging">I-D.ietf-httpbis-p1-messaging</a>].  Additionally, the
   following rules are included from [<a href="/doc/html/rfc2617" title="&quot;HTTP Authentication: Basic and Digest Access Authentication&quot;">RFC2617</a>]: auth-param.

   Session Key:

      The terms mac key, session key, and symmetric key are used
      interchangeably and refer to the cryptographic keying material
      established between the client and the resource server.  This
      temporary key used between the client and the resource server,
      with a lifetime limited to the lifetime of the access token.  This
      session key is generated by the authorization server.


   Authenticator:

      A record containing information that can be shown to have been
      recently generated using the session key known only by the client
      and the resource server.


   Message Authentication Code (MAC):

      Message authentication codes (MACs) are hash functions that take
      two distinct inputs, a message and a secret key, and produce a
      &amp;#64257;xed-size output.  The design goal is that it is
      practically infeasible to produce the same output without
      knowledge of the key.  The terms keyed message digest functions
      and MACs are used interchangeably.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Architecture</span>

   The architecture of the proposal described in this document assumes
   that the authorization server acts as a trusted third party that
   provides session keys to clients and to resource servers.  These
   session keys are used by the client and the resource server as input
   to a MAC.  In order to obtain the session key the client interacts



<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   with the authorization server as part of the a normal grant exchange.
   This is shown in an abstract way in Figure 1.  Together with the
   access token the authorization server returns a session key (in the
   mac_key parameter) and several other parameters.  The resource server
   obtains the session key via the access token.  Both of these two key
   distribution steps are described in more detail in <a href="#section-4">Section 4</a>.


                        +---------------+
                       ^|               | AS-RS Key
                     // | Authorization |&lt;*******
                    /   | Server        |       *
                  //    |               |       *
                 /      |               |       *
          (I)  //      /+---------------+       *
    Access    /      //                         *
    Token    /      /                           *
    Request//     //  (II) Access Token         *
          /      /         +Session Key (SK)    *
        //     //                               *
       /      v                                 v
     +-----------+                       +------------+
     |           |                       |            |
     |           |                       | Resource   |
     | Client    |                       | Server     |
     |           |                       |            |
     |           |                       |            |
     +-----------+                       +------------+

     ****: Out-of-Band Long-Term Key Establishment
     ----: Dynamic Session Key Distribution


      Figure 1: Architecture: Interaction between the Client and the
                           Authorization Server.

   Once the client has obtained the necessary access token and the
   session key (including parameters) it can start to interact with the
   resource server.  To demonstrate possession of the session key it
   computes a MAC and adds various fields to the outgoing request
   message.  We call this structure the &quot;Authenticator&quot;.  The server
   evaluates the request, includes an Authenticator and returns a
   response back to the client.  Since the access token is valid for a
   period of time the resource server may decide to cache it so that it
   does not need to be provided in every request from the client.  This
   interaction is shown in Figure 2.





<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


                      +---------------+
                      |               |
                      | Authorization |
                      | Server        |
                      |               |
                      |               |
                      +---------------+






   +-----------+  Authenticator (a)    +------------+
   |           |----------------------&gt;|            |
   |           |  [+Access Token]      | Resource   |
   | Client    |                       | Server     |
   |           |  Authenticator (b)    |            |
   |           |&lt;----------------------|            |
   +-----------+                       +------------+

        ^                                    ^
        |                                    |
        |                                    |
       SK                                   SK
       +param                               +param


      Figure 2: Architecture: Interaction between the Client and the
                             Resource Server.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Key Distribution</span>

   For this scheme to function a session key must be available to the
   client and the resource server, which is then used as a parameter in
   the keyed message digest function.  This document describes the key
   distribution mechanism that uses the authorization server as a
   trusted third party, which ensures that the session key is
   transported from the authorization server to the client and the
   resource server.

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>.  Session Key Transport to Client</span>

   Authorization servers issue MAC Tokens based on requests from
   clients.  The request MUST include the audience parameter defined in
   [<a href="#ref-I-D.tschofenig-oauth-audience">I-D.tschofenig-oauth-audience</a>], which indicates the resource server
   the client wants to interact with.  This specification assumes use of
   the &#x27;Authorization Code&#x27; grant.  If the request is processed



<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   successfully by the authorization server it MUST return at least the
   following parameters to the client:

   kid

         The name of the key (key id), which is an identifier generated
         by the resource server.  It is RECOMMENDED that the
         authorization server generates this key id by computing a hash
         over the access_token, for example using SHA-1, and to encode
         it in a base64 format.



   access_token

         The OAuth 2.0 access token.



   mac_key

         The session key generated by the authorization server.  Note
         that the lifetime of the session key is equal to the lifetime
         of the access token.



   mac_algorithm

         The MAC algorithm used to calculate the request MAC.  The value
         MUST be one of &quot;hmac-sha-1&quot;, &quot;hmac-sha-256&quot;, or a registered
         extension algorithm name as described in <a href="#section-9.2">Section 9.2</a>.  The
         authorization server is assumed to know the set of algorithms
         supported by the client and the resource server.  It selects an
         algorithm that meets the security policies and is supported by
         both nodes.

   For example:













<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


     HTTP/1.1 200 OK
     Content-Type: application/json
     Cache-Control: no-store

     {
       &quot;access_token&quot;:
   &quot;eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDK0hTMjU2In0.
   pwaFh7yJPivLjjPkzC-GeAyHuy7AinGcS51AZ7TXnwkC80Ow1aW47kcT_UV54ubo
   nONbeArwOVuR7shveXnwPmucwrk_3OCcHrCbE1HR-Jfme2mF_WR3zUMcwqmU0RlH
   kwx9txo_sKRasjlXc8RYP-evLCmT1XRXKjtY5l44Gnh0A84hGvVfMxMfCWXh38hi
   2h8JMjQHGQ3mivVui5lbf-zzb3qXXxNO1ZYoWgs5tP1-T54QYc9Bi9wodFPWNPKB
   kY-BgewG-Vmc59JqFeprk1O08qhKQeOGCWc0WPC_n_LIpGWH6spRm7KGuYdgDMkQ
   bd4uuB0uPPLx_euVCdrVrA.
   AxY8DCtDaGlsbGljb3RoZQ.
   7MI2lRCaoyYx1HclVXkr8DhmDoikTmOp3IdEmm4qgBThFkqFqOs3ivXLJTku4M0f
   laMAbGG_X6K8_B-0E-7ak-Olm_-_V03oBUUGTAc-F0A.
   OwWNxnC-BMEie-GkFHzVWiNiaV3zUHf6fCOGTwbRckU&quot;,
       &quot;token_type&quot;:&quot;mac&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;8xLOxBtZp8&quot;,
       &quot;kid&quot;:&quot;22BIjxU93h/IgwEb4zCRu5WF37s=&quot;,
       &quot;mac_key&quot;:&quot;adijq39jdlaska9asud&quot;,
       &quot;mac_algorithm&quot;:&quot;hmac-sha-256&quot;
     }


<span class="h3"><a class="selflink" id="section-4.2" href="#section-4.2">4.2</a>.  Session Key Transport to Resource Server</span>

   The transport of the mac_key from the authorization server to the
   resource server is accomplished by conveying the encrypting mac_key
   inside the access token.  At the time of writing only one
   standardized format for carrying the access token is defined: the
   JSON Web Token (JWT) [<a href="#ref-I-D.ietf-oauth-json-web-token">I-D.ietf-oauth-json-web-token</a>].  Note that the
   header of the JSON Web Encryption (JWE) structure
   [<a href="#ref-I-D.ietf-jose-json-web-encryption">I-D.ietf-jose-json-web-encryption</a>], which is a JWT with encrypted
   content, MUST contain a key id (kid) in the header to allow the
   resource server to select the appropriate keying material for
   decryption.  This keying material is a symmetric or an asymmetric
   long-term key established between the resource server and the
   authorization server, as shown in Figure 1 as AS-RS key.  The
   establishment of this long-term key is outside the scope of this
   specification.

   This document defines two new claims to be carried in the JWT:
   mac_key, kid.  These two parameters match the content of the mac_key
   and the kid conveyed to the client, as shown in <a href="#section-4.1">Section 4.1</a>.

   kid



<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


         The name of the key (key id), which is an identifier generated
         by the resource server.



   mac_key

         The session key generated by the authorization server.



   This example shows a JWT claim set without header and without
   encryption:


   {&quot;iss&quot;:&quot;authorization-server.example.com&quot;,
   &quot;exp&quot;:1300819380,
   &quot;kid&quot;:&quot;22BIjxU93h/IgwEb4zCRu5WF37s=&quot;,
   &quot;mac_key&quot;:&quot;adijq39jdlaska9asud&quot;,
   &quot;aud&quot;:&quot;apps.example.com&quot;
   }


      QUESTIONS: An alternative to the use of a JWT to convey the access
      token with the encrypted mac_key is use the token introspect
      [<a href="#ref-I-D.richer-oauth-introspection">I-D.richer-oauth-introspection</a>].  What mechanism should be
      described?  What should be mandatory to implement?

      QUESTIONS: The above description assumes that the entire access
      token is encrypted but it would be possible to only encrypt the
      session key and to only apply integrity protection to other
      fields.  Is this desirable?

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  The Authenticator</span>

   To access a protected resource the client must be in the possession
   of a valid set of session key provided by the authorization server.
   The client constructs the authenticator, as described in <a href="#section-5.1">Section 5.1</a>.

<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a>.  The Authenticator</span>

   The client constructs the authenticator and adds the resulting fields
   to the HTTP request using the &quot;Authorization&quot; request header field.
   The &quot;Authorization&quot; request header field uses the framework defined
   by [<a href="/doc/html/rfc2617" title="&quot;HTTP Authentication: Basic and Digest Access Authentication&quot;">RFC2617</a>].  To include the authenticator in a subsequent response
   from the authorization server to the client the WWW-Authenticate
   header is used.  For further exchanges a new, yet-to-be-defined
   header will be used.



<span class="grey">Richer, et al.            Expires July 19, 2014                 [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


     authenticator  = &quot;MAC&quot; 1*SP #params

     params         = id / ts / seq-nr / access_token / mac / h / cb

     kid            = &quot;kid&quot; &quot;=&quot; string-value
     ts             = &quot;ts&quot; &quot;=&quot; ( &lt;&quot;&gt; timestamp &lt;&quot;&gt; ) / timestamp
     seq-nr         = &quot;seq-nr&quot; &quot;=&quot; string-value
     access_token   = &quot;access_token&quot; &quot;=&quot; b64token
     mac            = &quot;mac&quot; &quot;=&quot; string-value
     cb             = &quot;cb&quot; &quot;=&quot; token
     h              = &quot;h&quot; &quot;=&quot; h-tag
     h-tag          = %x68 [FWS] &quot;=&quot; [FWS] hdr-name
                      *( [FWS] &quot;:&quot; [FWS] hdr-name )
     hdr-name       = token

     timestamp      = 1*DIGIT
     string-value   = ( &lt;&quot;&gt; plain-string &lt;&quot;&gt; ) / plain-string
     plain-string   = 1*( %x20-21 / %x23-5B / %x5D-7E )

     b64token       = 1*( ALPHA / DIGIT /
                          &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;


   The header attributes are set as follows:

   kid

         REQUIRED.  The key identifier.



   ts

         REQUIRED.  The timestamp.  The value MUST be a positive integer
         set by the client when making each request to the number of
         milliseconds since 1 January 1970.

         The JavaScript getTime() function or the Java
         System.currentTimeMillis() function, for example, produce such
         a timestamp.



   seq-nr

         OPTIONAL.  This optional field includes the initial sequence
         number to be used by the messages exchange between the client
         and the server when the replay protection provided by the



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


         timestamp is not sufficient enough replay protection.  This
         field specifies the initial sequence number for messages from
         the client to the server.  When included in the response
         message, the initial sequence number is that for messages from
         the server to the client.  Sequence numbers fall in the range 0
         through 2^64 - 1 and wrap to zero following the value 2^64 - 1.

         The initial sequence number SHOULD be random and uniformly
         distributed across the full space of possible sequence numbers,
         so that it cannot be guessed by an attacker and so that it and
         the successive sequence numbers do not repeat other sequences.
         In the event that more than 2^64 messages are to be generated
         in a series of messages, rekeying MUST be performed before
         sequence numbers are reused.  Rekeying requires a new access
         token to be requested.



   access_token

         CONDITIONAL.  The access_token MUST be included in the first
         request from the client to the server but MUST NOT be included
         in a subsequent response and in a further protocol exchange.



   mac

         REQUIRED.  The result of the keyed message digest computation,
         as described in <a href="#section-5.3">Section 5.3</a>.



   cb

         OPTIONAL.  This field carries the channel binding value from
         <a href="/doc/html/rfc5929">RFC 5929</a> [<a href="/doc/html/rfc5929" title="&quot;Channel Bindings for TLS&quot;">RFC5929</a>] in the following format: cb= channel-
         binding-type &quot;:&quot; channel-binding-content.  <a href="/doc/html/rfc5929">RFC 5929</a> offers two
         types of channel bindings for TLS.  First, there is the &#x27;tls-
         server-end-point&#x27; channel binding, which uses a hash of the TLS
         server&#x27;s certificate as it appears, octet for octet, in the
         server&#x27;s Certificate message.  The second channel binding is
         &#x27;tls-unique&#x27;, which uses the first TLS Finished message sent
         (note: the Finished struct, not the TLS record layer message
         containing it) in the most recent TLS handshake of the TLS
         connection being bound to.  As an example, the cb field may
         contain cb=tls-unique:9382c93673d814579ed1610d3




<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   h

         OPTIONAL.  This field contains a colon-separated list of header
         field names that identify the header fields presented to the
         keyed message digest algorithm.  If the &#x27;h&#x27; header field is
         absent then the following value is set by default: h=&quot;host&quot;.
         The field MUST contain the complete list of header fields in
         the order presented to the keyed message digest algorithm.  The
         field MAY contain names of header fields that do not exist at
         the time of computing the keyed message digest; nonexistent
         header fields do not contribute to the keyed message digest
         computation (that is, they are treated as the null input,
         including the header field name, the separating colon, the
         header field value, and any CRLF terminator).  By including
         header fields that do not actually exist in the keyed message
         digest computation, the client can allow the resource server to
         detect insertion of those header fields by intermediaries.
         However, since the client cannot possibly know what header
         fields might be defined in the future, this mechanism cannot be
         used to prevent the addition of any possible unknown header
         fields.  The field MAY contain multiple instances of a header
         field name, meaning multiple occurrences of the corresponding
         header field are included in the header hash.  The field MUST
         NOT include the mac header field.  Folding whitespace (FWS) MAY
         be included on either side of the colon separator.  Header
         field names MUST be compared against actual header field names
         in a case-insensitive manner.  This list MUST NOT be empty.
         See <a href="#section-8">Section 8</a> for a discussion of choosing header fields.

   Attributes MUST NOT appear more than once.  Attribute values are
   limited to a subset of ASCII, which does not require escaping, as
   defined by the plain-string ABNF.

<span class="h3"><a class="selflink" id="section-5.2" href="#section-5.2">5.2</a>.  MAC Input String</span>

   An HTTP message can either be a request from client to server or a
   response from server to client.  Syntactically, the two types of
   message differ only in the start-line, which is either a request-line
   (for requests) or a status-line (for responses).

   Two parameters serve as input to a keyed message digest function: a
   key and an input string.  Depending on the communication direction
   either the request-line or the status-line is used as the first value
   followed by the HTTP header fields listed in the &#x27;h&#x27; parameter.
   Then, the timestamp field and the seq-nr field (if present) is
   concatenated.





<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   As an example, consider the HTTP request with the new line separator
   character represented by &quot;\n&quot; for editorial purposes only.  The h
   parameter is set to h=host, the kid is 314906b0-7c55, and the
   timstamp is 1361471629.


   POST /request?b5=%3D%253D&amp;a3=a&amp;c%40=&amp;a2=r%20b&amp;c2&amp;a3=2+q HTTP/1.1
   Host: example.com

   Hello World!


   The resulting string is:


   POST /request?b5=%3D%253D&amp;a3=a&amp;c%40=&amp;a2=r%20b&amp;c2&amp;a3=2+q HTTP/1.1\n
   1361471629\n
   example.com\n


<span class="h3"><a class="selflink" id="section-5.3" href="#section-5.3">5.3</a>.  Keyed Message Digest Algorithms</span>

   The client uses a cryptographic algorithm together with a session key
   to calculate a keyed message digest.  This specification defines two
   algorithms: &quot;hmac-sha-1&quot; and &quot;hmac-sha-256&quot;, and provides an
   extension registry for additional algorithms.

<span class="h4"><a class="selflink" id="section-5.3.1" href="#section-5.3.1">5.3.1</a>.  hmac-sha-1</span>

   &quot;hmac-sha-1&quot; uses the HMAC-SHA1 algorithm, as defined in [<a href="/doc/html/rfc2104" title="&quot;HMAC: Keyed- Hashing for Message Authentication&quot;">RFC2104</a>]:


     mac = HMAC-SHA1 (key, text)


   Where:

   text

         is set to the value of the input string as described in
         <a href="#section-5.2">Section 5.2</a>,

   key

         is set to the session key provided by the authorization server,
         and

   mac



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 13]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-14" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


         is used to set the value of the &quot;mac&quot; attribute, after the
         result string is base64-encoded per <a href="/doc/html/rfc2045#section-6.8">Section&nbsp;6.8 of [RFC2045]</a>.

<span class="h4"><a class="selflink" id="section-5.3.2" href="#section-5.3.2">5.3.2</a>.  hmac-sha-256</span>

   &quot;hmac-sha-256&quot; uses the HMAC algorithm, as defined in [<a href="/doc/html/rfc2104" title="&quot;HMAC: Keyed- Hashing for Message Authentication&quot;">RFC2104</a>], with
   the SHA-256 hash function, defined in [<a href="#ref-NIST-FIPS-180-3">NIST-FIPS-180-3</a>]:


     mac = HMAC-SHA256 (key, text)


   Where:

   text

         is set to the value of the input string as described in
         <a href="#section-5.2">Section 5.2</a>,

   key

         is set to the session key provided by the authorization server,
         and

   mac

         is used to set the value of the &quot;mac&quot; attribute, after the
         result string is base64-encoded per <a href="/doc/html/rfc2045#section-6.8">Section&nbsp;6.8 of [RFC2045]</a>.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Verifying the Authenticator</span>

   When receiving a message with an authenticator the following steps
   are performed:

   1.  When the authorization server receives a message with a new
       access token (and consequently a new session key) then it obtains
       the session key by retrieving the content of the access token
       (which requires decryption of the session key contained inside
       the token).  The content of the access token, in particular the
       audience field and the scope, MUST be verified as described in
       Alternatively, the kid parameter is used to look-up a cached
       session key from a previous exchange.

   2.  Recalculate the keyed message digest, as described in
       <a href="#section-5.3">Section 5.3</a>, and compare the request MAC to the value received
       from the client via the &quot;mac&quot; attribute.





<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 14]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-15" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   3.  Verify that no replay took place by comparing the value of the ts
       (timestamp) header with the local time.  The processing of
       authenticators with stale timestamps is described in <a href="#section-6.1">Section 6.1</a>.

   Error handling is described in <a href="#section-6.2">Section 6.2</a>.

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Timestamp Verification</span>

   The timestamp field enables the server to detect replay attacks.
   Without replay protection, an attacker can use an eavesdropped
   request to gain access to a protected resource.  The following
   procedure is used to detect replays:

   o  At the time the first request is received from the client for each
      key identifier, calculate the difference (in seconds) between the
      request timestamp and the local clock.  The difference is stored
      locally for later use.

   o  For each subsequent request, apply the request time delta to the
      timestamp included in the message to calculate the adjusted
      request time.

   o  Verify that the adjusted request time is within the allowed time
      period defined by the authorization server.  If the local time and
      the calculated time based in the request differ by more than the
      allowable clock skew (e.g., 5 minutes) a replay has to be assumed.

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  Error Handling</span>

   If the protected resource request does not include an access token,
   lacks the keyed message digest, contains an invalid key identifier,
   or is malformed, the server SHOULD return a 401 (Unauthorized) HTTP
   status code.

   For example:


     HTTP/1.1 401 Unauthorized
     WWW-Authenticate: MAC


   The &quot;WWW-Authenticate&quot; request header field uses the framework
   defined by [<a href="/doc/html/rfc2617" title="&quot;HTTP Authentication: Basic and Digest Access Authentication&quot;">RFC2617</a>] as follows:








<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 15]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-16" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


     challenge   = &quot;MAC&quot; [ 1*SP #param ]
     param       = error / auth-param
     error       = &quot;error&quot; &quot;=&quot; ( token / quoted-string)


   Each attribute MUST NOT appear more than once.

   If the protected resource request included a MAC &quot;Authorization&quot;
   request header field and failed authentication, the server MAY
   include the &quot;error&quot; attribute to provide the client with a human-
   readable explanation why the access request was declined to assist
   the client developer in identifying the problem.

   For example:


     HTTP/1.1 401 Unauthorized
     WWW-Authenticate: MAC error=&quot;The MAC credentials expired&quot;


<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  Example</span>

   [Editor&#x27;s Note: Full example goes in here.]

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  Security Considerations</span>

   As stated in [<a href="/doc/html/rfc2617" title="&quot;HTTP Authentication: Basic and Digest Access Authentication&quot;">RFC2617</a>], the greatest sources of risks are usually
   found not in the core protocol itself but in policies and procedures
   surrounding its use.  Implementers are strongly encouraged to assess
   how this protocol addresses their security requirements and the
   security threats they want to mitigate.

<span class="h3"><a class="selflink" id="section-8.1" href="#section-8.1">8.1</a>.  Key Distribution</span>

   This specification describes a key distribution mechanism for
   providing the session key (and parameters) from the authorization
   server to the client.  The interaction between the client and the
   authorization server requires Transport Layer Security (TLS) with a
   ciphersuite offering confidentiality protection.  The session key
   MUST NOT be transmitted in clear since this would completely destroy
   the security benefits of the proposed scheme.  Furthermore, the
   obtained session key MUST be stored so that only the client instance
   has access to it.  Storing the session key, for example, in a cookie
   allows other parties to gain access to this confidential information
   and compromises the security of the protocol.

<span class="h3"><a class="selflink" id="section-8.2" href="#section-8.2">8.2</a>.  Offering Confidentiality Protection for Access to Protected</span>
<span class="h3">      Resources</span>



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 16]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-17" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   This specification can be used with and without Transport Layer
   Security (TLS).

   Without TLS this protocol provides a mechanism for verifying the
   integrity of requests and responses, it provides no confidentiality
   protection.  Consequently, eavesdroppers will have full access to
   request content and further messages exchanged between the client and
   the resource server.  This could be problematic when data is
   exchanged that requires care, such as personal data.

   When TLS is used then confidentiality can be ensured and with the use
   of the TLS channel binding feature it ensures that the TLS channel is
   cryptographically bound to the used MAC token.  TLS in combination
   with channel bindings bound to the MAC token provide security
   superior to the OAuth Bearer Token.

   The use of TLS in combination with the MAC token is highly
   recommended to ensure the confidentiality of the user&#x27;s data.

<span class="h3"><a class="selflink" id="section-8.3" href="#section-8.3">8.3</a>.  Authentication of Resource Servers</span>

   This protocol allows clients to verify the authenticity of resource
   servers in two ways:

   1.  The resource server demonstrates possession of the session key by
       computing a keyed message digest function over a number of HTTP
       fields in the response to the request from the client.

   2.  When TLS is used the resource server is authenticated as part of
       the TLS handshake.

<span class="h3"><a class="selflink" id="section-8.4" href="#section-8.4">8.4</a>.  Plaintext Storage of Credentials</span>

   The MAC key works in the same way passwords do in traditional
   authentication systems.  In order to compute the keyed message
   digest, the client and the resource server must have access to the
   MAC key in plaintext form.

   If an attacker were to gain access to these MAC keys - or worse, to
   the resource server&#x27;s or the authorization server&#x27;s database of all
   such MAC keys - he or she would be able to perform any action on
   behalf of any client.

   It is therefore paramount to the security of the protocol that these
   session keys are protected from unauthorized access.

<span class="h3"><a class="selflink" id="section-8.5" href="#section-8.5">8.5</a>.  Entropy of Session Keys</span>




<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 17]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-18" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   Unless TLS is used between the client and the resource server,
   eavesdroppers will have full access to requests sent by the client.
   They will thus be able to mount off-line brute-force attacks to
   recover the session key used to compute the keyed message digest.
   Authorization servers should be careful to generate fresh and unique
   session keys with sufficient entropy to resist such attacks for at
   least the length of time that the session keys are valid.

   For example, if a session key is valid for one day, authorization
   servers must ensure that it is not possible to mount a brute force
   attack that recovers the session key in less than one day.  Of
   course, servers are urged to err on the side of caution, and use the
   longest session key reasonable.

   It is equally important that the pseudo-random number generator
   (PRNG) used to generate these session keys be of sufficiently high
   quality.  Many PRNG implementations generate number sequences that
   may appear to be random, but which nevertheless exhibit patterns,
   which make cryptanalysis easier.  Implementers are advised to follow
   the guidance on random number generation in [<a href="/doc/html/rfc4086" title="&quot;Randomness Requirements for Security&quot;">RFC4086</a>].

<span class="h3"><a class="selflink" id="section-8.6" href="#section-8.6">8.6</a>.  Denial of Service / Resource Exhaustion Attacks</span>

   This specification includes a number of features which may make
   resource exhaustion attacks against resource servers possible.  For
   example, a resource server may need to need to consult back-end
   databases and the authorization server to verify an incoming request
   including an access token before granting access to the protected
   resource.

   An attacker may exploit this to perform a denial of service attack by
   sending a large number of invalid requests to the server.  The
   computational overhead of verifying the keyed message digest alone
   is, however, not sufficient to mount a denial of service attack since
   keyed message digest functions belong to the computationally fastest
   cryptographic algorithms.  The usage of TLS does, however, require
   additional computational capabity to perform the asymmetric
   cryptographic operations.  For a brief discussion about denial of
   service vulnerabilities of TLS please consult <a href="#appendix-F.5">Appendix F.5</a> of <a href="/doc/html/rfc5246">RFC</a>
   <a href="/doc/html/rfc5246">5246</a> [<a href="/doc/html/rfc5246" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;">RFC5246</a>].

<span class="h3"><a class="selflink" id="section-8.7" href="#section-8.7">8.7</a>.  Timing Attacks</span>

   This specification makes use of HMACs, for which a signature
   verification involves comparing the received MAC string to the
   expected one.  If the string comparison operator operates in
   observably different times depending on inputs, e.g. because it
   compares the strings character by character and returns a negative



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 18]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-19" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   result as soon as two characters fail to match, then it may be
   possible to use this timing information to determine the expected
   MAC, character by character.

   Implementers are encouraged to use fixed-time string comparators for
   MAC verification.  This means that the comparison operation is not
   terminated once a mismatch is found.

<span class="h3"><a class="selflink" id="section-8.8" href="#section-8.8">8.8</a>.  CSRF Attacks</span>

   A Cross-Site Request Forgery attack occurs when a site, evil.com,
   initiates within the victim&#x27;s browser the loading of a URL from or
   the posting of a form to a web site where a side-effect will occur,
   e.g. transfer of money, change of status message, etc.  To prevent
   this kind of attack, web sites may use various techniques to
   determine that the originator of the request is indeed the site
   itself, rather than a third party.  The classic approach is to
   include, in the set of URL parameters or form content, a nonce
   generated by the server and tied to the user&#x27;s session, which
   indicates that only the server could have triggered the action.

   Recently, the Origin HTTP header has been proposed and deployed in
   some browsers.  This header indicates the scheme, host, and port of
   the originator of a request.  Some web applications may use this
   Origin header as a defense against CSRF.

   To keep this specification simple, HTTP headers are not part of the
   string to be MACed.  As a result, MAC authentication cannot defend
   against header spoofing, and a web site that uses the Host header to
   defend against CSRF attacks cannot use MAC authentication to defend
   against active network attackers.  Sites that want the full
   protection of MAC Authentication should use traditional, cookie-tied
   CSRF defenses.

<span class="h3"><a class="selflink" id="section-8.9" href="#section-8.9">8.9</a>.  Protecting HTTP Header Fields</span>

   This specification provides flexibility for selectively protecting
   header fields and even the body of the message.  At a minimum the
   following fields are included in the keyed message digest.

<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>.  IANA Considerations</span>

<span class="h3"><a class="selflink" id="section-9.1" href="#section-9.1">9.1</a>.  JSON Web Token Claims</span>

   This document adds the following claims to the JSON Web Token Claims
   registry established with [<a href="#ref-I-D.ietf-oauth-json-web-token">I-D.ietf-oauth-json-web-token</a>]:

   o  Claim Name: &quot;kid&quot;



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 19]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-20" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   o  Change Controller: IETF

   o  Specification Document(s): [[ this document ]]

   o  Claim Name: &quot;mac_key&quot;

   o  Change Controller: IETF

   o  Specification Document(s): [[ this document ]]

<span class="h3"><a class="selflink" id="section-9.2" href="#section-9.2">9.2</a>.  MAC Token Algorithm Registry</span>

   This specification establishes the MAC Token Algorithm registry.

   Additional keyed message digest algorithms are registered on the
   advice of one or more Designated Experts (appointed by the IESG or
   their delegate), with a Specification Required (using terminology
   from [<a href="/doc/html/rfc5226" title="">RFC5226</a>]).  However, to allow for the allocation of values
   prior to publication, the Designated Expert(s) may approve
   registration once they are satisfied that such a specification will
   be published.

   Registration requests should be sent to the [TBD]@ietf.org mailing
   list for review and comment, with an appropriate subject (e.g.,
   &quot;Request for MAC Algorithm: example&quot;).  [[ Note to RFC-EDITOR: The
   name of the mailing list should be determined in consultation with
   the IESG and IANA.  Suggested name: http-mac-ext-review. ]]

   Within at most 14 days of the request, the Designated Expert(s) will
   either approve or deny the registration request, communicating this
   decision to the review list and IANA.  Denials should include an
   explanation and, if applicable, suggestions as to how to make the
   request successful.

   Decisions (or lack thereof) made by the Designated Expert can be
   first appealed to Application Area Directors (contactable using app-
   ads@tools.ietf.org email address or directly by looking up their
   email addresses on <a href="http://www.iesg.org/">http://www.iesg.org/</a> website) and, if the
   appellant is not satisfied with the response, to the full IESG (using
   the iesg@iesg.org mailing list).

   IANA should only accept registry updates from the Designated
   Expert(s), and should direct all requests for registration to the
   review mailing list.

<span class="h4"><a class="selflink" id="section-9.2.1" href="#section-9.2.1">9.2.1</a>.  Registration Template</span>

   Algorithm name:



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 20]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-21" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


      The name requested (e.g., &quot;example&quot;).

   Change controller:

      For standards-track RFCs, state &quot;IETF&quot;.  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      e-mail address, home page URI) may also be included.

   Specification document(s):

      Reference to document that specifies the algorithm, preferably
      including a URI that can be used to retrieve a copy of the
      document.  An indication of the relevant sections may also be
      included, but is not required.

<span class="h4"><a class="selflink" id="section-9.2.2" href="#section-9.2.2">9.2.2</a>.  Initial Registry Contents</span>

   The HTTP MAC authentication scheme algorithm registry&#x27;s initial
   contents are:

   o  Algorithm name: hmac-sha-1

   o  Change controller: IETF

   o  Specification document(s): [[ this document ]]

   o  Algorithm name: hmac-sha-256

   o  Change controller: IETF

   o  Specification document(s): [[ this document ]]

<span class="h3"><a class="selflink" id="section-9.3" href="#section-9.3">9.3</a>.  OAuth Access Token Type Registration</span>

   This specification registers the following access token type in the
   OAuth Access Token Type Registry.

<span class="h4"><a class="selflink" id="section-9.3.1" href="#section-9.3.1">9.3.1</a>.  The &quot;mac&quot; OAuth Access Token Type</span>

   Type name:

      mac

   Additional Token Endpoint Response Parameters:

      secret, algorithm

   HTTP Authentication Scheme(s):



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 21]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-22" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


      MAC

   Change controller:

      IETF

   Specification document(s):

      [[ this document ]]

<span class="h3"><a class="selflink" id="section-9.4" href="#section-9.4">9.4</a>.  OAuth Parameters Registration</span>

   This specification registers the following parameters in the OAuth
   Parameters Registry established by [<a href="/doc/html/rfc6749" title="&quot;The OAuth 2.0 Authorization Framework&quot;">RFC6749</a>].

<span class="h4"><a class="selflink" id="section-9.4.1" href="#section-9.4.1">9.4.1</a>.  The &quot;mac_key&quot; OAuth Parameter</span>

   Parameter name:  mac_key

   Parameter usage location:  authorization response, token response

   Change controller:  IETF

   Specification document(s):  [[ this document ]]

   Related information:  None

<span class="h4"><a class="selflink" id="section-9.4.2" href="#section-9.4.2">9.4.2</a>.  The &quot;mac_algorithm&quot; OAuth Parameter</span>

   Parameter name:  mac_algorithm

   Parameter usage location:  authorization response, token response

   Change controller:  IETF

   Specification document(s):  [[ this document ]]

   Related information:  None

<span class="h4"><a class="selflink" id="section-9.4.3" href="#section-9.4.3">9.4.3</a>.  The &quot;kid&quot; OAuth Parameter</span>

   Parameter name:  kid

   Parameter usage location:  authorization response, token response

   Change controller:  IETF

   Specification document(s):  [[ this document ]]



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 22]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-23" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   Related information:  None

<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>.  Acknowledgments</span>

   This document is based on OAuth 1.0 and we would like to thank Eran
   Hammer-Lahav for his work on incorporating the ideas into OAuth 2.0.
   As part of this initial work the following persons provided feedback:
   Ben Adida, Adam Barth, Rasmus Lerdorf, James Manger, William Mills,
   Scott Renfro, Justin Richer, Toby White, Peter Wolanin, and Skylar
   Woodward

   Further work in this document was done as part of OAuth working group
   conference calls late 2012/early 2013 and in design team conference
   calls February 2013.  The following persons (in addition to the OAuth
   WG chairs, Hannes Tschofenig, and Derek Atkins) provided their input
   during these calls: Bill Mills, Justin Richer, Phil Hunt, Prateek
   Mishra, Mike Jones, George Fletcher, Leif Johansson, Lucy Lynch, John
   Bradley, Tony Nadalin, Klaas Wierenga, Thomas Hardjono, Brian
   Campbell

   In the appendix of this document we re-use content from [<a href="/doc/html/rfc4962" title="&quot;Guidance for Authentication, Authorization, and Accounting (AAA) Key Management&quot;">RFC4962</a>] and
   the authors would like thank Russ Housely and Bernard Aboba for their
   work on <a href="/doc/html/rfc4962">RFC 4962</a>.

<span class="h2"><a class="selflink" id="section-11" href="#section-11">11</a>.  References</span>

<span class="h3"><a class="selflink" id="section-11.1" href="#section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-I-D.ietf-httpbis-p1-messaging">I-D.ietf-httpbis-p1-messaging</a>]
              Fielding, R. and J. Reschke, &quot;Hypertext Transfer Protocol
              (HTTP/1.1): Message Syntax and Routing&quot;, <a href="/doc/html/draft-ietf-httpbis-p1-messaging-25">draft-ietf-</a>
              <a href="/doc/html/draft-ietf-httpbis-p1-messaging-25">httpbis-p1-messaging-25</a> (work in progress), November 2013.

   [<a id="ref-I-D.ietf-jose-json-web-encryption">I-D.ietf-jose-json-web-encryption</a>]
              Jones, M., Rescorla, E., and J. Hildebrand, &quot;JSON Web
              Encryption (JWE)&quot;, <a href="/doc/html/draft-ietf-jose-json-web-encryption-19">draft-ietf-jose-json-web-encryption-19</a>
              (work in progress), December 2013.

   [<a id="ref-I-D.ietf-oauth-json-web-token">I-D.ietf-oauth-json-web-token</a>]
              Jones, M., Bradley, J., and N. Sakimura, &quot;JSON Web Token
              (JWT)&quot;, <a href="/doc/html/draft-ietf-oauth-json-web-token-14">draft-ietf-oauth-json-web-token-14</a> (work in
              progress), December 2013.

   [<a id="ref-I-D.richer-oauth-introspection">I-D.richer-oauth-introspection</a>]
              Richer, J., &quot;OAuth Token Introspection&quot;, <a href="/doc/html/draft-richer-oauth-introspection-04">draft-richer-</a>
              <a href="/doc/html/draft-richer-oauth-introspection-04">oauth-introspection-04</a> (work in progress), May 2013.

   [<a id="ref-I-D.tschofenig-oauth-audience">I-D.tschofenig-oauth-audience</a>]



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 23]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-24" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


              Tschofenig, H., &quot;OAuth 2.0: Audience Information&quot;, <a href="/doc/html/draft-tschofenig-oauth-audience-00">draft-</a>
              <a href="/doc/html/draft-tschofenig-oauth-audience-00">tschofenig-oauth-audience-00</a> (work in progress), February
              2013.

   [<a id="ref-RFC2045">RFC2045</a>]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies&quot;, <a href="/doc/html/rfc2045">RFC 2045</a>, November 1996.

   [<a id="ref-RFC2104">RFC2104</a>]  Krawczyk, H., Bellare, M., and R. Canetti, &quot;HMAC: Keyed-
              Hashing for Message Authentication&quot;, <a href="/doc/html/rfc2104">RFC 2104</a>, February
              1997.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2616">RFC2616</a>]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, <a href="/doc/html/rfc2616">RFC 2616</a>, June 1999.

   [<a id="ref-RFC2617">RFC2617</a>]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP
              Authentication: Basic and Digest Access Authentication&quot;,
              <a href="/doc/html/rfc2617">RFC 2617</a>, June 1999.

   [<a id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66, <a href="/doc/html/rfc3986">RFC</a>
              <a href="/doc/html/rfc3986">3986</a>, January 2005.

   [<a id="ref-RFC5226">RFC5226</a>]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, <a href="/doc/html/bcp26">BCP 26</a>, <a href="/doc/html/rfc5226">RFC 5226</a>,
              May 2008.

   [<a id="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, <a href="/doc/html/rfc5246">RFC 5246</a>, August 2008.

   [<a id="ref-RFC6265">RFC6265</a>]  Barth, A., &quot;HTTP State Management Mechanism&quot;, <a href="/doc/html/rfc6265">RFC 6265</a>,
              April 2011.

   [<a id="ref-RFC6749">RFC6749</a>]  Hardt, D., &quot;The OAuth 2.0 Authorization Framework&quot;, <a href="/doc/html/rfc6749">RFC</a>
              <a href="/doc/html/rfc6749">6749</a>, October 2012.

   [<a id="ref-W3C.REC-html401-19991224">W3C.REC-html401-19991224</a>]
              Hors, A., Raggett, D., and I. Jacobs, &quot;HTML 4.01
              Specification&quot;, World Wide Web Consortium Recommendation
              REC-html401-19991224, December 1999,
              &lt;<a href="http://www.w3.org/TR/1999/REC-html401-19991224">http://www.w3.org/TR/1999/REC-html401-19991224</a>&gt;.





<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 24]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-25" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


<span class="h3"><a class="selflink" id="section-11.2" href="#section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-I-D.hardjono-oauth-kerberos">I-D.hardjono-oauth-kerberos</a>]
              Hardjono, T., &quot;OAuth 2.0 support for the Kerberos V5
              Authentication Protocol&quot;, <a href="/doc/html/draft-hardjono-oauth-kerberos-01">draft-hardjono-oauth-kerberos-01</a>
              (work in progress), December 2010.

   [<a id="ref-I-D.tschofenig-oauth-hotk">I-D.tschofenig-oauth-hotk</a>]
              Bradley, J., Hunt, P., Nadalin, A., and H. Tschofenig,
              &quot;The OAuth 2.0 Authorization Framework: Holder-of-the-Key
              Token Usage&quot;, <a href="/doc/html/draft-tschofenig-oauth-hotk-02">draft-tschofenig-oauth-hotk-02</a> (work in
              progress), February 2013.

   [<a id="ref-NIST-FIPS-180-3">NIST-FIPS-180-3</a>]
              National Institute of Standards and Technology, &quot;Secure
              Hash Standard (SHS). FIPS PUB 180-3, October 2008&quot;,
              October 2008.

   [<a id="ref-NIST800-63">NIST800-63</a>]
              Burr, W., Dodson, D., Perlner, R., Polk, T., Gupta, S.,
              and E. Nabbus, &quot;NIST Special Publication 800-63-1,
              INFORMATION SECURITY&quot;, December 2008.

   [<a id="ref-RFC4086">RFC4086</a>]  Eastlake, D., Schiller, J., and S. Crocker, &quot;Randomness
              Requirements for Security&quot;, <a href="/doc/html/bcp106">BCP 106</a>, <a href="/doc/html/rfc4086">RFC 4086</a>, June 2005.

   [<a id="ref-RFC4120">RFC4120</a>]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &quot;The
              Kerberos Network Authentication Service (V5)&quot;, <a href="/doc/html/rfc4120">RFC 4120</a>,
              July 2005.

   [<a id="ref-RFC4279">RFC4279</a>]  Eronen, P. and H. Tschofenig, &quot;Pre-Shared Key Ciphersuites
              for Transport Layer Security (TLS)&quot;, <a href="/doc/html/rfc4279">RFC 4279</a>, December
              2005.

   [<a id="ref-RFC4962">RFC4962</a>]  Housley, R. and B. Aboba, &quot;Guidance for Authentication,
              Authorization, and Accounting (AAA) Key Management&quot;, <a href="/doc/html/bcp132">BCP</a>
              <a href="/doc/html/bcp132">132</a>, <a href="/doc/html/rfc4962">RFC 4962</a>, July 2007.

   [<a id="ref-RFC5056">RFC5056</a>]  Williams, N., &quot;On the Use of Channel Bindings to Secure
              Channels&quot;, <a href="/doc/html/rfc5056">RFC 5056</a>, November 2007.

   [<a id="ref-RFC5849">RFC5849</a>]  Hammer-Lahav, E., &quot;The OAuth 1.0 Protocol&quot;, <a href="/doc/html/rfc5849">RFC 5849</a>,
              April 2010.

   [<a id="ref-RFC5929">RFC5929</a>]  Altman, J., Williams, N., and L. Zhu, &quot;Channel Bindings
              for TLS&quot;, <a href="/doc/html/rfc5929">RFC 5929</a>, July 2010.





<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 25]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-26" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   [<a id="ref-RFC6125">RFC6125</a>]  Saint-Andre, P. and J. Hodges, &quot;Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)&quot;, <a href="/doc/html/rfc6125">RFC 6125</a>, March 2011.

   [<a id="ref-RFC6750">RFC6750</a>]  Jones, M. and D. Hardt, &quot;The OAuth 2.0 Authorization
              Framework: Bearer Token Usage&quot;, <a href="/doc/html/rfc6750">RFC 6750</a>, October 2012.

<span class="h2"><a class="selflink" id="appendix-A" href="#appendix-A">Appendix A</a>.  Background Information</span>

   With the desire to define a security mechanism in addition to bearer
   tokens a design team was formed to collect threats, explore different
   threat mitigation techniques, describe use cases, and to derive
   requirements for the MAC token based security mechanism defined in
   the body of this document.  This appendix provides information about
   this thought process that should help to motivate design decision.

<span class="h3"><a class="selflink" id="appendix-A.1" href="#appendix-A.1">A.1</a>.  Security and Privacy Threats</span>

   The following list presents several common threats against protocols
   utilizing some form of tokens.  This list of threats is based on NIST
   Special Publication 800-63 [<a href="#ref-NIST800-63">NIST800-63</a>].  We exclude a discussion of
   threats related to any form of identity proofing and authentication
   of the Resource Owner to the Authorization Server since these
   procedures are not part of the OAuth 2.0 protocol specification
   itself.

   Token manufacture/modification:

      An attacker may generate a bogus tokens or modify the token
      content (such as authentication or attribute statements) of an
      existing token, causing Resource Server to grant inappropriate
      access to the Client.  For example, an attacker may modify the
      token to extend the validity period.  A Client may modify the
      token to have access to information that they should not be able
      to view.

   Token disclosure:  Tokens may contain personal data, such as real
      name, age or birthday, payment information, etc.

   Token redirect:

      An attacker uses the token generated for consumption by the
      Resource Server to obtain access to another Resource Server.

   Token reuse:




<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 26]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-27" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


      An attacker attempts to use a token that has already been used
      once with a Resource Server.  The attacker may be an eavesdropper
      who observes the communication exchange or, worse, one of the
      communication end points.  A Client may, for example, leak access
      tokens because it cannot keep secrets confidential.  A Client may
      also re-use access tokens for some other Resource Servers.
      Finally, a Resource Server may use a token it had obtained from a
      Client and use it with another Resource Server that the Client
      interacts with.  A Resource Server, offering relatively
      unimportant application services, may attempt to use an access
      token obtained from a Client to access a high-value service, such
      as a payment service, on behalf of the Client using the same
      access token.

   We excluded one threat from the list, namely &#x27;token repudiation&#x27;.
   Token repudiation refers to a property whereby a Resource Server is
   given an assurance that the Authorization Server cannot deny to have
   created a token for the Client.  We believe that such a property is
   interesting but most deployments prefer to deal with the violation of
   this security property through business actions rather than by using
   cryptography.

<span class="h3"><a class="selflink" id="appendix-A.2" href="#appendix-A.2">A.2</a>.  Threat Mitigation</span>

   A large range of threats can be mitigated by protecting the content
   of the token, using a digital signature or a keyed message digest.
   Alternatively, the content of the token could be passed by reference
   rather than by value (requiring a separate message exchange to
   resolve the reference to the token content).  To simplify the
   subsequent description we assume that the token itself is digitally
   signed by the Authorization Server and therefore cannot be modified.

   To deal with token redirect it is important for the Authorization
   Server to include the identifier of the intended recipient - the
   Resource Server.  A Resource Server must not be allowed to accept
   access tokens that are not meant for its consumption.















<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 27]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-28" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   To provide protection against token disclosure two approaches are
   possible, namely (a) not to include sensitive information inside the
   token or (b) to ensure confidentiality protection.  The latter
   approach requires at least the communication interaction between the
   Client and the Authorization Server as well as the interaction
   between the Client and the Resource Server to experience
   confidentiality protection.  As an example, Transport Layer Security
   with a ciphersuite that offers confidentiality protection has to be
   applied.  Encrypting the token content itself is another alternative.
   In our scenario the Authorization Server would, for example, encrypt
   the token content with a symmetric key shared with the Resource
   Server.

   To deal with token reuse more choices are available.

<span class="h4"><a class="selflink" id="appendix-A.2.1" href="#appendix-A.2.1">A.2.1</a>.  Confidentiality Protection</span>

   In this approach confidentiality protection of the exchange is
   provided on the communication interfaces between the Client and the
   Resource Server, and between the Client and the Authorization Server.
   No eavesdropper on the wire is able to observe the token exchange.
   Consequently, a replay by a third party is not possible.  An
   Authorization Server wants to ensure that it only hands out tokens to
   Clients it has authenticated first and who are authorized.  For this
   purpose, authentication of the Client to the Authorization Server
   will be a requirement to ensure adequate protection against a range
   of attacks.  This is, however, true for the description in
   <a href="#appendix-A.2.2">Appendix A.2.2</a> and <a href="#appendix-A.2.3">Appendix A.2.3</a> as well.  Furthermore, the Client
   has to make sure it does not distribute the access token to entities
   other than the intended the Resource Server.  For that purpose the
   Client will have to authenticate the Resource Server before
   transmitting the access token.

<span class="h4"><a class="selflink" id="appendix-A.2.2" href="#appendix-A.2.2">A.2.2</a>.  Sender Constraint</span>

   Instead of providing confidentiality protection the Authorization
   Server could also put the identifier of the Client into the protected
   token with the following semantic: &#x27;This token is only valid when
   presented by a Client with the following identifier.&#x27;  When the
   access token is then presented to the Resource Server how does it
   know that it was provided by the Client?  It has to authenticate the
   Client!  There are many choices for authenticating the Client to the
   Resource Server, for example by using client certificates in TLS
   [<a href="/doc/html/rfc5246" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;">RFC5246</a>], or pre-shared secrets within TLS [<a href="/doc/html/rfc4279" title="&quot;Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)&quot;">RFC4279</a>].  The choice of
   the preferred authentication mechanism and credential type may depend
   on a number of factors, including

   o  security properties



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 28]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-29" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   o  available infrastructure

   o  library support

   o  credential cost (financial)

   o  performance

   o  integration into the existing IT infrastructure

   o  operational overhead for configuration and distribution of
      credentials

   This long list hints to the challenge of selecting at least one
   mandatory-to-implement Client authentication mechanism.

<span class="h4"><a class="selflink" id="appendix-A.2.3" href="#appendix-A.2.3">A.2.3</a>.  Key Confirmation</span>

   A variation of the mechanism of sender authentication described in
   <a href="#appendix-A.2.2">Appendix A.2.2</a> is to replace authentication with the proof-of-
   possession of a specific (session) key, i.e., key confirmation.  In
   this model the Resource Server would not authenticate the Client
   itself but would rather verify whether the Client knows the session
   key associated with a specific access token.  Examples of this
   approach can be found with the OAuth 1.0 MAC token [<a href="/doc/html/rfc5849" title="&quot;The OAuth 1.0 Protocol&quot;">RFC5849</a>],
   Kerberos [<a href="/doc/html/rfc4120" title="&quot;The Kerberos Network Authentication Service (V5)&quot;">RFC4120</a>] when utilizing the AP_REQ/AP_REP exchange (see
   also [<a href="#ref-I-D.hardjono-oauth-kerberos">I-D.hardjono-oauth-kerberos</a>] for a comparison between Kerberos
   and OAuth), the Holder-of-the-Key approach
   [<a href="#ref-I-D.tschofenig-oauth-hotk">I-D.tschofenig-oauth-hotk</a>], and also the MAC token approach defined
   in this document.

   To illustrate key confirmation the first examples borrow from
   Kerberos and use symmetric key cryptography.  Assume that the
   Authorization Server shares a long-term secret with the Resource
   Server, called K(Authorization Server-Resource Server).  This secret
   would be established between them in an initial registration phase.
   When the Client requests an access token the Authorization Server
   creates a fresh and unique session key Ks and places it into the
   token encrypted with the long term key K(Authorization Server-
   Resource Server).  Additionally, the Authorization Server attaches Ks
   to the response message to the Client (in addition to the access
   token itself) over a confidentiality protected channel.  When the
   Client sends a request to the Resource Server it has to use Ks to
   compute a keyed message digest for the request (in whatever form or
   whatever layer).  The Resource Server, when receiving the message,
   retrieves the access token, verifies it and extracts K(Authorization
   Server-Resource Server) to obtain Ks.  This key Ks is then used to
   verify the keyed message digest of the request message.



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 29]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-30" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   Note that in this example one could imagine that the mechanism to
   protect the token itself is based on a symmetric key based mechanism
   to avoid any form of public key infrastructure but this aspect is not
   further elaborated in the scenario.

   A similar mechanism can also be designed using asymmetric
   cryptography.  When the Client requests an access token the
   Authorization Server creates an ephemeral public / privacy key pair
   (PK/SK) and places the public key PK into the protected token.  When
   the Authorization Server returns the access token to the Client it
   also provides the PK/SK key pair over a confidentiality protected
   channel.  When the Client sends a request to the Resource Server it
   has to use the privacy key SK to sign the request.  The Resource
   Server, when receiving the message, retrieves the access token,
   verifies it and extracts the public key PK.  It uses this ephemeral
   public key to verify the attached signature.

<span class="h4"><a class="selflink" id="appendix-A.2.4" href="#appendix-A.2.4">A.2.4</a>.  Summary</span>

   As a high level message, there are various ways how the threats can
   be mitigated and while the details of each solution is somewhat
   different they all ultimately accomplish the goal.

   The three approaches are:

   Confidentiality Protection:

      The weak point with this approach, which is briefly described in
      <a href="#appendix-A.2.1">Appendix A.2.1</a>, is that the Client has to be careful to whom it
      discloses the access token.  What can be done with the token
      entirely depends on what rights the token entitles the presenter
      and what constraints it contains.  A token could encode the
      identifier of the Client but there are scenarios where the Client
      is not authenticated to the Resource Server or where the
      identifier of the Client rather represents an application class
      rather than a single application instance.  As such, it is
      possible that certain deployments choose a rather liberal approach
      to security and that everyone who is in possession of the access
      token is granted access to the data.

   Sender Constraint:

      The weak point with this approach, which is briefly described in
      <a href="#appendix-A.2.2">Appendix A.2.2</a>, is to setup the authentication infrastructure such
      that Clients can be authenticated towards Resource Servers.
      Additionally, Authorization Server must encode the identifier of
      the Client in the token for later verification by the Resource
      Server.  Depending on the chosen layer for providing Client-side



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 30]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-31" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


      authentication there may be additional challenges due Web server
      load balancing, lack of API access to identity information, etc.

   Key Confirmation:

      The weak point with this approach, see <a href="#appendix-A.2.3">Appendix A.2.3</a>, is the
      increased complexity: a complete key distribution protocol has to
      be defined.

   In all cases above it has to be ensured that the Client is able to
   keep the credentials secret.

<span class="h3"><a class="selflink" id="appendix-A.3" href="#appendix-A.3">A.3</a>.  Requirements</span>

   In an attempt to address the threats described in <a href="#appendix-A.1">Appendix A.1</a> the
   Bearer Token, which corresponds to the description in <a href="#appendix-A.2.1">Appendix A.2.1</a>,
   was standardized and the work on a JSON-based token format has been
   started [<a href="#ref-I-D.ietf-oauth-json-web-token">I-D.ietf-oauth-json-web-token</a>].  The required capability to
   protected the content of a JSON token using integrity and
   confidentiality mechanisms is work in progress at the time of
   writing.

   Consequently, the purpose of the remaining document is to provide
   security that goes beyond the Bearer Token offered security
   protection.

   <a href="/doc/html/rfc4962">RFC 4962</a> [<a href="/doc/html/rfc4962" title="&quot;Guidance for Authentication, Authorization, and Accounting (AAA) Key Management&quot;">RFC4962</a>] gives useful guidelines for designers of
   authentication and key management protocols.  While <a href="/doc/html/rfc4962">RFC 4962</a> was
   written with the AAA framework used for network access authentication
   in mind the offered suggestions are useful for the design of other
   key management systems as well.  The following requirements list
   applies OAuth 2.0 terminology to the requirements outlined in <a href="/doc/html/rfc4962">RFC</a>
   <a href="/doc/html/rfc4962">4962</a>.

   These requirements include

   Cryptographic Algorithm Independent:

      The key management protocol MUST be cryptographic algorithm
      independent.

   Strong, fresh session keys:









<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 31]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-32" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


      Session keys MUST be strong and fresh.  Each session deserves an
      independent session key, i.e., one that is generated specifically
      for the intended use.  In context of OAuth this means that keying
      material is created in such a way that can only be used by the
      combination of a Client instance, protected resource, and
      authorization scope.

   Limit Key Scope:

      Following the principle of least privilege, parties MUST NOT have
      access to keying material that is not needed to perform their
      role.  Any protocol that is used to establish session keys MUST
      specify the scope for session keys, clearly identifying the
      parties to whom the session key is available.

   Replay Detection Mechanism:

      The key management protocol exchanges MUST be replay protected.
      Replay protection allows a protocol message recipient to discard
      any message that was recorded during a previous legitimate
      dialogue and presented as though it belonged to the current
      dialogue.

   Authenticate All Parties:

      Each party in the key management protocol MUST be authenticated to
      the other parties with whom they communicate.  Authentication
      mechanisms MUST maintain the confidentiality of any secret values
      used in the authentication process.  Secrets MUST NOT be sent to
      another party without confidentiality protection.

   Authorization:

      Client and Resource Server authorization MUST be performed.  These
      entities MUST demonstrate possession of the appropriate keying
      material, without disclosing it.  Authorization is REQUIRED
      whenever a Client interacts with an Authorization Server.  The
      authorization checking prevents an elevation of privilege attack,
      and it ensures that an unauthorized authorized is detected.

   Keying Material Confidentiality and Integrity:

      While preserving algorithm independence, confidentiality and
      integrity of all keying material MUST be maintained.

   Confirm Cryptographic Algorithm Selection:





<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 32]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-33" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


      The selection of the &quot;best&quot; cryptographic algorithms SHOULD be
      securely confirmed.  The mechanism SHOULD detect attempted roll-
      back attacks.

   Uniquely Named Keys:

      Key management proposals require a robust key naming scheme,
      particularly where key caching is supported.  The key name
      provides a way to refer to a key in a protocol so that it is clear
      to all parties which key is being referenced.  Objects that cannot
      be named cannot be managed.  All keys MUST be uniquely named, and
      the key name MUST NOT directly or indirectly disclose the keying
      material.

   Prevent the Domino Effect:

      Compromise of a single Client MUST NOT compromise keying material
      held by any other Client within the system, including session keys
      and long-term keys.  Likewise, compromise of a single Resource
      Server MUST NOT compromise keying material held by any other
      Resource Server within the system.  In the context of a key
      hierarchy, this means that the compromise of one node in the key
      hierarchy must not disclose the information necessary to
      compromise other branches in the key hierarchy.  Obviously, the
      compromise of the root of the key hierarchy will compromise all of
      the keys; however, a compromise in one branch MUST NOT result in
      the compromise of other branches.  There are many implications of
      this requirement; however, two implications deserve highlighting.
      First, the scope of the keying material must be defined and
      understood by all parties that communicate with a party that holds
      that keying material.  Second, a party that holds keying material
      in a key hierarchy must not share that keying material with
      parties that are associated with other branches in the key
      hierarchy.

   Bind Key to its Context:

      Keying material MUST be bound to the appropriate context.  The
      context includes the following.

      *  The manner in which the keying material is expected to be used.

      *  The other parties that are expected to have access to the
         keying material.

      *  The expected lifetime of the keying material.  Lifetime of a
         child key SHOULD NOT be greater than the lifetime of its parent
         in the key hierarchy.



<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 33]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-34" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


      Any party with legitimate access to keying material can determine
      its context.  In addition, the protocol MUST ensure that all
      parties with legitimate access to keying material have the same
      context for the keying material.  This requires that the parties
      are properly identified and authenticated, so that all of the
      parties that have access to the keying material can be determined.
      The context will include the Client and the Resource Server
      identities in more than one form.

   Authorization Restriction:

      If Client authorization is restricted, then the Client SHOULD be
      made aware of the restriction.

   Client Identity Confidentiality:

      A Client has identity confidentiality when any party other than
      the Resource Server and the Authorization Server cannot
      sufficiently identify the Client within the anonymity set.  In
      comparison to anonymity and pseudonymity, identity confidentiality
      is concerned with eavesdroppers and intermediaries.  A key
      management protocol SHOULD provide this property.

   Resource Owner Identity Confidentiality:

      Resource servers SHOULD be prevented from knowing the real or
      pseudonymous identity of the Resource Owner, since the
      Authorization Server is the only entity involved in verifying the
      Resource Owner&#x27;s identity.

   Collusion:

      Resource Servers that collude can be prevented from using
      information related to the Resource Owner to track the individual.
      That is, two different Resource Servers can be prevented from
      determining that the same Resource Owner has authenticated to both
      of them.  This requires that each Authorization Server obtains
      different keying material as well as different access tokens with
      content that does not allow identification of the Resource Owner.

   AS-to-RS Relationship Anonymity:

      This MAC Token security does not provide AAS-to-RS Relationship
      Anonymity since the Client has to inform the resource server about
      the Resource Server it wants to talk to.  The Authorization Server
      needs to know how to encrypt the session key the Client and the
      Resource Server will be using.




<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 34]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-35" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   As an additional requirement a solution MUST enable support for
   channel bindings.  The concept of channel binding, as defined in
   [<a href="/doc/html/rfc5056" title="&quot;On the Use of Channel Bindings to Secure Channels&quot;">RFC5056</a>], allows applications to establish that the two end-points
   of a secure channel at one network layer are the same as at a higher
   layer by binding authentication at the higher layer to the channel at
   the lower layer.

   Furthermore, there are performance concerns specifically with the
   usage of asymmetric cryptography.  As such, the requirement can be
   phrases as &#x27;faster is better&#x27;.  [QUESTION: How are we trading the
   benefits of asymmetric cryptography against the performance impact?]

   Finally, there are threats that relate to the experience of the
   software developer as well as operational policies.  Verifying the
   servers identity in TLS is discussed at length in [<a href="/doc/html/rfc6125" title="&quot;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)&quot;">RFC6125</a>].

<span class="h3"><a class="selflink" id="appendix-A.4" href="#appendix-A.4">A.4</a>.  Use Cases</span>

   This section lists use cases that provide additional requirements and
   constrain the solution space.

<span class="h4"><a class="selflink" id="appendix-A.4.1" href="#appendix-A.4.1">A.4.1</a>.  Access to an &#x27;Unprotected&#x27; Resource</span>

   This use case is for a web client that needs to access a resource
   where no integrity and confidentiality protection is provided for the
   exchange of data using TLS following the OAuth-based request.  In
   accessing the resource, the request, which includes the access token,
   must be protected against replay, and modification.

   While it is possible to utilize bearer tokens in this scenario, as
   described in [<a href="/doc/html/rfc6750" title="&quot;The OAuth 2.0 Authorization Framework: Bearer Token Usage&quot;">RFC6750</a>], with TLS protection when the request to the
   protected resource is made there may be the desire to avoid using TLS
   between the client and the resource server at all.  In such a case
   the bearer token approach is not possible since it relies on TLS for
   ensuring integrity and confidentiality protection of the access token
   exchange since otherwise replay attacks are possible: First, an
   eavesdropper may steal an access token and represent it at a
   different resource server.  Second, an eavesdropper may steal an
   access token and replay it against the same resource server at a
   later point in time.  In both cases, if the attack is successful, the
   adversary gets access to the resource owners data or may perform an
   operation selected by the adversary (e.g., sending a message).  Note
   that the adversary may obtain the access token (if the
   recommendations in [<a href="/doc/html/rfc6749" title="&quot;The OAuth 2.0 Authorization Framework&quot;">RFC6749</a>] and [<a href="/doc/html/rfc6750" title="&quot;The OAuth 2.0 Authorization Framework: Bearer Token Usage&quot;">RFC6750</a>] are not followed) using a
   number of ways, including eavesdropping the communication on the
   wireless link.





<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 35]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-36" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   Consequently, the important assumption in this use case is that a
   resource server does not have TLS support and the security solution
   should work in such a scenario.  Furthermore, it may not be necessary
   to provide authentication of the resource server towards the client.

<span class="h4"><a class="selflink" id="appendix-A.4.2" href="#appendix-A.4.2">A.4.2</a>.  Offering Application Layer End-to-End Security</span>

   In Web deployments resource servers are often placed behind load
   balancers.  Note that the load balancers are deployed by the same
   organization that operates the resource servers.  These load
   balancers may terminate Transport Layer Security (TLS) and the
   resulting HTTP traffic may be transmitted in clear from the load
   balancer to the resource server.  With application layer security
   independent of the underlying TLS security it is possible to allow
   application servers to perform cryptographic verification on an end-
   to-end basis.

   The key aspect in this use case is therefore to offer end-to-end
   security in the presence of load balancers via application layer
   security.

<span class="h4"><a class="selflink" id="appendix-A.4.3" href="#appendix-A.4.3">A.4.3</a>.  Preventing Access Token Re-Use by the Resource Server</span>

   Imagine a scenario where a resource server that receives a valid
   access token re-uses it with other resource server.  The reason for
   re-use may be malicious or may well be legitimate.  In a legitimate
   use case consider a case where the resource server needs to consult
   third party resource servers to complete the requested operation.  In
   both cases it may be assumed that the scope of the access token is
   sufficiently large that it allows such a re-use.  For example,
   imagine a case where a company operates email services as well as
   picture sharing services and that company had decided to issue access
   tokens with a scope that allows access to both services.

   With this use case the desire is to prevent such access token re-use.
   This also implies that the legitimate use cases require additional
   enhancements for request chaining.

<span class="h4"><a class="selflink" id="appendix-A.4.4" href="#appendix-A.4.4">A.4.4</a>.  TLS Channel Binding Support</span>

   In this use case we consider the scenario where an OAuth 2.0 request
   to a protected resource is secured using TLS but the client and the
   resource server demand that the underlying TLS exchange is bound to
   additional application layer security to prevent cases where the TLS
   connection is terminated at a load balancer or a TLS proxy is used
   that splits the TLS connection into two separate connections.





<span class="grey">Richer, et al.            Expires July 19, 2014                [Page 36]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-37" ></span>
<span class="grey">Internet-Draft            OAuth 2.0 MAC Tokens              January 2014</span>


   In this use case additional information is conveyed to the resource
   server to ensure that no entity entity has tampered with the TLS
   connection.

Authors&#x27; Addresses

   Justin Richer
   The MITRE Corporation

   Email: jricher@mitre.org


   William Mills
   Yahoo! Inc.

   Email: wmills@yahoo-inc.com


   Hannes Tschofenig (editor)
   Austria

   Email: Hannes.Tschofenig@gmx.net
   URI:   <a href="http://www.tschofenig.priv.at">http://www.tschofenig.priv.at</a>


   Phil Hunt
   Oracle Corporation

   Email: phil.hunt@yahoo.com






















Richer, et al.            Expires July 19, 2014                [Page 37]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

